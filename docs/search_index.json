[["index.html", "R과 통계분석 소개하기", " R과 통계분석 박동련 2023-08-23 소개하기 R은 통계분석과 그래프 작성 및 통계적 프로그래밍에 적합한 매우 효과적인 분석 도구이다. 또한 R은 잠시도 정체되어 있지 않고 끊임없이 진화하고 있으며, 놀라운 발전 속도를 항상 보여주고 있다. 특히 패키지 tidyverse의 출현은 매우 주목할 사항이다. 그것은 R의 모습이 tidyverse 이전과 이후로 완전히 구분된다고 할 수 있기 때문이다. 데이터 다루기와 그래프 성능이 비교할 수 없을 만큼 향상되었고, 복잡한 분석 과정이 대폭 단순화되어 매우 효율적인 분석이 가능해졌다. 이러한 발전으로 인하여 R은 이제 data science를 위한 최적의 프로그램으로 자리매김을 확고하게 했다고 할 수 있다. 이 책은 R을 처음 접하는 초급 사용자에게 R의 특징을 소개하는 것뿐만이 아니라 이미 R을 사용하고 있는 중급 사용자에게 실질적인 도움이 될 수 있도록 구성되어 있다. 1장에서 5장까지는 초급 사용자를 위해 R의 기본 개념에 대한 설명을 시작으로 해서, 패키지 readr 등을 활용한 외부 데이터 불러오기, dplyr에 의한 데이터 다듬기 및 ggplot2의 기본 개념을 소개하고 있다. 6장부터 9장까지는 중급 사용자를 위해 tidyr에 의한 데이터 변형, dplyr에 의한 자료 결합, stringr에 의한 문자 다루기 및 purrr에 의한 프로그래밍 기법에 대한 소개가 있으며, 데이터 시각화에 의한 자료탐색 과정에 대한 설명이 예제와 함께 잘 소개되어 있다. 이 책에 포함되어 있는 R code에는 프롬프트(&gt; 또는 +)를 제거하였고, console 창에 출력되는 실행 결과물은 ##으로 시작되도록 하였다. 제공된 R code를 쉽게 복사하는 방법은 R code 블록에 마우스를 놓으면 우측 상단에 기호가 나타나는데, 그 기호를 클릭하는 것이다. R은 data science 분야에서 사용되는 여러 프로그래밍 언어 중에서 가장 뛰어난 통계분석 기능이 있는 언어이다. Data scientist가 되기를 원하시는 분들에게 조금이나마 도움이 되기를 바라는 마음에서 이 책을 출간한다. 이 책을 작성할 때의 R 세션 정보는 다음과 같다. sessionInfo() ## R version 4.3.1 (2023-06-16 ucrt) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 11 x64 (build 22621) ## ## Matrix products: default ## ## ## locale: ## [1] LC_COLLATE=Korean_Korea.utf8 LC_CTYPE=Korean_Korea.utf8 ## [3] LC_MONETARY=Korean_Korea.utf8 LC_NUMERIC=C ## [5] LC_TIME=Korean_Korea.utf8 ## ## time zone: Asia/Seoul ## tzcode source: internal ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] lubridate_1.9.2 forcats_1.0.0 stringr_1.5.0 dplyr_1.1.2 ## [5] purrr_1.0.1 readr_2.1.4 tidyr_1.3.0 tibble_3.2.1 ## [9] ggplot2_3.4.3 tidyverse_2.0.0 ## ## loaded via a namespace (and not attached): ## [1] gtable_0.3.3 jsonlite_1.8.7 compiler_4.3.1 tidyselect_1.2.0 ## [5] jquerylib_0.1.4 scales_1.2.1 yaml_2.3.7 fastmap_1.1.1 ## [9] R6_2.5.1 generics_0.1.3 knitr_1.43 bookdown_0.35 ## [13] munsell_0.5.0 bslib_0.5.1 pillar_1.9.0 tzdb_0.4.0 ## [17] rlang_1.1.1 utf8_1.2.3 stringi_1.7.12 cachem_1.0.8 ## [21] xfun_0.39 sass_0.4.7 timechange_0.2.0 cli_3.6.1 ## [25] withr_2.5.0 magrittr_2.0.3 digest_0.6.33 grid_4.3.1 ## [29] rstudioapi_0.15.0 hms_1.1.3 lifecycle_1.0.3 vctrs_0.6.3 ## [33] evaluate_0.21 glue_1.6.2 fansi_1.0.4 colorspace_2.1-0 ## [37] rmarkdown_2.24 tools_4.3.1 pkgconfig_2.0.3 htmltools_0.5.5 "],["R-start.html", "1 장 R 시작하기 1.1 R의 소개 1.2 R의 설치 1.3 RStudio의 설치 및 R의 실행 1.4 작업공간 1.5 스크립트 파일의 활용 1.6 일괄처리 1.7 R의 확장: 패키지", " 1 장 R 시작하기 1.1 R의 소개 R은 다양한 통계분석과 그래프 작성 등을 위한 프로그래밍 언어이자 개발 환경이다. 뉴질랜드 오클랜드 대학의 Ross Ihaka와 Robert Gentleman에 의해 개발된 오픈 소스 소프트웨어로서 현재는 통계학 및 컴퓨터 분야 등의 쟁쟁한 학자들로 이루어진 R Development Core Team에 의하여 유지 관리되고 있으며 세계 곳곳의 다양한 R 사용자들의 활발한 활동으로 꾸준히 발전되고 있다. 최근 들어 R은 기존 분석 시장의 강자였던 SAS를 능가하 며 분석시장의 판도를 이끌고 있다. 빅데이터 시대를 맞이하여 이미 구글과 같은 인터넷 기업에서 통계자료분석 엔진으로 R이 사용되고 있다는 사실 등은 우리에게 시사하는 바가 크다고 할 것이다. 그럼 무엇 때문에 R이 이와 같이 큰 주목을 받는 것일까? 그것은 다른 통계 소프트웨어들에서는 볼 수 없는 차별화된 장점이 있기 때문일 것이다. 우선 R은 무료로 사용할 수 있다. 이것은 대학뿐만이 아니라 일반 기업에서도 대단히 매력적인 측면이라 할 수 있다. 또한 다양한 형태의 데이터를 이용하여 거의 모든 분야의 통계분석이 가능한 매우 포괄적인 통계 소프트웨어이며, 기존의 어떤 통계 소프트웨어에서도 볼 수 없었던 완벽한 그래프를 간편하게 작성할 수 있다. 더욱이 오픈 소스 소프트웨어이기 때문에 수많은 R 사용자들이 활발하게 분석기법 등을 추가하고 있는데, 이것은 다른 통계 소프트웨어에서는 사용할 수 없는 최첨단 분석기법들을 R에서는 사용할 수 있다는 것을 의미한다. 이외에도 다양한 장점을 지니고 있는 R은 앞으로 계속 발전할 것이며 통계 분석에 관한 기존의 패러다임을 바꾸어 놓을 것이다. R이 다른 통계 소프트웨어와 차별화되는 다양한 장점을 갖고 있는 것은 사실이나 몇 가지 아쉬운 점이 있는 것 또한 사실이다. 오픈 소스 소프트웨어라는 것은 동전의 양면과 같아서 누릴 수 있는 많은 장점들이 있는 동시에 감내해야 될 어려움 또한 존재하는데, R에서 사용할 수 있는 대부분의 분석기법들이 여러 분야의 수많은 사용자들에 의해서 각각 작성되어 올려진다는 것이 바로 그것이다. 다양한 분석기법이 있다는 것은 더할 나위 없이 좋은 점이나, 현재 R에서 어떤 분석기법이 사용 가능하며 그 사용법이 무엇인지를 알아내는 것이 상당히 번거로운 일이 된다. 이 문제에 대한 이해는 R 패키지에 대한 소개가 이루어지면 명확하게 될 것이다. 이 책에서 우리는 R의 다양한 특징에 대하여 알아보고자 한다. 여러 형태의 데이터 입력과 변환 방법, 다양한 분석기법, 그리고 뛰어난 그래프 작성 방법 등을 살펴볼 것이다. R 은 Windows와 Linux 그리고 Mac OS X에서 설치가 가능한데 이 책에서는 Windows를 기반으로 하는 PC에서 운영하는 방법만을 다루고자 한다. 1.2 R의 설치 R은 크게 base 시스템과 패키지로 구분되며 R의 설치는 base 시스템의 설치를 의미한다. 설치 파일은 Comprehensive R Archive Network (CRAN)에 방문하면 얻을 수 있으며, 원활한 다운로드를 위해서는 미러(mirror) 사이트 중 한 곳을 선택하여 방문하는 것이 좋다. 사이트에 설명된 방법에 따라 Windows용 설치 파일을 다운로드하고 설치하면 기본적인 R 사용 준비는 끝나게 된다. R의 업데이트 주기는 매우 짧아서 일 년에도 여러 번 업데이트 버전이 출시된다. 이 책은 버전 4.3.1을 기반으로 하여 작성되었다. 다양한 분석기법들을 사용하기 위해서는 해당 패키지를 설치해야 하는데, 패키지의 설치도 CRAN 사이트에서 할 수 있다. 자세한 내용은 1.7절에서 찾아볼 수 있다. 1.3 RStudio의 설치 및 R의 실행 모든 R 작업은 RStudio에서 진행하는 것이 바람직하다. RStudio는 R을 위한 통합 개발 환경으로서 프로그램의 작성과 실행, 디버깅, 그래프 작성 및 작업공간의 관리, 보고서 작성 등 R과 관련된 모든 작업을 편리하게 수행할 수 있게 한다. R을 설치한 후에는 RStudio에 방문하여 오픈 소스 버전의 설치파일을 다운로드 받아 RStudio를 설치한다. RStudio도 일년에 몇 차례 업데이트 버전이 출시되는데, 이 책에서는 버전 2023.06.1을 사용하고 있다. RStudio를 설치하고 바탕화면에 생성된 아이콘을 더블 클릭하면 그림 1.1과 같은 초기화면이 나타난다. 그림 1.1: RStudio의 초기화면 열린 세 개의 창 중 왼쪽에 있는 Console이라는 이름의 창을 보면 &gt; 기호가 나타나는데 이것이 R의 프롬프트이다. 프롬프트 다음에 명령문을 입력하고 Enter 키를 치면 입력된 명령문이 실행되고, 그 실행 결과가 바로 다음 줄에 나오게 된다.즉 R은 기본적으로 대화형 처리방식(interactive mode)으로 작업을 수행한다. SAS 등에서 사용되는 일괄처리방식 (batch mode)에 익숙한 사용자들에게는 무척 생소하고 불편한 방식으로 느껴지겠지만 최근에 우리가 접하는 데이터가 대부분 매우 복잡한 구조를 갖고 있으며 이러한 데이터는 반드시 여러 단계의 중간분석을 거쳐야 한다는 점을 고려할 때 매우 효율적인 작업방식이라고 하겠다. 물론 동일한 작업이 계속 반복되는 경우라면 일괄처리방식이 훨씬 더 편리하다고 할 수 있을 것이다. 따라서 두 가지 처리방식이 모두 가능하다면 상당히 융통성이 있는 작업수행을 할 수 있게 되는데, R에서는 이 두 가지 처리방식이 모두 가능하다. 일괄처리 방식에 대한 자세한 내용은 1.6절에서 찾아볼 수 있다. R의 작업환경을 이해하기 위해 간단한 예제 프로그램을 실행해 보자. 다음 데이터 세트는 자동차의 주행속도(speed)와 그 속도에서 차를 완전히 멈추는 데 필요한 거리 (dist)를 알아보는 실험 데이터의 일부분이다. 두 변수의 관계를 알아보자. 표 1.1: 예제 데이터 speed dist 4 2 7 4 8 16 9 10 10 18 11 17 12 24 13 34 13 26 14 26 R에서 사용되는 명령문이란 대부분 내장함수 혹은 사용자 정의 함수로 이루어지며, 자료의 입력이란 특정 객체에 데이터를 할당하는 것을 의미한다. 간단한 데이터의 입력은 함수 c()를 이용할 수 있는데, 할당은 &lt;- 기호 또는 = 기호로 이루어진다. 예를 들어 x라는 이름을 가진 벡터 객체에 숫자 10과 11을 할당하는 작업은 다음의 두 명령문 중 어느 하나를 사용하면 된다. 이 책에서 &lt;- 기호를 할당 기호로 사용할 것이며, RStudio에서 할당 기호 &lt;-은 Alt 키와 마이너스(-) 키를 함께 치면 나타난다. x &lt;- c(10,11) x = c(10,11) 예제 데이터의 분석을 위해 우선 함수 c()를 이용하여 두 변수 speed와 dist를 각각 생성하고, 두 변수의 기술통계량을 함수 summary()와 mean(), sd()를 이용하여 각각 계산해 보자. 이어서 두 변수의 산점도를 함수 plot()으로 작성하고, 상관계수를 함수 cor()로 구해 보자. 그림 1.2는 RStudio에서 실행한 결과를 보여주고 있다. speed &lt;- c(4,7,8,9,10,11,12,13,13,14) dist &lt;- c(2,4,16,10,18,17,24,34,26,26) summary(speed) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.00 8.25 10.50 10.10 12.75 14.00 mean(dist) ## [1] 17.7 sd(dist) ## [1] 10.22035 cor(speed, dist) ## [1] 0.9176971 plot(speed, dist) 그림 1.2에서 볼 수 있듯이 실행결과는 Console 창에 바로 나타난다. 작성된 그래프의 경우에는 Plots 창에 나타나며, 생성된 객체에 대한 정보는 Environment 창에 표시되는 것 을 알 수 있다. 그림 1.2: 예제 프로그램 실행 결과 R에서 프로그램을 실행하면서 주의할 점이 있는데, 우선 R에서는 영문자의 대문자와 소문자를 서로 다른 문자로 인식한다. mean(speed) ## [1] 10.1 Mean(speed) ## Error in Mean(speed): could not find function &quot;Mean&quot; 또한 명령문이 완성되지 않은 상태에서 Enter 키를 치면 프롬프트가 &gt; 기호에서 + 기호로 바뀐다. 이 연결 프롬프트는 명령문이 완성될 때까지 계속해서 나오는데, 만일 무엇이 문제인지 알 수 없는 경우에는 Esc 키로 명령문 실행을 취소시켜야 프롬프트가 &gt; 기호로 다시 바뀌게 된다. &gt; cor(dist, + speed) ## [1] 0.9176971 R에서는 # 기호 이후의 명령문은 무시되어 처리되지 않는다. 따라서 명령문에 대한 부가설명을 붙이고자 한다면 # 기호 후에 입력하면 된다. sd(dist) # standard deviation of dist ## [1] 10.22035 1.4 작업공간 작업공간이란 R의 실행 과정에서 생성되는 모든 객체 및 입력된 명령문 등이 보관되어 있는 공간을 의미하는 것이며, 현재의 작업 디렉터리에 임시로 보관되어 있다. 현재의 작업 디렉터리는 함수 getwd()를 실행하면 알 수 있다. 작업공간에 임시 보관되어 있는 객체들은 그림 1.2에서와 같이 Environment 창에서 상세하게 그 내용을 확인할 수 있다. Console 창에서도 함수 ls()를 실행시키면 임시 저장된 객체들의 목록을 얻을 수 있다. 앞서 실행시킨 명령문들은 Console 창에서 ↑ 또는 ↓의 화살표 키를 이용하여 확인하거나, History 창에서 확인할 수 있다. 디폴트로 지정된 작업 디렉터리는 사용자의 필요에 따라 바꿀 수 있는데, Console 창에서 함수 setwd()를 실행하거나, 메인 메뉴 Session &gt; Set Working Directory &gt; Choose Directory…을 선택하여 변경할 수 있다. 함수 setwd()를 이용하는 경우에는 작업 디렉터리로 사용할 폴더를 미리 생성한 후 그 폴더를 지정해야 하고, 메인 메뉴를 이용하는 경우에는 작업 도중에 폴더를 생성할 수 있다. 현재 작업 디렉터리에 임시로 보관되어 있는 객체들을 저장하면 .RData라는 이름의 파일로 저장된다. 저장 방법은 함수 save.image()를 실행하거나, R을 종료할 때 저장하는 방법이 있다. R의 종료는 함수 q()를 실행하거나, RStudio를 종료하면 R도 함께 종료가 되는데, 종료 직전에 현재 작업공간을 저장할 것인지를 묻게 된다. 실행시킨 명령문들은 .Rhistory라는 이름의 파일로 작업 디렉터리에 저장되는 것이 디폴트이다. 디폴트 작업 디렉터리에 저장된 작업공간은 R이 다시 시작되면 자동으로 올라오지만 변경된 작업 디렉터리에 저장된 작업공간은 함수 load()를 실행하거나 메인 메뉴 바에서 Session &gt; Load Workspace……를 이용하여 사용자 스스로 불러와야 한다. 여기서 주의해야 할 사항은 작업 디렉터리의 경로를 나타내는 데 사용되는 슬래시의 방향이 Windows에서와 다르다는 점이다. Windows에서의 올바른 경로 표시는 C:\\Users\\Park\\Documents이지만, R에서는 슬래시의 방향이 반대이다. 만일 Windows에서 사용되는 방향의 슬래시를 사용하고자 한다면, 두 개를 겹쳐서 C:\\\\Users\\\\Park\\\\Documents로 하면 된다. 지금까지 작업공간의 저장 및 디폴트 작업 디렉터리의 변경 방법에 대해서 살펴보았으나, 실제 분석 과정에서는 가급적 사용하지 않는 것이 좋을 것이다. 특히 세션마다 생성되는 객체를 저장하는 것은 차후 분석에 혼선을 줄 가능성이 있기 때문에 반드시 금해야 할 사항이라고 본다. R 종료 시에 작업공간의 저장 여부를 묻는 과정을 생략하려면, RStudio의 메인 메뉴 바에서 Tools &gt; Global options...를 선택하고 나타나는 대화 창에서 Save workspace to .RData on exit을 [Never]로 선택하면 된다. 작업별로 자료, 프로그램, 결과물 등을 분리해서 저장하는 것이 필요한데, 이러한 작업별 공간의 분리는 RStudio의 project를 이용하는 것이 매우 효과적이다. 작업별 project를 설정한다는 것은 해당 작업를 위한 일종의 ‘작업 폴더’ 지정을 의미하는 것으로써, 작업의 모든 자료와 프로그램 및 결과물 등을 특정 폴더에 분리 저장할 수 있게 한다. Project를 사용하기 위한 설정 방법은 다음과 같다. RStudio의 메뉴에서 File &gt; New Project를 선택해서 나타나는 대화 창에서 New Directory를 선택한다. 이어서 나타난 창에서 New Project를 선택하고, 다음에 나타난 창에서 project를 위한 폴더의 위치와 이름을 지정한다. 예를 들어 Project의 이름을 R program이라고 입력해 보자. 그리고 Create Project를 선택하면 RStudio 창이 그림 1.3와 같이 다시 나타난다. RStudio 창의 오른쪽 위에 입력한 Project 이름이 있는 것을 볼 수 있다. 그림 1.3: R Project 생성 Project의 사용법에 대한 자세한 내용은 RStudio support 사이트를 참조하기 바란다. 1.5 스크립트 파일의 활용 지금까지의 R 작업은 Console 창에 명령문을 하나하나 입력하고 실행하여 이루어졌다. 하지만 일일이 명령문을 Console 창에 입력하는 것은 상당히 번거로운 작업이고 오류를 범할 가능성이 많은 방법이다. 비록 이미 실행된 명령문을 자판의 화살표 키를 이용하여 다시 불러내어 수정하는 것이 가능하지만 여전히 불편한 점이 많은 것은 사실이다. 특히 동일한 작업이 반복되는 경우라면 SAS에서와 같이 프로그램 편집기에서 프로그램을 작성한 후 프로그램의 전체 혹은 일부분을 실행시키는 것이 훨씬 더 편리하다고 하겠다. RStudio의 스크립트 편집기는 SAS의 확장 편집기보다 훨씬 다양한 기능을 갖고 있다. 따라서 R 작업을 가장 효과적으로 수행하는 방법은 RStudio의 스크립트 편집기를 이용하 는 것이다. 새로운 스크립트 창을 여는 방법은 메인 메뉴 바에서 File &gt; New File &gt; R Script를 선택하거나, 단축키 Ctrl+Shift+N 키를 누르는 것이다. 스크립트 창은 일반적인 문서 편집기와 동일하게 복사 및 붙여 넣기 등의 편집기능을 갖고 있어서 일련의 명령문 입력 및 수정 등을 훨씬 간편하게 할 수 있다. 또한 구문오류가 있으면 알려주는 기능이 있고, 프로그램의 문제점을 확인해 주기도 한다. 스크립트 창에 입력된 명령문의 실행방식은 상황에 따라 다음 세 가지로 나뉘어진다. 한 명령문씩 차례로 실행해야 하는 경우: 커서를 실행하고자 하는 명령문에 옮겨놓고 Ctrl+Enter 키를 누른다. 해당 명령문이 실행되고 커서는 자동으로 다음 명령문으로 옮겨간다. 몇 개의 명령문을 한꺼번에 실행해야 하는 경우: 마우스를 이용하여 해당되는 명령문들을 선택하고 하이라이트를 시킨 후 Ctrl+Enter 키를 누른다. 선택된 몇 줄의 명령문들이 모두 실행된다. 스크립트 창의 모든 명령문들을 한꺼번에 실행해야 하는 경우: 해당 스크립트 창을 선택하고 Ctrl+Alt+R 키를 누른다. 그림 1.4: 스크립트창을 활용한 작업수행 예 그림 1.4은 RStudio 스크립트 창을 이용한 작업수행의 예를 보여주고 있다. 스크립트 창 을 이용하여 작성된 스크립트 파일의 저장은 Ctrl+S 키를 누르거나, 메뉴 바에서 File &gt; Save 혹은 File &gt; Save As...을 선택하여 폴더와 파일이름을 지정하면 된다. 저장된 스크립트 파일은 다음 작업 때 불러올 수 있는데 Ctrl+O 키를 누르거나, 메뉴 바 에서 File &gt; Open File...를 선택한 후 파일이 저장된 폴더로 이동하여 파일 열기를 선택 하면 된다. 작성된 스크립트 파일을 함수 source()를 이용하여 실행시키는 방법이 있다. 이 방법은 실행되는 스크립트 파일의 내용 및 그 처리 결과를 굳이 Console 창에 출력할 필요가 없 는 경우에 적합한 방법이 된다. 그림 1.5: 파일 ex1.R의 내용 예를 들어 C:\\Users\\Park\\Documents\\My R Files 폴더에 있는 파일 Ex1.R에 그림 1.5와 같은 내용의 명령문이 입력되어 있다고 하자. 벡터 speed를 생성하고 평균 및 표준편차를 계산하는 내용이다. 명령문 sd(speed)에 함수 print()가 적용된 것을 볼 수 있다. 파일 ex1.R의 내용을 함수 source()로 실행시켜 보자. 첫 번째 경우에는 함수 print() 가 적용된 sd(speed)의 결과만이 출력되었고, echo=TRUE라는 옵션이 포함된 두 번째 경 우에는 입력된 명령문 및 그 결과도 모두 출력되었음을 알 수 있다. source(&#39;~/My R Files/Ex1.R&#39;) ## [1] 3.142893 source(&#39;~/My R Files/Ex1.R&#39;, echo = TRUE) ## ## &gt; speed &lt;- c(4, 7, 8, 9, 10, 11, 12, 13, 13, 14) ## ## &gt; mean(speed) ## [1] 10.1 ## ## &gt; print(sd(speed)) ## [1] 3.142893 작업 과정 중에 Plots 창에 생성된 그래프는 간단하게 외부 파일로 저장할 수 있다. 이 작업은 상당히 자주 사용될 것인데, 그것은 R에서 생성된 매우 뛰어난 품질의 그래프를 다른 보고서 등에 인용해야 하는 경우가 많이 있기 때문이다. 생성된 그래프를 MS Word와 같은 워드프로세스에 삽입하는 것은 그래프를 복사하는 것으로 충분하겠지만 Latex에서 이용하기 위해서는 파일로 저장해야 할 것이다. 그림 1.6: 그래프의 복사 및 저장 이미 작성된 그래프의 복사 및 저장 작업은 그림 1.6에서와 같이 Plots 창의 Export 버튼을 클릭하면 나타나는 메뉴에서 선택하면 된다. 또는 메인 메뉴 바에서 Plots &gt; Copy to Clipboard ... 혹은 Plots &gt; Save as Image ...를 선택하면 된다. 그래프의 복사는 metafile과 bitmap 형식으로 가능하며 파일로의 저장은 PNG, JPEG, metafile 등 여러 형태로 가능하다. 그래프를 파일로 저장하는 두 번째 방법은 함수 pdf(), postscript(), bmp(), jpeg() 등을 이용하는 것이다. 그래프를 작성하기 전 원하는 파일 형태에 해당되는 함수를 실행시키고 이어서 그래프를 작성한 후 함수 dev.off()를 실행시키면 작성된 그래프가 파일로 저장된다. speed &lt;- c(4,7,8,9,10,11,12,13,13,14) dist &lt;- c(2,4,16,10,18,17,24,34,26,26) pdf(&quot;plot1.pdf&quot;) plot(dist, speed) dev.off() ## png ## 2 1.6 일괄처리 앞 절에서는 RStudio에서 R 스크립트 파일을 실행하는 방법에 대해서 알아보았다. 이 방법은 대부분의 경우에 적용되는 방법이다. 그러나 경우에 따라서는 스크립트 파일을 일괄 처리방식으로 실행해야 할 수도 있다. 일괄처리는 윈도우 명령 프롬프트 창에서 실행해야 되는 것이므로 RStudio 외부에서만 가능한 것이었으나, RStudio의 최근 버전부터는 내부에서도 가능하게 되었다. 일괄처리방식의 작업이 필요하지 않은 사용자들은 이 절의 내용을 생략해도 무관하다고 본다. RStudio 내부에서 일괄처리방식의 실행은 Console 탭 옆에 있는 Terminal 탭을 누르면 열리는 Terminal 창에서 할 수 있다. Terminal 창은 윈도우 명령 프롬프트 창을 RStudio 내부로 옮겨 놓은 것으로 간주하면 된다. R 스크립트 파일을 일괄처리방식으로 실행시키는 명령문의 기본 형식은 다음과 같다. R CMD BATCH infile outfile Rscript infile 여기서 infile은 스크립트 파일이다. R CMD를 사용하는 경우에는 실행결과가 outfile에 저장되고, Rscript를 사용하는 경우에는 결과가 Terminal 창에 출력된다. 예를 들어 실행시킬 스크립트 파일이 그림 1.5에서 보았던 C:\\Users\\Park\\Documents\\My R Files에 있는 Ex1.R이라고 하자. Terminal 창이 열리면 처음 위치는 현재의 작업 디렉터리가 된다. 따라서 명령문 cd를 이용하여 스크립트 파일이 있는 폴더로 이동한다. Terminal 창에서 사용되는 윈도우 명령 프롬프트 명령문들은 예전에는 DOS 명령문으로 불리던 것으로 매우 생소하게 느껴질 것이다. 실행 과정 및 결과는 그림 1.7과 같다. 그림 1.7: Terminal 창에서 일괄처리 R 외부에서 스크립트 파일을 일괄처리방식으로 실행시키기 위해서는 R 실행 파일이 있는 폴더를 기존의 path에 추가해야 하고, 윈도우 명령 프롬프트 창을 열어야 한다. 먼저 R 실행 파일이 있는 폴더인 C:\\Program Files\\R\\R-4.1.2\\bin\\x64를 Windows 11에서 기존 의 path에 추가하는 방법은 다음과 같다. Windows 시작 버튼 &gt; 설정 &gt; 설정 찾기에서 고급 시스템 설정 입력하고, 이어서 ’고급 시스템 설정 보기`를 클릭 시스템 속성 창이 열리면 고급 탭 하단에 있는 환경 변수를 클릭 환경 변수 창 하단의 시스템 변수에서 Path를 선택하고 편집을 클릭 환경 변수 편집 창에서 찾아보기를 클릭한 후 R 실행 파일이 있는 폴더를 선택하여 그림1.8과 같이 path에 추가 그림 1.8: R 실행 폴더를 path에 추가 이어서 Windows 명령 프롬프트 창을 연다. 몇 가지 방법이 있으나, 그 중 한 방법은 자판에서 윈도우 키를 찾아 윈도우+R 키를 누르면 나타나는 실행 창에 cmd라고 입력하고 확인 키를 누르는 것이다. 이후의 작업은 RStudio 내부에서의 작업과 동일하다. 즉, 실행시킬 스크립트 파일이 있는 폴더로 이동하여 실행한다. 1.7 R의 확장: 패키지 R의 막강한 파워는 다양한 패키지에서 온다고 할 수 있다. 패키지란 사용자가 작성한 R 함수, 데이터 및 컴파일된 코드 등을 모아 놓은 것으로, 다양한 분야의 분석도구를 제공하 고 있다. 2023년 1월 현재 19,000개가 넘는 패키지가 CRAN 사이트에 올라와 있으며, 그 수가 꾸준히 증가하고 있다. 다양한 패키지를 사용할 수 있다는 것은 분석자의 입장에서는 큰 축복이라고 할 수 있으나 너무 많은 수의 패키지가 있기 때문에 각 패키지의 특성을 모두 파악하는 것이 실질적으로 거의 불가능하며, 따라서 사용자가 필요한 특정 분석기법이 어떤 패키지에 있는지를 알아내는 것이 어렵다는 측면도 있다. 또한 개별 사용자들이 직접 작성해서 올린 것이기 때문에 간혹 문제가 있는 패키지가 있을 수도 있다는 점을 항상 유의해야 한다. 1.7.1 패키지의 종류 몇몇 패키지들은 R을 설치할 때(즉, R의 base 시스템을 PC에 설치할 때) 자동으로 설치된 다. 이것들 중 실질적으로 base 시스템의 일부분처럼 작동되는 것이 있는데 여기에는 base, datasets, graphics, grid, methods, stats, utils 등이 포함되며, 이것을 base 패키지라고 한 다. 또한 자동적으로 설치는 되지만 사용하기 위해서는 R 세션으로 따로 불러들여야 하는 패키지들도 있는데 여기에는 KernSmooth, MASS, foreign, lattice 등이 포함되며, 이것을 recommended 패키지라고 한다. 이 두 부류에 포함되지 않는 다른 패키지들은 모두 개별적으로 설치하고 R 세션으로 불러들여야 사용할 수 있다. 사용자가 설치해야 되는 패키지 중에는 C/C++ 또는 Fortran 코드를 컴파일해야 설치가 완료되는 패키지가 있다. 이러한 패키지를 윈도우에 설치하기 위해서는 Rtools를 먼저 설치해야 한다. Rtools의 설치 파일도 CRAN에 방문하면 얻을 수 있으며, R 버전 4.2.0 부터 RTools42를 설치해야 한다. 1.7.2 패키지의 설치 및 사용 패키지를 설치하기 위해서는 함수 install.packages()를 이용하거나, RStudio의 Packages 창에 있는 Install 버튼을 클릭하면 된다. 사용자가 개별적으로 설치하는 패키지가 저장되는 위치는 함수 .libPaths()를 실행하면 나타나는 첫 번째 경로에 설치되는 것이 디폴트이다. 두 번째 경로는 base 패키지와 recommended 패키지가 저장되는 위치이다. 설치된 패키지의 목록은 RStudio의 Packages 창에서 확인할 수 있다. .libPaths() ## [1] &quot;C:/Users/Park/AppData/Local/R/win-library/4.3&quot; ## [2] &quot;C:/Program Files/R/R-4.3.1/library&quot; 예를 들어 John Verzani의 “Using R for Introductory Statistics”라는 책에 있는 여러 가지 함수 및 데이터가 들어 있는 패키지 UsingR을 설치해 보자. Packages 창의 Install 버튼 을 클릭하면 나타나는 창에 그림 1.9와 같이 UsingR을 입력하고, [Install]을 클릭하자. Console 창에 install.packages(\"UsingR\")이 실행되는 것을 확인할 수 있다. 그림 1.9: 패키지 설치 과정 설치된 패키지는 R 세션으로 불러와야 사용할 수 있는데 이 작업은 함수 require() 또는 library()로 하게 된다. 예를 들어 설치된 패키지 UsingR를 R 세션으로 불러오기 위해서는 require(UsingR) 혹은 library(UsingR)를 실행시키면 된다. 이때에는 패키지의 이름에 인용부호를 붙이지 않아야 한다. 두 함수 require()와 library()의 기능에는 약간의 차이가 있는데, 설치되어 있지 않은 패키지를 불러오면 함수 library()는 오류가 발생되지만, 함수 require()는 단순 경고 메시지를 보여준다. 또한 함수 require()는 패키지를 불러오는데 성공하면 TRUE 값을, 실패하면 FALSE 값을 발생시킨다. 이미 설치된 패키지들의 버전 등을 포함한 대략적인 정보는 함수 installed.packages() 로 확인할 수 있으며, 설치된 패키지들을 업데이트시키기 위해서는 함수 update.packages()를 실행시키거나, Packages 창의 Update 버튼을 클릭하면 된다. 특정 패키지에 대한 자세한 도움이 필요한 경우에 help(package=\"패키지 이름\")을 실행 시키면 해당 패키지에 있는 함수와 데이터 등에 대한 설명을 볼 수 있다. 예컨대 help(package=\"MASS\")을 실행시키면, 패키지 MASS에 대한 도움 문서들을 Help 창에서 볼 수 있다. 또한 현재 R 세션에 불러들여져 있는 패키지에 있는 함수나 데이터에 대한 도움은 help(함수 이름)로 얻을 수 있다. 즉, 함수 plot()에 대한 도움은 help(plot) 혹은 물음표 기호를 사용하여 ?plot으로 얻을 수 있다. 조금 더 포괄적인 도움이 필요한 경우에 함수 help.search()를 이용하면 매우 유용한 정보를 얻을 수 있다. 예를 들어 문자열 plot이 포함된 여러 다른 패키지에 있는 다양한 함수들에 대한 도움이 필요한 경우 help.search(\"plot\") 혹은 물음표 기호를 중복시켜 ??plot을 실행시키면 매우 유용한 도움을 받을 수 있다. R은 일 년에도 여러 번 업데이트 버전이 출시된다. 새로운 버전의 R을 다시 설치하기 위해 매번 CRAN 사이트를 방문할 수도 있겠지만, 패키지 installr의 함수 updateR()을 사용하는 것도 좋은 방법이 된다. RGui에서 함수 updateR()을 실행하면, 새로운 버전의 R 출시 여부를 먼저 확인한다. 이어서 나타나는 대화상자에서 설치를 선택하면 새로운 버전의 R이 설치된다. 새로운 버전의 R이 설치되면 이전 버전에서 설치했던 패키지를 다시 설치해야 하는 경우가 있다. 함수 updateR()에서 패키지 이전 작업이 잘 수행되지 않는 경우에는 다음과 같이 실행해 보자. 버전 4.2.3에서 버전 4.3.1로 업데이트한 후, 이전에 설치했던 모든 패키지를 다시 설치하는 작업 내용이다. 사용자가 설치한 패키지의 저장 위치가 버전 4.3과 다르다는 점에 유의하자. old.lib &lt;- &quot;C:/Users/Park/AppData/Local/R/win-library/4.2&quot; install.packages(pkgs=as.data.frame(installed.packages(old.lib))$Package) R은 잠시도 정체되어 있지 않고 끊임없이 진화하고 있다. 이것은 수많은 패키지들이 새로이 나타나고 업데이트되고 있기 때문에 가능한 일이다. 이렇듯 지속적으로 변화하고 있는 R을 제대로 따라가며 이해하는 것은 말 그대로 큰 도전이라고 하겠다. 하지만 다행스러운 일은 세계 곳곳에 활발하게 활동하고 있는 수많은 R 사용자 모임이 있고 그들이 운영하는 많은 웹사이트가 있다는 것이다. 이들 웹사이트를 잘 활용하면 내가 필요한 분석절차가 어떤 패키지에 있는지를 알 수 있으며, 새로운 분석기법에 대한 소개 및 적절한 도움도 받을 수 있을 것이다. 1.7.3 패키지 tidyverse의 소개 tidyverse는 data science를 위해 개발된 패키지들의 묶음이라고 할 수 있다. 여기에 속한 패키지들은 모두 공통된 분석 방식을 공유하고 있으며, 자료분석에 필요한 모든 과정을 망라하고 있다. 패키지 tidyverse에 속한 많은 패키지들은 개별적으로 하나하나 설치할 필요 없이 install.packages(\"tidyverse\")를 실행하면 모든 패키지들이 설치된다. 하지만 이 패키지들을 사용하기 위하여 library(tidyverse)를 실행하면 설치 때와는 다르게 몇몇 패키지들만 R 세션에 올라오는데, 이 몇몇 패키지들을 core tidyverse라고 부른다. 여기에 속하지 않는 다른 많은 패키지들은 모두 개별적으로 함수 library()로 불러와야 한다. 현재 설치된 tidyverse 패키지들의 리스트와 버전 정보 등은 함수 tidyverse_sitrep()으로 다음과 같이 확인할 수 있다. tidyverse_sitrep() ## ── R &amp; RStudio ────────────────────────────────────────────────────────────────── ## • R: 4.3.1 ## ── Core packages ──────────────────────────────────────────────────────────────── ## • dplyr (1.1.2) ## • forcats (1.0.0) ## • ggplot2 (3.4.3) ## • lubridate (1.9.2) ## • purrr (1.0.1 &lt; 1.0.2) ## • readr (2.1.4) ## • stringr (1.5.0) ## • tibble (3.2.1) ## • tidyr (1.3.0) ## ── Non-core packages ──────────────────────────────────────────────────────────── ## • broom (1.0.5) ## • conflicted (1.2.0) ## • dbplyr (2.3.3) ## • dtplyr (1.3.1) ## • googledrive (2.1.1) ## • googlesheets4 (1.1.1) ## • haven (2.5.3) ## • hms (1.1.3) ## • httr (1.4.7) ## • jsonlite (1.8.7) ## • magrittr (2.0.3) ## • modelr (0.1.11) ## • pillar (1.9.0) ## • ragg (1.2.5) ## • readxl (1.4.3) ## • reprex (2.0.2) ## • rlang (1.1.1) ## • rvest (1.0.3) ## • xml2 (1.3.5) core tidyverse에 속하는 패키지의 대략적 기능은 다음과 같다. readr: 자료 불러오기 tibble: 개선된 형태의 데이터 프레임 tidyr: 분석이 편리한 형태인 tidy 자료 생성 dplyr: 데이터 프레임 다루기 stringr: 문자열 다루기 forcats: 요인 다루기 ggplot2: 자료의 시각화 purrr: 함수형 프로그래밍 lubridate : 날짜 다루기 자료분석 내용을 과정별로 나누어 살펴보면, 먼저 분석 대상이 되는 외부 자료를 R로 불러와야 한다. R로 불러온 자료는 대부분의 경우 바로 분석이 가능한 형태를 띠고 있지 않다. 따라서 불러온 자료를 분석이 가능한 형태로 다듬어야 하며, 이어서 분석에 필요한 자료를 생성하는 등의 변형 과정을 거쳐서 자료의 시각화와 모형화 과정을 통해 자료를 분석하게 된다. 이러한 각각의 분석 과정을 담당할 수 있는 패키지가 tidyverse에는 모두 포함되어 있다. 사실 tidyverse로 인하여 R은 완전히 새로 태어났다고 할 수 있는데, 상당히 효율적인 작업이 가능해졌으며, 사용 방식에 일관성이 확립되었고 어렵지 않게 확장할 수 있는 체계가 구성되었기 때문이다. 따라서 데이터를 다듬고 그래프를 작성하는 작업은 이제 base 패키지를 이용하는 것보다 tidyverse의 일원인 dplyr이나 ggplot2 등을 이용하는 것이 훨씬 더 바람직하다고 할 수 있다. "],["data-structure.html", "2 장 R 데이터 구조 2.1 벡터 2.2 요인 2.3 날짜 2.4 행렬 및 배열 2.5 데이터 프레임 2.6 tibble: 개선된 형태의 데이터 프레임 2.7 리스트 2.8 연습문제", " 2 장 R 데이터 구조 통계학에서 데이터는 양적 데이터와 질적 데이터로 구분된다. 양적 데이터는 숫자형 데이터를 의미하는 것으로서 연속형과 이산형 데이터로 구분할 수 있다. 질적 데이터는 범주형 데이터라고도 하며, 다시 명목형과 순서형으로 구분된다. 또한 통계 데이터 세트란 데이터들이 아래의 예제처럼 행과 열의 2차원 형태로 배열된 상태를 의미하는 것이다. 열은 변수를 나타내며 하나의 열에는 같은 유형의 데이터만이 올 수 있고, 행은 동일 대상에 대한 여러 변수들의 관찰값을 나타낸다. ## model mpg cyl disp hp drat wt qsec vs am gear carb ## 1 Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 이렇듯 분석 대상이 되는 통계 데이터는 다양한 유형과 구조를 가지고 있다. 데이터의 다양한 구조를 표현하기 위해 R에서는 벡터, 요인, 행렬, 배열, 데이터 프레임 그리고 리스트라는 이름의 데이터 객체가 있다. 벡터는 하나의 변수를 나타내기 위한 1차원 구조이고, 요인은 범주형 자료를 나타내기 위한 구조이며, 행렬과 데이터 프레임은 2차원 구조, 배열은 2차원 이상의 구조를 가진 데이터 형태이다. 리스트는 가장 포괄적인 형태의 구조로서 여러 유형, 여러 형태의 데이터를 한데 묶은 형태를 취하고 있다. 이 장에서는 다양한 데이터 객체를 생성하는 방법 및 각 객체들의 중요한 특성들을 살펴보고자 한다. 2.1 벡터 벡터는 하나의 변수를 나타내기 위한 것으로써 1차원으로 배열된 데이터 구조를 갖고 있다. 한 변수를 나타내는 것이므로, 벡터를 구성하고 있는 자료는 모두 동일한 유형이어야 하며, 그 유형에 따라 논리형(logical), 숫자형(numeric), 문자형(character)으로 구분된다. 숫자형 벡터는 다시 정수형(integer)과 실수형(double)으로 세분된다. 2.1.1 벡터의 기본 특성 벡터의 생성 벡터는 함수 c()로 만들 수 있다. x &lt;- c(TRUE, FALSE, TRUE) y1 &lt;- c(1L, 3L, 5L) y2 &lt;- c(1.1, 3.5, 10.4) z &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) x는 논리형, y1은 정수형, y2는 실수형, z는 문자형 벡터이다. 논리형 벡터는 TRUE 혹은 FALSE로 이루어진 가장 단순한 형태를 갖고 있으며, 벡터의 비교 결과로 주로 생성된다. 정수형 벡터 y1을 만들 때 사용된 숫자 뒤에 붙는 기호 L은 유형을 정수로 지정하는 효과가 있다. 정수형 벡터와 실수형 벡터는 합쳐서 숫자형 벡터로 분류되며, 문자형 벡터의 구성인자들은 모두 인용부호 \" \" 혹은 ' ' 안에 있어야 한다. 벡터의 특성 벡터의 유형 확인은 함수 typeof()로 할 수 있다. typeof(x) ## [1] &quot;logical&quot; typeof(y1) ## [1] &quot;integer&quot; typeof(y2) ## [1] &quot;double&quot; typeof(z) ## [1] &quot;character&quot; 벡터의 유형 확인은 is.numeric() 또는 is.character()와 같은 is.*() 형식의 함수로 할 수 있는데, is로 시작하는 함수는 입력된 객체의 유형이 *에 지정한 것과 같으면 TRUE, 다르면 FALSE를 출력한다. is.integer(y1) ## [1] TRUE is.double(y1) ## [1] FALSE is.numeric(y1) ## [1] TRUE is.character(z) ## [1] TRUE is.logical(x) ## [1] TRUE 벡터를 구성하고 있는 요소의 개수, 즉 벡터의 길이 확인은 함수 length()로 할 수 있다. 예를 들어 length(y2)는 벡터 y2가 몇 개의 숫자로 구성되어 있는지를 확인하는 것이다. length(y2) ## [1] 3 구성요소가 하나인 벡터를 스칼라(scalar)라고 하는데, 스칼라를 만들 때에는 함수 c()를 사용하지 않아도 된다. 즉, a &lt;- 1 혹은 a &lt;- c(1) 모두 숫자형 벡터 a를 생성한다. a &lt;- 1 a ## [1] 1 벡터는 동일한 유형의 데이터만으로 구성할 수 있는데, 만일 다른 유형의 데이터가 뒤섞여서 있다면 어떤 일이 벌어지겠는가? 아래의 예에서 그 답을 찾을 수 있다. c(1, &quot;1&quot;, TRUE) ## [1] &quot;1&quot; &quot;1&quot; &quot;TRUE&quot; c(3, TRUE, FALSE) ## [1] 3 1 0 첫 번째 예에서 1은 숫자형, \"1\"은 문자형, TRUE는 논리형 데이터이다. 이 데이터를 뒤섞어 입력하면 그 결과는 모두 문자형 데이터로 통일된다. 이것은 문자형이 가장 복잡한 형태의 유형이기 때문이다. 두 번째 예는 숫자형과 논리형 데이터를 함께 입력한 경우이다. 이런 경우에는 논리형 데이터가 숫자형으로 변환되는데, TRUE는 1로, FALSE는 0으로 변환된다. 이것 또한 숫자형이 논리형보다 더 복잡한 유형의 구조이기 때문이다. 벡터 구성요소에 이름 붙이기 모든 벡터는 각 개별 자료에 이름을 붙일 수 있다. 예를 들어 서울, 부산, 인천, 수원의 인구(천 명 단위)를 숫자형 벡터로 입력하면서 각 숫자에 도시 이름을 붙일 수 있다. c(Seoul = 9930, Busan = 3497, Inchon = 2944, Suwon = 1194) ## Seoul Busan Inchon Suwon ## 9930 3497 2944 1194 이미 생성된 벡터의 각 개별자료에 이름을 붙이는 것은 함수 names()로 할 수 있다. pop &lt;- c(9930, 3497, 2944, 1194) names(pop) &lt;- c(&quot;Seoul&quot;, &quot;Busan&quot;, &quot;Inchon&quot;, &quot;Suwon&quot;) pop ## Seoul Busan Inchon Suwon ## 9930 3497 2944 1194 함수 scan()에 의한 벡터 생성 함수 scan()은 다양한 기능을 지니고 있는 함수로서 직접 벡터를 생성할 수도 있고 외부 데이터 파일을 불러와서 벡터에 할당할 수도 있다. 직접 벡터를 생성하기 위해서는 함수 scan()을 그냥 실행하면 된다. 그러면 Console의 프롬프트가 &gt; 기호에서 1: 기호로 바뀌는데, 이것은 첫 번째 자료의 입력을 기다리고 있다는 것을 의미한다. 이어서 데이터를 직접 입력하거나 또는 복사하고 붙여넣기를 할 수 있으며, 한 줄에 여러 개의 숫자를 빈 칸으로 구분하여 입력할 수도 있다. 아래의 예에서 4개 숫자의 입력이 끝나고 나타나는 5: 프롬프트에서 그냥 Enter 키를 치면 데이터의 입력이 종료된 것으로 인식한다. 문자형 벡터의 입력은 옵션 what=\"character\"를 포함해야 한다. 함수 c()의 경우와는 다르게 각각의 자료에 인용부호를 사용할 필요는 없으나, 만일 자료에 빈칸이 포함되어 있다면 그 자료를 인용부호로 감싸야 한다. 한 변수의 자료가 입력되어 있는 데이터 파일을 벡터로 불러오고자 하는 경우에도 함수 scan()을 사용할 수 있다. 텍스트 파일에 입력된 각 자료들은 반드시 한 칸 이상의 빈 칸으로 구분되어 있어야 한다. 예를 들어 Data 폴더에 있는 파일 data1.txt에 다음과 같이 데이터가 저장되어 있다고 하자. 이것을 벡터 z에 입력시키는 방법은 다음과 같이 scan()에 불러올 파일이 저장된 위치를 입력하면 된다. 파일이 저장된 위치는 사용자의 컴퓨터가 될 수도 있고, https:// 등으로 시작되는 웹서버가 될 수도 있다. z &lt;- scan(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data1.txt&quot;) z ## [1] 24 35 28 21 25 2.1.2 다양한 형태를 갖는 벡터의 생성 이 절에서는 기존의 벡터에 데이터를 추가하거나 여러 벡터들을 결합하여 하나의 벡터를 만드는 방법 및 일정한 구조를 갖는 벡터의 생성 방법을 살펴보겠다. 2.1.2.1 벡터에 데이터 추가 및 벡터들의 결합 기존의 벡터에 추가적으로 데이터를 덧붙이는 작업이나 벡터들을 결합하는 작업은 함수 c() 또는 함수 append()를 이용하여 할 수 있다. 우선 c()에 의한 결합 예를 살펴보자. x &lt;- c(11,12,13,14) c(x, 15) ## [1] 11 12 13 14 15 y &lt;- c(16,17,18) c(x, y) ## [1] 11 12 13 14 16 17 18 함수 append()는 추가되는 스칼라 혹은 벡터의 위치를 옵션 after로 지정할 수 있다. append(x, 15) ## [1] 11 12 13 14 15 append(x, 15, after = 2) ## [1] 11 12 15 13 14 append(x, y) ## [1] 11 12 13 14 16 17 18 append(x, y, after = 3) ## [1] 11 12 13 16 17 18 14 2.1.2.2 일정한 구조를 갖는 벡터의 생성 일정한 구조를 갖고 있는 벡터가 필요한 경우가 있다. 예를 들어 1부터 100까지의 정수로 이루어진 벡터를 만들어야 한다고 하자. 이러한 경우 c()에 숫자를 하나하나 입력해야 한다면 무척 한심스러운 일이 될 것이다. 콜론(:) 연산자 또는 seq()를 이용하면 일정한 간격이 있는 자료를 쉽게 만들 수 있으며, rep()를 이용하면 반복된 패턴이 있는 자료를 간편하게 만들 수 있다. 콜론 연산자 콜론 연산자는 연산자의 왼쪽 숫자에서 시작하여 오른쪽 숫자를 초과하지 않을 때까지 1씩 증가하는 수열을 만든다. 왼쪽의 숫자가 오른쪽의 숫자보다 크면 1씩 감소를 시킨다. 1:5 ## [1] 1 2 3 4 5 -3:3 ## [1] -3 -2 -1 0 1 2 3 1.5:5.4 ## [1] 1.5 2.5 3.5 4.5 5:0 ## [1] 5 4 3 2 1 0 함수 seq()에 의한 수열 생성 콜론 연산자는 만들고자 하는 수열의 증가 폭이 1인 경우에만 사용할 수 있다는 한계가 있다. 조금 더 일반적인 형태의 수열을 만드는 작업은 함수 seq()를 사용해야 한다. 가장 기본적인 형태는 옵션 from과 to가 있으면서 by와 length로 수열의 간격 또는 개수를 지정하는 것이다. 시작점(from)과 끝점(to)만이 있다면, 콜론 연산자의 경우와 같이 간격이 1이 된다. 옵션 by는 간격을 지정하는 것으로써 from에서 시작하여 by 만큼 증가(감소)를 시키되 to를 지나치지 않는 수열을 생성한다. 옵션 length는 수열의 개수를 지정하는 것으로써 from과 to를 포함하는 간격이 일정한 수열을 생성한다. 만일 옵션 to가 없다면, from에서 시작하여 by 만큼의 간격이 있는 length개의 수열을 구성한다. seq(from = 0, to = 5) ## [1] 0 1 2 3 4 5 seq(from = 0, to = 5, by = 2) ## [1] 0 2 4 seq(from = 0, to = 5, length = 3) ## [1] 0.0 2.5 5.0 seq(from = 0, by = 2, length = 3) ## [1] 0 2 4 함수 seq()에 하나의 숫자만을 입력하면 1을 시작점으로 하여 1씩 증가(감소)하여 지정된 숫자를 끝점으로 하는 수열이 만들어진다. seq(3) ## [1] 1 2 3 seq(-3) ## [1] 1 0 -1 -2 -3 주어진 벡터와 길이가 같으면서, 1에서부터 시작하고 간격이 1인 수열이 필요한 경우가 있다. 이러한 경우에는 함수 seq()의 옵션 along에 해당되는 벡터를 지정하거나, 옵션 length에 해당 벡터의 길이를 지정하면 된다. 또는 함수 seq_along() 혹은 함수 seq_len()을 대신 사용해도 된다. x &lt;- c(24,31,29) seq(along = x) ## [1] 1 2 3 seq(length = length(x)) ## [1] 1 2 3 seq_along(x) ## [1] 1 2 3 seq_len(length(x)) ## [1] 1 2 3 함수 rep()에 의한 반복된 패턴이 있는 데이터 생성 함수 rep()는 옵션 times와 each, length를 이용하여 다양한 형태의 반복된 패턴이 있는 데이터를 만들 수 있다. 옵션 times는 반복 횟수를 지정하는 것으로써 하나의 정수를 지정할 때와 반복시키려는 벡터의 길이와 같은 정수형 벡터를 지정할 때에 다른 결과가 나온다. rep(1, times = 3) ## [1] 1 1 1 rep(1:3, times = 2) ## [1] 1 2 3 1 2 3 rep(c(&quot;M&quot;,&quot;F&quot;), times = c(2,3)) ## [1] &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; 옵션 times에 하나의 반복 횟수만 지정하면 데이터 전체를 지정된 횟수만큼 반복시킨다. 반복 대상이 c(\"M\",\"F\")이고 반복 횟수가 c(2,3)이 되어 일대일 대응이 되는 경우에는 M이 두 번 먼저 반복되고 이어서 F가 세 번 반복된다. 옵션 each에 반복 횟수를 지정하면, 데이터의 요소들이 각각 each번 반복한다. 이어서 옵션 times를 추가하면 각 요소의 each번 반복 과정 전체가 times만큼 반복된다. rep(1:3, each = 2) ## [1] 1 1 2 2 3 3 rep(1:3, times = rep(2,3)) ## [1] 1 1 2 2 3 3 rep(1:3, each = 2, times = 2) ## [1] 1 1 2 2 3 3 1 1 2 2 3 3 옵션 length에 벡터의 길이를 지정하면, 길이가 length가 될 때까지 데이터 전체가 반복된다. 옵션 each를 함께 사용하면, 데이터 각 요소가 each번 반복되는 과정을 반복하여 결과 벡터의 길이가 length가 되도록 한다. rep(1:3, length = 6) ## [1] 1 2 3 1 2 3 rep(1:3, each = 2, length = 8) ## [1] 1 1 2 2 3 3 1 1 2.1.3 문자열을 위한 함수 R에는 문자열을 다루기 위한 매우 유용한 함수들이 있다. 우리는 종종 문자형 벡터에서 특 정 정보를 얻거나 문자형 벡터의 내용을 수정해야 할 때가 있는데 이런 경우 유용하게 사 용할 수 있는 함수들이 표 2.1에 있다. 표 2.1: 문자 함수 함수 기능 nchar(x) 문자열 x를 구성하는 문자의 개수 paste(…, sep=” “) 문자열의 결합 substr(x, start, stop) 문자열 일부분 선택 toupper(x) 영문자 대문자로 변환 tolower(x) 영문자 소문자로 변환 strsplit(x, split) 문자열의 분리 sub(old, new, x) 문자열 치환 gsub(old, new, x) 문자열 치환 함수 nchar(): 문자열을 구성하는 문자 개수 계산 함수 nchar()는 문자열을 구성하고 있는 문자의 개수를 센다. 다음에 주어진 문자형 벡터 x의 첫 문자열은 4개, 두 번째는 3개, 마지막 문자열은 4개의 문자로 이루어졌다는 것을 알 수 있다. 한글로 이루어진 문자열도 문제 없이 문자 개수를 셀 수 있다. x &lt;- c(&quot;Park&quot;,&quot;Lee&quot;,&quot;Kwon&quot;) nchar(x) ## [1] 4 3 4 nchar(&quot;응용통계학과&quot;) ## [1] 6 함수 paste(): 문자열의 결합 여러 개의 문자열들을 적절하게 결합시켜 새로운 문자열을 만들어야 하는 경우가 자주 있다. 이런 경우에 함수 paste()가 매우 유용하게 사용된다. 함수 paste()의 기본적인 사용법은 결합시키고자 하는 문자열들을 차례로 입력하는 것이고, 옵션 sep에서 지정하는 문자 혹은 빈칸 등이 결합되는 문자열과 문자열 사이에 오게 된다. 5개의 문자열인 “모든”, “사람에게는”, “통계적”, “사고능력이” 그리고 “필요하다”를 결합시켜 보자. 첫 번째는 옵션 sep의 디폴트 값인 sep=\" \"가 사용되어 결합되는 문자열들 사이에 하나의 빈칸이 생긴 것이고, 두 번째는 sep=\"-\"가 지정되어 문자열들이 대시(dash) 기호로 결합되었고, 세 번째에는 sep=\"\"이 사용되어 빈칸 없이 문자열들이 결합되었다. paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;) ## [1] &quot;모든 사람에게는 통계적 사고능력이 필요하다&quot; paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;, sep=&quot;-&quot;) ## [1] &quot;모든-사람에게는-통계적-사고능력이-필요하다&quot; paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;, sep=&quot;&quot;) ## [1] &quot;모든사람에게는통계적사고능력이필요하다&quot; 함수 paste()에 입력된 숫자는 문자로 전환되어 문자열 결합에 사용된다. paste(&quot;원주율은&quot;, pi, &quot;이다&quot;) ## [1] &quot;원주율은 3.14159265358979 이다&quot; 함수 paste() 안에 문자형 벡터 몇 개가 함께 들어오면 벡터들의 대응되는 요소끼리의 결합이 이루어진다. 이때 벡터의 길이가 서로 다르면, 순환법칙이 적용된다. 즉, 문자열 \"Stat\"과 벡터 1:3을 함께 입력하면 실제로는 c(\"Stat\",\"Stat\",\"Stat\")과 1:3이 결합이 되는 것이고, c(\"Stat\",\"Math\")와 1:3을 함께 입력하면, c(\"Stat\",\"Math\", \"Stat\")과 1:3이 결합되는 것이다. paste(c(&quot;Stat&quot;, &quot;Math&quot;), 1:2, sep = &quot;&quot;) ## [1] &quot;Stat1&quot; &quot;Math2&quot; paste(&quot;Stat&quot;, 1:3, sep = &quot;&quot;) ## [1] &quot;Stat1&quot; &quot;Stat2&quot; &quot;Stat3&quot; paste(c(&quot;Stat&quot;, &quot;Math&quot;), 1:3, sep = &quot;-&quot;) ## [1] &quot;Stat-1&quot; &quot;Math-2&quot; &quot;Stat-3&quot; 빈칸 없이 문자열을 결합시킬 때에는 함수 paste()에 옵션 sep=\"\"을 추가하는 것보다 그냥 함수 paste0()을 사용하는 것이 더 편리하다. paste0(&quot;stat&quot;, 1:3) ## [1] &quot;stat1&quot; &quot;stat2&quot; &quot;stat3&quot; 한 개의 문자형 벡터를 구성하고 있는 모든 문자열을 묶어서 하나의 문자열로 나타내는 작업이 필요한 경우가 있다. 이때는 옵션 collapse를 사용하면 된다. 영문자 소문자와 대문자로 구성된 문자형 벡터 letters와 LETTERS를 각각 하나의 문자열로 합쳐보자. letters ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; paste0(letters, collapse = &quot;&quot;) ## [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; paste(LETTERS, collapse = &quot;,&quot;) ## [1] &quot;A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot; 하나의 문자열로 합쳐질 때 옵션 collapse에 지정한 문자가 일종의 구분자 역할을 하고 있다. 함수 paste()에 두 개의 문자형 벡터를 입력하고, 이어서 옵션 collapse를 사용하면 입력된 두 문자형 벡터를 하나의 문자형 벡터로 결합시키고, 이어서 모든 문자열을 묶어서 하나의 문자열로 나타낸다. paste0(letters, LETTERS, collapse = &quot;,&quot;) ## [1] &quot;aA,bB,cC,dD,eE,fF,gG,hH,iI,jJ,kK,lL,mM,nN,oO,pP,qQ,rR,sS,tT,uU,vV,wW,xX,yY,zZ&quot; paste(letters, LETTERS, sep = &quot;-&quot;, collapse = &quot;,&quot;) ## [1] &quot;a-A,b-B,c-C,d-D,e-E,f-F,g-G,h-H,i-I,j-J,k-K,l-L,m-M,n-N,o-O,p-P,q-Q,r-R,s-S,t-T,u-U,v-V,w-W,x-X,y-Y,z-Z&quot; 함수 substr(): 문자열에서 일부분 선택 주어진 문자열에서 일부분을 선택해야 하는 작업도 빈번히 일어나는 중요한 작업 중 하나이다. 함수 substr()에는 문자형 벡터, 시작점, 끝점이 차례로 입력된다. 시작점과 끝점은 각각 정수형 스칼라 혹은 벡터가 된다. 시작점과 끝점이 벡터가 되면, 대응되는 숫자끼리 시작점과 끝점을 구성하며 필요하다면 순환법칙도 적용된다. 아래 예의 첫 번째 결과는 문자형 벡터 x를 구성하고 있는 세 문자에 대하여 동일하게 시작점과 끝점을 하나의 숫자로 지정하여 추출한 것이다. 두 번째 결과는 시작점과 끝점이 벡터로 지정된 것으로 첫 번째 문자열에는 (시작점=1, 끝점=2), 두 번째 문자열에는 (시작 점=3, 끝점=6), 그리고 세 번째 문자열에는 다시 (시작점=1, 끝점=2)가 적용된 결과이다. substr(&quot;Statistics&quot;, 1, 4) ## [1] &quot;Stat&quot; x &lt;- c(&quot;응용통계학과&quot;, &quot;정보통계학과&quot;, &quot;학생회장&quot;) substr(x, 3, 6) ## [1] &quot;통계학과&quot; &quot;통계학과&quot; &quot;회장&quot; substr(x, c(1,3), c(2,6)) ## [1] &quot;응용&quot; &quot;통계학과&quot; &quot;학생&quot; 미국의 세 도시와 그 도시가 속한 주 이름이 입력된 문자형 벡터 x에서 세 도시가 속한 주 이름만을 선택하여 출력해 보자. 비록 세 문자열의 길이가 서로 다르지만 주의 이름은 각 문자열의 마지막 두 칸에 있다는 점에 착안하여 함수 nchar()로 시작점과 끝점을 지정할 수 있다. x &lt;- c(&quot;New York, NY&quot;,&quot;Ann Arbor, MI&quot;,&quot;Chicago, IL&quot;) substr(x, start=nchar(x)-1, stop=nchar(x)) ## [1] &quot;NY&quot; &quot;MI&quot; &quot;IL&quot; 패키지 ggplot2에 있는 데이터 프레임 mpg는 자동차의 연비와 관련된 자료이다. 11개의 변수 중 trans는 변속기 종류를 나타내는 변수이다. 변수 trans가 갖는 값을 살펴보자. 함수 library()로 패키지를 로딩하지 않은 상태에서 해당 패키지의 데이터를 불러오려면 패키지::데이터의 형식을 사용하면 된다. mpg$trans는 데이터 프레임 mpg의 변수 trans를 벡터 형태로 선택한 것이며 자세한 설명은 2.5절에서 찾아볼 수 있다. 또한 함수 table()로 문자형 벡터를 구성하고 있는 각 문자열의 빈도를 계산할 수 있다. x &lt;- ggplot2::mpg$trans table(x) ## x ## auto(av) auto(l3) auto(l4) auto(l5) auto(l6) auto(s4) auto(s5) ## 5 2 83 39 6 3 3 ## auto(s6) manual(m5) manual(m6) ## 16 58 19 auto(av)부터 auto(s6)까지를 auto로 통합하고 manual(m5)와 manual(m6)를 manual로 통합하는 작업은 시작점을 1, 끝점을 nchar(x)-4로 지정함으로써 가능하다. y &lt;- substr(x, start = 1, stop = nchar(x) - 4) table(y) ## y ## auto manual ## 157 77 함수 strsplit(): 문자열의 분할 여러 문자열들을 서로 결합하는 것도 중요한 작업이지만 하나의 문자열을 몇 개로 분리하는 것도 매우 중요한 작업이다. 함수 strsplit()는 주어진 문자열을 옵션 split에 지정된 기준에 의하여 분리시킨다. 문자형 벡터 x에 입력된 세 도시의 이름과 주 이름을 분리해 보자. 도시 이름과 주 이름이 콤마로 구분되어 있기 때문에 분리 기준으로 옵션 split=\",\"을 지정하였다. 결과는 리스트로 출력된다. R 데이터 구조 중 하나인 리스트에 대한 소개는 2.7절에 있다. x &lt;- c(&quot;New York, NY&quot;,&quot;Ann Arbor, MI&quot;,&quot;Chicago, IL&quot;) (y &lt;- strsplit(x, split = &quot;,&quot;)) ## [[1]] ## [1] &quot;New York&quot; &quot; NY&quot; ## ## [[2]] ## [1] &quot;Ann Arbor&quot; &quot; MI&quot; ## ## [[3]] ## [1] &quot;Chicago&quot; &quot; IL&quot; 리스트 y를 생성하는 할당문 전체가 괄호로 감싸여 있는데, 이렇게 할당문을 괄호로 감싸면 할당된 객체의 값이 출력됨을 볼 수 있다. unlist(y) ## [1] &quot;New York&quot; &quot; NY&quot; &quot;Ann Arbor&quot; &quot; MI&quot; &quot;Chicago&quot; &quot; IL&quot; 또한 리스트 객체를 함수 unlist()에 입력하면, 리스트의 모든 구성요소들로 이루어진 벡터가 만들어진다. 문자열을 구성하는 개별 문자들을 모두 분리시키는 작업도 가능한데, 이 경우에는 분리 기준이 옵션 split = \"\"이 되어야 한다. unlist(strsplit(&quot;PARK&quot;, split = &quot;&quot;)) ## [1] &quot;P&quot; &quot;A&quot; &quot;R&quot; &quot;K&quot; 점(.)이 포함된 문자열에서 점을 기준으로 분리하고자 하는 경우에 옵션 split=\".\"을 지정하는 것으로는 원하는 결과를 얻을 수 없다. 옵션 split에는 정규 표현식(regular expression)이 사용되는데, 정규 표현식에서 점(.)은 다른 의미를 갖고 있는 메타 문자로 사용된다. 이러한 경우에는 또 다른 메타 문자인 대괄호를 함께 사용하면 원하는 결과를 얻을 수 있다. 또는 옵션 fixed에 TRUE를 지정하면, 문자 자체의 의미로 사용된다. 정규 표현식에 대한 소개는 6장에서 볼 수 있다. unlist(strsplit(&quot;a.b.c&quot;, split = &quot;.&quot;)) ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; unlist(strsplit(&quot;a.b.c&quot;, split = &quot;[.]&quot;)) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; unlist(strsplit(&quot;a.b.c&quot;, split = &quot;.&quot;, fixed = TRUE)) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 함수 toupper()와 tolower() 가끔 주어진 문자형 벡터를 구성하는 영문자들의 대문자 혹은 소문자를 서로 바꿔야 하는 경우가 생긴다. 이러한 경우에 유용하게 사용할 수 있는 함수가 toupper()와 tolower() 이다. x &lt;- c(&quot;park&quot;,&quot;lee&quot;,&quot;kwon&quot;) (y &lt;- toupper(x)) ## [1] &quot;PARK&quot; &quot;LEE&quot; &quot;KWON&quot; tolower(y) ## [1] &quot;park&quot; &quot;lee&quot; &quot;kwon&quot; 문자열 전체를 바꾸는 것이 아닌 특정 위치에 있는 것만 바꿔야 할 경우가 있다. 문자형 벡터 x를 구성하고 있는 세 문자열의 첫 글자만 대문자로 바꿔보자. 이 경우 우선 함수 substr()로 첫 글자를 추출하고, 그것을 함수 toupper()로 대문자로 변환시킨 후, 그 결 과를 다시 함수 substr()로 추출한 첫 글자를 치환하면 된다. x ## [1] &quot;park&quot; &quot;lee&quot; &quot;kwon&quot; substr(x,1,1) &lt;- toupper(substr(x,1,1)) x ## [1] &quot;Park&quot; &quot;Lee&quot; &quot;Kwon&quot; 함수 sub()와 gsub(): 문자열의 치환 문자열의 일부를 수정하는 작업은 매우 중요한 작업이라 하겠다. 두 함수의 일반적인 사용법은 sub(old, new, x)과 gsub(old, new, x)이 되는데, 문자형 벡터 x를 구성하고 있는 각 문자열 중 old를 new로 치환하는 것이다. 두 함수의 차이점으로 함수 sub()는 각 문자열 중 첫 번째 old만을 new로 치환하지만, 함수 gsub()는 각 문자열의 모든 old를 new로 치환한다는 것이다. x &lt;- &quot;Park hates stats. He hates math, too.&quot; sub(&quot;hat&quot;, &quot;lov&quot;, x) ## [1] &quot;Park loves stats. He hates math, too.&quot; gsub(&quot;hat&quot;, &quot;lov&quot; ,x) ## [1] &quot;Park loves stats. He loves math, too.&quot; 문자형 벡터를 구성하고 있는 각 원소의 치환도 가능하다. (y &lt;- paste0(&quot;banana&quot;, 1:3)) ## [1] &quot;banana1&quot; &quot;banana2&quot; &quot;banana3&quot; sub(&quot;a&quot;, &quot;A&quot;, y) ## [1] &quot;bAnana1&quot; &quot;bAnana2&quot; &quot;bAnana3&quot; gsub(&quot;a&quot;, &quot;A&quot;, y) ## [1] &quot;bAnAnA1&quot; &quot;bAnAnA2&quot; &quot;bAnAnA3&quot; 문자열의 일부를 삭제하고자 한다면 new에 \"\"을 입력하면 된다. z &lt;- &quot;Everybody cannot do it&quot; sub(&quot;not&quot;, &quot;&quot;, z) ## [1] &quot;Everybody can do it&quot; 치환하고자 하는 문자가 정규 표현식에서 다른 의미를 갖고 있는 메타 문자인 경우에는 옵션 fixed에 TRUE를 지정해서 문자 그대로 매칭이 이루어지도록 해야 한다. 메타 문자인 점(.)과 $ 기호가 포함된 문자형 벡터를 만들어 보자. w1 &lt;- c(&quot;a.1&quot;, &quot;a.2&quot;, &quot;a.3&quot;) w2 &lt;- c(&quot;a$1&quot;, &quot;a$2&quot;, &quot;a$3&quot;) 이제 w1에서는 점(.)을 밑줄(_)로 바꾸고, w2에서는 $ 기호를 삭제해 보자. 옵션 fixed의 값을 변경하지 않으면, 원하는 결과를 얻지 못하는 것을 알 수 있다. gsub(&quot;.&quot;, &quot;_&quot;, w1) ## [1] &quot;___&quot; &quot;___&quot; &quot;___&quot; gsub(&quot;$&quot;, &quot;&quot;, w2) ## [1] &quot;a$1&quot; &quot;a$2&quot; &quot;a$3&quot; 옵션 fixed = TRUE를 추가해서 다시 실행해 보자. gsub(&quot;.&quot;, &quot;_&quot;, w1, fixed = TRUE) ## [1] &quot;a_1&quot; &quot;a_2&quot; &quot;a_3&quot; gsub(&quot;$&quot;, &quot;&quot;, w2, fixed = TRUE) ## [1] &quot;a1&quot; &quot;a2&quot; &quot;a3&quot; 2.1.4 벡터의 연산 벡터와 벡터의 연산은 대응되는 각 구성요소끼리의 연산, 즉 벡터 단위로 이루어진다. 이것의 의미는 다음의 예에서 확인할 수 있다. x &lt;- c(7,8,9,10) y &lt;- c(1,2,3,4) x+y ## [1] 8 10 12 14 x-y ## [1] 6 6 6 6 x*y ## [1] 7 16 27 40 x/y ## [1] 7.0 4.0 3.0 2.5 x^y ## [1] 7 64 729 10000 두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산, 즉 첫 번째 숫자끼리 연산, 두 번째 숫자끼리 연산 등등으로 이루어진다. 벡터와 스칼라의 연산도 동일한 개념으로 수행 되어 벡터의 모든 구성요소와 스칼라와의 연산이 이루어진다. x ## [1] 7 8 9 10 x+3 ## [1] 10 11 12 13 x/4 ## [1] 1.75 2.00 2.25 2.50 2^x ## [1] 128 256 512 1024 벡터 연산은 R의 가장 큰 강점 중 하나이다. 벡터 단위의 연산이 가능하지 않은 다른 소프트웨어에서 R의 벡터 연산과 동일한 작업을 수행하기 위해서는 루프(loop)에 의한 반복 작업이 이루어져야 하며, 이것은 프로그램의 복잡성뿐만이 아니라 처리속도에도 악영향을 미치게 된다. 벡터의 연산 결과로 나타날 수 있는 특수 기호에는 Inf, -Inf, NaN 등이 있다. Inf와 –Inf는 무한대와 마이너스 무한대를 나타내는 것이고 NaN은 ’Not a Number’를 나타내는 기호이다. c(-1,0,1)/0 ## [1] -Inf NaN Inf NaN은 0/0 외에도 계산을 할 수 없는 몇몇 상황에서 발생한다. sqrt(-1) ## Warning in sqrt(-1): NaNs produced ## [1] NaN Inf-Inf ## [1] NaN Inf/Inf ## [1] NaN 벡터 연산의 순환법칙 R에서 두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산으로 이루어지는데, 만일 두 벡터의 길이가 달라 일대일 대응이 되지 않는다면 어떤 일이 벌어지겠는가? 이런 경 우에는 길이가 짧은 벡터의 구성요소를 순환 반복시켜 길이가 긴 벡터의 구성요소와 짝을 짓게 된다. 예를 들어 1:6 + 1:3의 경우에는 길이가 3인 1:3을 한 번 반복시켜서 길이가 6인 c(1,2,3,1,2,3)을 만든 후 벡터 연산을 수행하게 된다. 1:6 + 1:3 ## [1] 2 4 6 5 7 9 1:6 + rep(1:3, 2) ## [1] 2 4 6 5 7 9 이와 같은 연산의 순환법칙은 비단 벡터 연산의 경우에만 국한되는 것은 아니고, 다양한 함수의 적용 과정에서도 이 순환법칙이 사용되고 있다. 앞으로 많은 경우에 있어서 순환법칙이 적용되는 상황을 보게 될 것이다. 사실 벡터와 스칼라의 연산도 순환법칙이 적용된 결과로서 c(7,8,9,10)과 3의 덧셈은 3이 4번 반복되어 c(3,3,3,3)이 된 후 덧셈이 이루어지는 것이다. 이러한 순환법칙이 실행될 때 긴 벡터의 길이가 짧은 벡터 길이의 배수가 아니라면 짧은 벡터를 순환 반복시키더라도 긴 벡터와 길이를 동일하게 만들 수 없게 되다. 이런 경우 R은 경고 문구를 내보낸다. 1:4 + 1:3 ## Warning in 1:4 + 1:3: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 5 의도적으로 순환법칙을 사용하지 않은 경우에 이와 같은 경고 문구를 보게 되면 무엇이 문제인지를 면밀히 검토해보는 것이 좋을 것이다. 대부분의 경우 잘못된 연산이 수행되었을 것이다. 수학 계산 관련 함수 R에는 숫자형 벡터를 위한 다양한 함수가 있다. 먼저 기본적인 수학계산과 관련된 함수들 을 살펴보자. 표 2.2에 있는 함수들의 사용 예는 다음과 같다. 표 2.2: 수학 계산과 관련된 함수 함수 설명 abs(x) 절댓값 계산 sqrt(x) 제곱근 계산 ceiling(x) x보다 작지 않은 가장 작은 정수 floor(x) x보다 크지 않은 가장 큰 정수 trunc(x) x의 소수점 이하 버림 round(x, n) x를 소수 n자리로 반올림 signif(x, n) x를 유효수 n자리로 반올림 log(x) x의 자연로그 값 log10(x) x의 사용로그 값 exp(x) x의 지수 함수 값 abs(-2) ## [1] 2 sqrt(25) ## [1] 5 ceiling(3.475) ## [1] 4 floor(3.475) ## [1] 3 ceiling(-3.475) ## [1] -3 floor(-3.475) ## [1] -4 trunc(5.99) ## [1] 5 round(3.475,2) ## [1] 3.48 signif(0.00347, 2) ## [1] 0.0035 sin(1); cos(1); tan(1) ## [1] 0.841471 ## [1] 0.5403023 ## [1] 1.557408 asin(sin(1)); acos(cos(1)); atan(tan(1)) ## [1] 1 ## [1] 1 ## [1] 1 log(2, base = 2) ## [1] 1 log(10) ## [1] 2.302585 log10(10) ## [1] 1 exp(log(10)) ## [1] 10 기초 통계 관련 함수 많이 사용되는 기초적인 통계 계산과 관련된 함수를 살펴보자. 표 2.3에 있는 함수들의 사용 예는 다음과 같다. 표 2.3: 통계 관련 함수 함수 설명 mean(x) 산술 평균값 median(x) 중앙값 range(x) 최솟값과 최댓값 IQR(x) 사분위범위 sum(x) 합 diff(x, n) 차분 min(x) 최솟값 max(x) 최댓값 x &lt;- c(1,2,3,4,50) mean(x) ## [1] 12 median(x) ## [1] 3 range(x) ## [1] 1 50 IQR(x) ## [1] 2 sd(x) ## [1] 21.27205 var(x) ## [1] 452.5 sum(x) ## [1] 60 min(x) ## [1] 1 max(x) ## [1] 50 diff(c(1,2,4,7,11)) ## [1] 1 2 3 4 결측값 데이터에는 그 규모에 관계 없이 결측값이 있을 수 있다. R에서는 결측값을 기호 NA (not available)로 표시한다. 주어진 데이터에 결측값의 포함 여부를 파악하는 것은 모든 분석의 시작이라고 할 수 있으며, 함수 is.na()로 그러한 작업을 할 수 있다. x &lt;- c(1,0,3,5,NA) is.na(x) ## [1] FALSE FALSE FALSE FALSE TRUE 자료에 포함된 결측값의 개수는 함수 is.na()로 생성된 논리형 벡터를 함수 sum()에 입 력하면 계산할 수 있다. sum(is.na(x)) ## [1] 1 결측값의 포함여부를 비교 연산자를 이용하여 x == NA로 파악할 수 있을 것이라고 생각할 수도 있겠으나 결측값은 자기 자신을 포함한 어느 대상과도 비교되지 않는다. 따라서 x == NA의 결과는 모두 NA가 된다. 여기서 두 개의 등호를 연속해서 사용한 기호 ==는 벡터의 비교에 사용되는 비교 연산자로써 자세한 설명은 2.1.5절에서 찾아볼 수 있다. NA가 포함된 벡터를 수학 및 통계 관련 함수들에 적용시키면 많은 경우에 그 결과가 NA 로 출력되며 어떤 경우에는 함수의 실행이 중단되기도 한다. 이것은 R에서 NA를 중요한 요소로 인식하고 있다는 증거가 된다. 몇몇 함수의 경우 계산 과정에서 NA를 제외하고자 한다면 옵션 na.rm=TRUE를 사용해야 한다. mean(x) ## [1] NA max(x) ## [1] NA mean(x, na.rm = TRUE) ## [1] 2.25 max(x, na.rm = TRUE) ## [1] 5 2.1.5 벡터의 비교 두 벡터의 구성요소끼리 크기를 비교하거나, 혹은 벡터와 스칼라를 비교하는 작업 등은 그 자체로도 의미가 있지만 벡터의 인덱싱이나 벡터의 변환 등에서 필수적인 요소가 된다. 어느 경우든 적절한 비교를 위해서는 비교 연산자와 논리 연산자가 필요하다. 표 2.4: 비교/논리 연산자 연산자 기능 &lt; 작다 &lt;= 작거나 같다 &gt; 크다 &gt;= 크거나 같다 == 같다 != 같지 않다 !x x가 아니다 (NOT) x | y x 또는 y (OR) x &amp; y x 그리고 y (AND) R의 큰 강점 중 하나가 벡터 연산이 가능하다는 것인데 두 벡터의 비교도 벡터 연산으 로 이루어진다. 즉, 두 벡터 사이에 대응되는 구성요소끼리의 비교가 이루어지는 것이다. 따라서 3개의 숫자로 구성된 두 벡터를 비교하면 그 구성요소 각각을 비교한 3개의 TRUE 또는 FALSE가 결과로 출력된다. x &lt;- c(3, 8, 2) y &lt;- c(5, 4, 2) x &gt; y ## [1] FALSE TRUE FALSE x &gt;= y ## [1] FALSE TRUE TRUE x &lt; y ## [1] TRUE FALSE FALSE x &lt;= y ## [1] TRUE FALSE TRUE x == y ## [1] FALSE FALSE TRUE x != y ## [1] TRUE TRUE FALSE 벡터와 스칼라의 비교는 숫자 하나를 벡터의 모든 구성요소와 비교하게 되는 것으로 연산의 순환법칙이 적용된 것이다. x &lt;- 1:3 x &gt; 2 ## [1] FALSE FALSE TRUE x &lt; 2 ## [1] TRUE FALSE FALSE x &lt;= 2 | x &gt;= 3 ## [1] TRUE TRUE TRUE x &lt;= 2 &amp; x &gt;= 1 ## [1] TRUE TRUE FALSE 벡터의 비교가 이루어지면 벡터의 길이만큼의 논리형 벡터가 결과로 출력된다. 이때 만일 각 구성요소 차원의 세세한 결과보다 전체 비교 중 한 번이라도 사실이 있는지, 혹은 모든 비교가 사실인지가 중요한 결과인 경우에는 함수 any()와 all()이 유용하게 사용될 수 있다. x &lt;- 1:5 any(x &gt;= 4) ## [1] TRUE all(x &gt;= 4) ## [1] FALSE 주어진 벡터의 구성요소 중 특정 조건을 만족시키는 요소의 개수 혹은 비율을 알고자 하는 경우에도 논리형 벡터는 매우 유용하게 사용된다. 예를 들어 주어진 숫자형 벡터 x 중 4보다 크거나 같은 숫자의 개수와 비율은 다음과 같이 논리형 벡터를 함수 sum() 또는 mean()에 적용시켜 구할 수 있다. x &lt;- 1:5 x &gt;= 4 ## [1] FALSE FALSE FALSE TRUE TRUE sum(x &gt;= 4) ## [1] 2 mean(x &gt;= 4) ## [1] 0.4 주어진 벡터의 구성요소 중 특정한 값이 포함되어 있는지를 확인해야 하는 경우에는 %in% 연산자가 매우 유용하게 사용된다. x &lt;- 1:5 x %in% c(2,4) ## [1] FALSE TRUE FALSE TRUE FALSE 벡터 x의 구성요소 하나하나와 %in% 연산자 오른쪽에 주어진 값을 비교하여 같은 값이 면 TRUE, 아니면 FALSE가 생성된다. 만일 벡터 x에 c(2,4)가 포함되어 있는지 여부를 x == c(2,4)로 확인하려고 한다면 어떤 결과가 나오는지 살펴보자. x == c(2,4) ## Warning in x == c(2, 4): longer object length is not a multiple of shorter ## object length ## [1] FALSE FALSE FALSE TRUE FALSE 여기에서 이루어진 작업은 길이가 다른 벡터 x와 c(2,4)에 대한 비교이다. 따라서 길이가 짧은 벡터 c(2,4)를 순환 반복시켜서 실질적으로는 x == c(2,4,2,4,2)가 실행된 것이므로, 원하는 작업을 수행한 것이 아니다. 2.1.6 벡터의 인덱싱 벡터의 인덱싱(indexing)이란 벡터의 일부분만을 선택하는 것을 의미하는 것으로, 하나의 대괄호를 인덱싱 기호로 사용한다. 즉, x[a]의 형태가 되는데, 여기서 a는 정수형 벡터와 논리형 벡터가 사용되며, 이름이 있는 벡터의 경우에는 문자형 벡터도 가능하다. 정수형 벡터가 모두 양수인 경우에는 지정된 위치의 자료를 선택하는 것이고, 모두 음수인 경우에는 지정된 위치의 자료를 제외하는 것이다. 양수와 음수를 혼합하여 지정할 수는 없다. y &lt;- c(2, 4, 6, 8, 10) y[c(1, 3, 5)] ## [1] 2 6 10 y[c(-2, -4)] ## [1] 2 6 10 같은 위치를 반복해서 지정할 수 있으며, 지정한 위치가 벡터의 길이보다 크면 지정할 자료가 없기 때문에 결측값인 NA가 출력된다. y[c(2, 2, 2)] ## [1] 4 4 4 y[0] ## numeric(0) y[6] ## [1] NA 이름이 있는 벡터의 경우에는 문자형 벡터를 사용하여 인덱싱을 할 수 있다. 벡터 pop에서 Seoul과 Suwon의 인구만을 선택해 보자. pop &lt;- c(Seoul = 9930, Busan = 3497, Inchon = 2944, Suwon = 1194) pop[c(&quot;Seoul&quot;, &quot;Suwon&quot;)] ## Seoul Suwon ## 9930 1194 논리형 벡터를 사용하는 경우에는 TRUE가 있는 위치의 자료만 선택되는데, 이러한 인덱싱은 벡터의 비교에 따른 자료 선택에서 유용하게 사용된다. y ## [1] 2 4 6 8 10 y[c(TRUE, TRUE, FALSE, FALSE, TRUE)] ## [1] 2 4 10 y &gt; 3 ## [1] FALSE TRUE TRUE TRUE TRUE y[y &gt; 3] ## [1] 4 6 8 10 조건에 의한 인덱싱 논리형 벡터에 의한 인덱싱의 경우에는 TRUE인 위치의 자료가 선택된다고 하였는데, 이러한 논리형 벡터는 주로 벡터의 비교 결과로 생성된다. 이것은 곧 주어진 조건을 만족시키는 요소만을 선택할 수 있다는 것을 의미한다. 벡터 x의 각 개별 값 중 벡터 x의 평균값보다 큰 값을 선택해 보자. 우선 벡터 x의 개별값과 평균값의 크기를 비교해 보자. x &lt;- c(80, 88, 90, 93, 95, 94, 99, 78, 101) x &gt;= mean(x) ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE TRUE FALSE는 작은 경우를, TRUE는 크거나 같은 경우를 나타내고 있다. 이 결과를 대괄호에 입력시키면 평균값보다 크거나 같은 개별 값들만이 선택된다. x[x &gt;= mean(x)] ## [1] 93 95 94 99 101 위에서 소개된 방법을 이용하여 다음의 조건을 만족시키는 개별 관찰값을 각각 선택해 보자. 평균으로부터 ±1 표준편차 안에 있는 관찰값 평균으로부터 ±1 표준편차와 ±2 표준편차 사이에 있는 관찰값 평균으로부터 ±2 표준편차를 벗어나는 관찰값 진행 절차는 우선 벡터 x를 표준화시켜 그것을 벡터 z에 할당하고 이어서 벡터 z로 각 조건을 나타내는 비교를 실시하여 그 결과를 벡터 x의 대괄호에 입력하면 된다. 평균으로 부터 ±2 표준편차를 벗어나는 관찰값은 없는 것으로 나타났다. z &lt;- (x-mean(x))/sd(x) x[abs(z) &lt;= 1] # 1 ## [1] 88 90 93 95 94 x[abs(z) &gt; 1 &amp; abs(z) &lt;= 2] # 2 ## [1] 80 99 78 101 x[abs(z) &gt; 2] # 3 ## numeric(0) 2.2 요인 명목형 혹은 순서형 데이터와 같은 범주형 데이터를 나타내기 위한 구조를 요인(factor)이 라고 한다. 1차원 구조를 갖고 있는 요인이 취하는 값을 수준(level)이라고 하는데, 따라서 요인은 level 속성을 가진 벡터라 할 수 있으며 데이터 분석에서 매우 중요한 역할을 하고 있다. 2.2.1 요인의 기본 특성 명목형 요인의 생성 주어진 벡터를 요인으로 변환시키는 작업은 함수 as.factor() 또는 factor()로 할 수 있다. gender &lt;- c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) gender_f &lt;- as.factor(gender) gender_f ## [1] Male Female Female ## Levels: Female Male 함수 as.factor()는 수준의 개수나 이름 등의 변화 없이 벡터를 요인으로 변환하는 작업을 수행한다. 문자형 벡터에서 요인으로 변환된 gender_f의 개별자료에는 인용부호가 없어지고 대신 level이 다음 줄에 나타나는데, 알파벳순으로 Female이 첫 번째, Male이 두 번째가 되었다. 요인이 갖고 있는 수준의 이름 등을 바꾸고자 하는 경우에는 함수 factor()을 사용해야 한다. 옵션 labels에 수준의 개수와 길이가 같은 문자형 벡터를 지정해 주면 수준의 이름이 변경된다. 예를 들어 다음의 숫자형 벡터 x를 요인으로 변환하면 숫자가 수준이 되는데, 이것에 다른 이름을 주는 방법은 다음과 같다. x &lt;- c(1, 3, 2, 2, 1, 4) factor(x) ## [1] 1 3 2 2 1 4 ## Levels: 1 2 3 4 x1 &lt;- factor(x, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;)) x1 ## [1] A C B B A D ## Levels: A B C D 옵션 labels에 수준의 개수만큼의 문자를 지정하였다. 만일 labels에 같은 문자를 반복해서 입력하면 요인의 수준이 합쳐지게 된다. 예를 들어 벡터 x의 네 개 수준에서 (1, 2)를 A로 합치고 (3, 4)를 B로 합쳐서 두 개 수준으로 병합하고자 한다면 다음과 같이하면 된다. x2 &lt;- factor(x, labels = c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;)) x2 ## [1] A B A A A B ## Levels: A B 함수 nlevels()과 levels()를 사용하면 요인의 수준 개수와 이름을 확인할 수 있다. levels(x1) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; levels(x2) ## [1] &quot;A&quot; &quot;B&quot; nlevels(x1) ## [1] 4 nlevels(x2) ## [1] 2 요인의 유형 및 속성 요인의 유형 및 속성을 확인하기 위하여 함수 typeof()와 class()를 사용해 보자. typeof(gender_f) ## [1] &quot;integer&quot; class(gender_f) ## [1] &quot;factor&quot; 함수 typeof()로 확인한 요인의 유형은 정수형 벡터이다. R 내부에서는 첫 번째 수준인 Female이 1로, 두 번째 수준인 Male이 2로 저장된다. 함수 class()는 객체가 가진 부가적인 속성 중 class 속성을 확인하는 함수인데, 이 속성은 객체 지향 프로그램에서 매우 중요한 역할을 하는 속성이다. 예를 들어 함수 summary()는 입력되는 객체의 class 속성에 따라 다른 분석을 실시하는 generic 함수 중 하나이다. 함수 summary()에 문자형 벡터 gender와 요인 gender_f를 입력시키면 각 속성에 적합한 다른 분석 결과가 출력됨을 알 수 있다. summary(gender) ## Length Class Mode ## 3 character character summary(gender_f) ## Female Male ## 2 1 순서형 요인의 생성 순서형 요인을 만들기 위해서는 함수 factor()에 order = TRUE를 포함시켜야 하고, 원하는 수준의 순서가 알파벳 순서와 다른 경우에는 옵션 level에서 사용자가 직접 지정해야 한다. income &lt;- c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;, &quot;Medium&quot;) factor(income, order = TRUE) ## [1] Low Medium High Medium ## Levels: High &lt; Low &lt; Medium factor(income, order = TRUE, level = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) ## [1] Low Medium High Medium ## Levels: Low &lt; Medium &lt; High 2.2.2 숫자형 벡터를 요인으로 변환 통계분석과정에서 기존의 숫자형 변수를 범주형 변수로 변환시켜야 하는 경우가 종종 있는데, 시험점수(숫자형 변수)를 기반으로 특정 기준에 따라 학점(범주형 변수)을 부여하는 경우가 여기에 해당된다고 하겠다. 이러한 경우 숫자형 변수가 취할 수 있는 값의 전체 범위를 특정 기준에 따라 일정구간으로 나누고 각 구간에 개별 값이 속하면 해당 범주의 값을 갖게하면 된다. 논리형 벡터에 의한 변수 변환 예를 들어 0에서 100 사이의 값을 갖는 숫자형 벡터 x를 ‘90 이상’, ‘90 미만 80 이상’, ’80 미만’의 세 등분으로 구분하여 각각 A, B, C의 값을 갖는 요인 cat.x로 변환해 보자. 변환방법으로 우선 논리형 벡터를 사용하는 방법을 생각해 볼 수 있다. 조금씩 다른 세 가지 방법을 살펴보자. 각 방법 모두 세 번의 벡터 비교가 이루어졌는데, 각 괄호 안에는 비교 결과인 TRUE와 FALSE로 이루어진 논리형 벡터가 생성되며, 이 논리형 벡터들이 사칙연산에 적용되면 TRUE는 1, FALSE는 0으로 전환되는 것을 이용하였다. 첫 번째 방법에서는 90 이상의 값들이 세 번의 비교에서 모두 1의 값을 갖게 되지만 80 이상 90 미만의 값들은 두 번의 비교에서만 1의 값을 갖게 되고, 80 미만의 값들은 한 번의 비교에서만 1의 값을 갖게 되는 구조가 된다. 숫자형 벡터를 요인으로 전환하는 작업은 함수 factor()로 수행하였다. 옵션 labels를 사용하여 1은 C, 2는 B, 3은 A로 나타내었다. x &lt;- c(80, 88, 90, 93, 95, 94, 100, 78, 65) x_1 &lt;- (x &gt;= 0) + (x &gt;= 80) + (x &gt;= 90) factor(x_1, labels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) ## [1] B B A A A A A C C ## Levels: C B A 두 번째 방법은 첫 번째 방법과 반대 방향으로 비교가 이루어지는 것으로 80 미만은 3, 80 이상 90 미만은 2, 그리고 90 이상은 1의 값을 갖게 된다. 생성된 벡터 x_2에 대해서는 옵션 labels에 지정된 문자의 방향이 첫 번째 방법과는 반대로 되어 있다. x_2 &lt;- (x &lt;= 100) + (x &lt; 90) + (x &lt; 80) factor(x_2, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ## [1] B B A A A A A C C ## Levels: A B C 세 번째 방법은 세 번의 비교가 서로 배타적인 관계가 되도록 설정한 것이다. x_3 &lt;- 1*(x &gt;= 0 &amp; x &lt; 80) + 2*(x &gt;= 80 &amp; x &lt; 90) + 3*(x &gt;= 90) factor(x_3, labels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) ## [1] B B A A A A A C C ## Levels: C B A 함수 cut()에 의한 변수 변환 연속형 벡터를 요인으로 전환하는 작업은 함수 cut()을 사용하면 비교적 간단하게 할 수 있다. 함수 cut()의 옵션으로 breaks에는 최솟값과 최댓값을 포함하여 전체 구간을 원하는 그룹으로 구분하는 벡터가 입력되며, right에는 설정된 구간이 오른쪽으로 닫히는 \\((a &lt; x ≤ b)\\)와 같은 구간이면 TRUE, 왼쪽으로 닫히는 \\((a ≤ x &lt; b)\\)와 같은 구간이면 FALSE가 입력되고, include.lowest에는 개별 값이 전체 구간의 최솟값(또는 최댓값, right=FALSE의 경우)과 같아도 변환에 포함시킬 것(TRUE)인지 아닌지(FALSE)를 지정하게 된다. 옵션 right의 디폴트는 TRUE이고, 옵션 include.lowest의 디폴트는 FALSE이다. 요인 수준의 라벨은 옵션 labels로 지정할 수 있다. cut(x, breaks=c(0, 80, 90, 100), include.lowest = TRUE, right = FALSE, labels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) ## [1] B B A A A A A C C ## Levels: C B A 자료에 무한대가 포함될 가능성은 없기 때문에, 옵션 break에 최솟값과 최댓값을 -Inf와 Inf로 지정하면, 옵션 include.lowest에 대한 걱정 없이 모든 자료를 요인으로 변환할 수 있다. cut(x, breaks = c(-Inf, 80, 90, Inf), right = FALSE, labels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) ## [1] B B A A A A A C C ## Levels: C B A 순서형 요인을 원한다면 옵션 ordered_result = TRUE를 입력해야 한다. cut(x, breaks = c(-Inf, 80, 90, Inf), right = FALSE, labels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;), ordered_result = TRUE) ## [1] B B A A A A A C C ## Levels: C &lt; B &lt; A 2.3 날짜 시간의 흐름에 따라 데이터를 얻는 경우, 날짜는 중요한 변수가 된다. 날짜를 만드는 방법은 문자형 벡터에 함수 as.Date()를 적용하면 된다. 입력되는 문자형 벡터의 디폴트 형태는 yyyy-mm-dd가 된다. x &lt;- as.Date(c(&quot;2017-01-01&quot;,&quot;2018-01-01&quot;)) x ## [1] &quot;2017-01-01&quot; &quot;2018-01-01&quot; 출력된 날짜는 문자형 벡터로 보이지만, 사실은 숫자형 벡터로 1970년 1월 1일부터의 날수로 저장되며, 따라서 날짜를 대상으로 사칙연산을 할 수 있다. typeof(x) ## [1] &quot;double&quot; x[2]-x[1] ## Time difference of 365 days 날짜의 class 속성은 Date이다. class(x) ## [1] &quot;Date&quot; 일정한 간격의 날짜를 만들고자 한다면 함수 seq()를 사용하는 것이 좋다. 예를 들어 2018년 3월 1일부터 3월 31까지의 기간 동안 7일 간격의 날짜를 구해 보자. s1 &lt;- as.Date(&quot;2018-03-01&quot;) e1 &lt;- as.Date(&quot;2018-03-31&quot;) 옵션 by에 숫자를 지정하면, 일 단위 간격의 날짜를 생성하는데, 양수를 지정하는 것과 음수를 지정하는 것의 차이를 확인 할 수 있다. seq(from = s1, to = e1, by = 7) ## [1] &quot;2018-03-01&quot; &quot;2018-03-08&quot; &quot;2018-03-15&quot; &quot;2018-03-22&quot; &quot;2018-03-29&quot; seq(from = e1, to = s1, by = -7) ## [1] &quot;2018-03-31&quot; &quot;2018-03-24&quot; &quot;2018-03-17&quot; &quot;2018-03-10&quot; &quot;2018-03-03&quot; 증가 폭을 일 단위가 아닌 주 단위 혹은 월 단위로 하는 것도 가능한데, by에 \"week\", \"month\", \"quarter\", 혹은 \"year\"를 지정하면 된다. seq(from = s1, by = &quot;week&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2018-03-08&quot; &quot;2018-03-15&quot; &quot;2018-03-22&quot; &quot;2018-03-29&quot; seq(from = s1, by = &quot;month&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2018-04-01&quot; &quot;2018-05-01&quot; &quot;2018-06-01&quot; &quot;2018-07-01&quot; seq(from = s1, by = &quot;year&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2019-03-01&quot; &quot;2020-03-01&quot; &quot;2021-03-01&quot; &quot;2022-03-01&quot; by에 \"-1 week\"와 같이 지정하면 일주일 간격으로 감소되는 날짜를 생성한다. seq(from = s1, by = &quot;-1 week&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2018-02-22&quot; &quot;2018-02-15&quot; &quot;2018-02-08&quot; &quot;2018-02-01&quot; seq(from = s1, by = &quot;-1 month&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2018-02-01&quot; &quot;2018-01-01&quot; &quot;2017-12-01&quot; &quot;2017-11-01&quot; seq(from = s1, by = &quot;-1 year&quot;, length = 5) ## [1] &quot;2018-03-01&quot; &quot;2017-03-01&quot; &quot;2016-03-01&quot; &quot;2015-03-01&quot; &quot;2014-03-01&quot; 2.4 행렬 및 배열 1차원 구조인 벡터에 부가적인 속성 중 하나인 dim이 추가되면 이차원 구조인 행렬이나, 다차원 구조인 배열이 된다. 따라서 행렬과 배열도 구성요소는 모든 동일한 유형(논리형, 숫자형, 문자형)이어야 한다 2.4.1 행렬과 배열의 기본 특성 행렬의 생성 행렬은 함수 matrix()로 만들 수 있다. 행렬로 전환될 벡터를 먼저 입력하고 이어서 행과 열의 개수를 nrow=와 ncol=로 지정할 수 있다. 벡터가 먼저 입력되어 행렬을 구성하 는 요소의 전체 개수가 주어진 상태이므로, nrow 혹은 ncol 둘 중 하나만 사용해도 된다. x &lt;- matrix(1:12, nrow = 3) x ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 위의 예에서 자료는 열 단위로 채워졌는데, 이것을 행 단위로 채우려면 byrow=TRUE를 지정하면 된다 y &lt;- matrix(1:12, nrow = 3, byrow = TRUE) y ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 행렬을 생성하는 두 번째 방법은 함수 cbind()와 rbind()를 사용하는 것이다. 함수 cbind()는 기존의 벡터들을 열 단위로 묶어서 행렬을 만들 때 사용할 수 있고, 함수 rbind()는 벡터들을 행 단위로 묶어서 행렬을 구성할 때 사용할 수 있다. x1 &lt;- 1:3 x2 &lt;- 4:6 (A &lt;- cbind(x1,x2)) ## x1 x2 ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 (B &lt;- rbind(x1,x2)) ## [,1] [,2] [,3] ## x1 1 2 3 ## x2 4 5 6 기존의 행렬에 열 또는 행을 추가하는 경우에도 함수 cbind()와 rbind()를 사용할 수 있다. cbind(A, x3 = 7:9) ## x1 x2 x3 ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 rbind(A, 7:8) ## x1 x2 ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 ## [4,] 7 8 함수 cbind()와 rbind()를 사용할 때 결합 대상이 되는 벡터들의 길이가 서로 다르면 순환법칙이 적용된다. 다음 예에서 벡터 x2는 한 번, x3는 세 번 반복되어 x1과 길이를 맞춘 후 결합이 진행된다. x1 &lt;- 1:4 x2 &lt;- 5:6 x3 &lt;- 7 cbind(x1,x2,x3) ## x1 x2 x3 ## [1,] 1 5 7 ## [2,] 2 6 7 ## [3,] 3 5 7 ## [4,] 4 6 7 행렬을 만드는 세 번째 방법은 함수 dim()을 사용하는 것이다. 벡터에 함수 dim()으로 dim 속성을 부가하면 벡터가 행렬이나 배열로 변환된다. x &lt;- 1:12 dim(x) &lt;- c(3,4) x ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 행렬의 행과 열에 이름을 붙일 수 있는데, 이것은 함수 rownames()와 colnames()로 할 수 있다. rownames(x) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) colnames(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) x ## a b c d ## one 1 4 7 10 ## two 2 5 8 11 ## three 3 6 9 12 행렬을 함수 length()에 입력하면 벡터의 경우와 같이 자료 전체의 개수가 출력된다. length(x) ## [1] 12 하지만, 행렬의 경우에는 자료 전체의 개수보다 행 또는 열의 개수가 더 중요한 정보가 된다. 따라서 행의 개수를 출력하는 함수 nrow(), 또는 열의 개수를 출력하는 ncol() 혹은 행과 열을 개수를 모두 출력하는 dim()의 사용이 더 적절할 것이다. nrow(x) ## [1] 3 ncol(x) ## [1] 4 dim(x) ## [1] 3 4 배열의 생성 배열은 함수 array()로 만들 수 있다. 배열은 다차원 구조이므로 각 차원에 대한 정의가 함수 array() 안에 포함되어야 한다. y &lt;- array(1:24, c(4, 3, 2)) y ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 각 차원에 대한 이름은 함수 dimnames()로 붙일 수 있는데, 문자형 벡터들로 이루어진 리스트를 할당해야 한다. 행렬도 배열의 일종이므로, 함수 dimnames()는 행렬의 행 이름과 열 이름을 지정하거나, 수정하는 경우에도 사용할 수 있다. dimnames(y) &lt;- list(X = c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;), Y = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), Z = c(&quot;z1&quot;, &quot;z2&quot;)) y ## , , Z = z1 ## ## Y ## X y1 y2 y3 ## x1 1 5 9 ## x2 2 6 10 ## x3 3 7 11 ## x4 4 8 12 ## ## , , Z = z2 ## ## Y ## X y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 행렬과 배열의 인덱싱 벡터의 경우와 동일하게 행렬에서도 자료의 일부분을 선택하는 인덱싱은 매우 중요한 작업이다. 이 경우에도 대괄호가 사용되는데 행렬 x의 i번째 행, j번째 열에 있는 값은 x[i,j]로, i번째 행은 x[i,]로, j번째 열은 x[,j]로 나타낸다. x &lt;- matrix(1:12, nrow = 3) x ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 x[2,3] ## [1] 8 x[1,] ## [1] 1 4 7 10 x[,2] ## [1] 4 5 6 x[1:2,] ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 x[1:2, 3:4] ## [,1] [,2] ## [1,] 7 10 ## [2,] 8 11 배열의 인덱싱도 대괄호가 사용되며, 차원 수만큼의 첨자가 필요하다. 다음은 3차원 배열에 대한 인덱싱 예제이다. y &lt;- array(1:24, c(4,3,2)) y[,1,1] ## [1] 1 2 3 4 y[,,1] ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 2.4.2 행렬의 연산 행렬의 연산은 다양한 통계분석을 진행하는 과정에서 종종 사용된다. 표 2.5에는 행렬의 연산에서 중요하게 사용되는 함수 및 연산자들이 정리되어있다. 표에서 A와 B는 행렬을, x와 b는 벡터를, 그리고 k는 스칼라를 의미한다. 표 2.5: 행렬의 연산에 유용하게 사용되는 함수 및 연산자 연산자 및 함수 기능 + - * / ^ 행렬을 구성하는 숫자 각각에 적용 A %*% B 행렬 A와 B의 곱하기 colMeans(A) 행렬 A 각 열의 평균값으로 구성된 벡터 colSums(A) 행렬 A 각 열의 합으로 구성된 벡터 diag(A) 행렬 A의 대각선 원소로 구성된 벡터 diag(x) 벡터 x를 대각선 원소로 하는 대각행렬 diag(k) k * k 단위행렬 eigen(A) 행렬 A의 고유값과 고유벡터로 구성된 리스트 rowMeans(A) 행렬 A 각 행의 평균값으로 구성된 벡터 rowSums(A) 행렬 A 각 행의 합으로 구성된 벡터 solve(A) 행렬 A의 역행렬 solve(A, b) 연립방정식 Ax=b의 해 t(A) 행렬 A의 전치 행렬 연산에 대한 이해를 돕기 위해 몇몇 함수 및 연산자들에 대한 간단한 사용 예를 살펴보자. (A &lt;- matrix(1:4, 2, byrow = TRUE)) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 (B &lt;- matrix(5:8, 2, byrow = TRUE)) ## [,1] [,2] ## [1,] 5 6 ## [2,] 7 8 두 행렬에 곱셈 연산자 *를 사용하면 두 행렬의 대응되는 원소끼리 곱셈이 이루어진다. 행렬의 곱셈은 %*% 연산자를 사용해야 하며, 함수 t()는 행렬의 열과 행을 서로 바꾸는 전치 행렬을 계산하다. A * B ## [,1] [,2] ## [1,] 5 12 ## [2,] 21 32 A %*% B ## [,1] [,2] ## [1,] 19 22 ## [2,] 43 50 t(A) ## [,1] [,2] ## [1,] 1 3 ## [2,] 2 4 함수 cbind()는 열 단위 결합이고, rbind()는 행 단위 결합을 실행한다. cbind(A,B) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 5 6 ## [2,] 3 4 7 8 rbind(A,B) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 ## [4,] 7 8 각 행의 합과 평균 또는 각 열의 합과 평균을 다음과 같이 간편하게 계산할 수 있다. colMeans(A) ## [1] 2 3 colSums(A) ## [1] 4 6 rowMeans(A) ## [1] 1.5 3.5 rowSums(A) ## [1] 3 7 함수 diag()에는 입력되는 객체의 형태에 따라 다른 결과가 나오게 되는데, 행렬을 입력하면 대각 원소를 벡터로 출력한다. diag(A) ## [1] 1 4 벡터를 입력하면, 입력된 벡터를 대각 원소로 하는 대각 행렬을 출력한다. x &lt;- c(10,20) diag(x) ## [,1] [,2] ## [1,] 10 0 ## [2,] 0 20 양수를 입력하면, 입력된 숫자를 차원으로 하는 단위 행렬을 출력한다. diag(2) ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 1 함수 solve()는 행렬의 역행렬을 계산한다. solve(A) ## [,1] [,2] ## [1,] -2.0 1.0 ## [2,] 1.5 -0.5 solve(A)%*%A ## [,1] [,2] ## [1,] 1 4.440892e-16 ## [2,] 0 1.000000e+00 함수 solve()에 행렬 A와 벡터 b를 차례로 입력하면, 연립방정식의 해를 구할 수 있다. 다음 연립방정식의 해를 구하자. \\[ \\begin{matrix} 2x + 3y &amp;=&amp; 5 \\\\ 4x + 5y &amp;=&amp; 6 \\end{matrix} \\] 주어진 문제에 따라 행렬 A와 벡터 b를 다음과 같이 지정한다. A &lt;- matrix(c(2, 4, 3, 5), ncol = 2) b &lt;- c(5,6) 함수 solve()로 연립방정식을 풀어보자. solve(A,b) ## [1] -3.5 4.0 2.5 데이터 프레임 데이터 세트는 행과 열의 2차원 구조를 갖고 있으며, 하나의 열에는 같은 유형의 자료만이 올 수 있으나, 각각의 열은 서로 다른 유형의 자료를 가질 수 있는 구조이다. 이러한 통계 데이터 세트를 위한 데이터 객체가 바로 데이터 프레임이다. 따라서 가장 빈번하게 사용되는 데이터 객체가 된다. 2.5.1 데이터 프레임의 생성 함수 data.frame()에 이름을 붙인 벡터를 차례로 입력함으로써 데이터 프레임을 만들 수 있다. 벡터 x와 y가 데이터 프레임 df1의 열(변수)이 되었고, 행 번호가 자동으로 붙은 것을 알 수 있다. df1 &lt;- data.frame(x = c(2, 4, 6), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df1 ## x y ## 1 2 a ## 2 4 b ## 3 6 c 이 때 입력하는 벡터의 길이는 반드시 같아야 한다. data.frame(x = c(2, 4), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## Error in data.frame(x = c(2, 4), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): arguments imply differing number of rows: 2, 3 길이가 1인 벡터의 경우에는 순환 법칙이 적용되어 길이가 긴 벡터의 길이만큼 반복되어 입력된다. data.frame(x = 1, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) ## x y ## 1 1 a ## 2 1 b ## 3 1 c 함수 str()은 데이터 객체의 특성을 살펴볼 수 있는 함수이다. 함수 str()을 이용하여 데이터 프레임 df1의 특성을 살펴보자. 관찰값(행)과 변수(열)의 개수가 표시되고 각 변수의 이름과 유형 및 자료의 처음 몇 개의 값이 출력된다. str(df1) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ x: num 2 4 6 ## $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; 데이터 프레임은 행렬과 같이 2차원 구조여서 함수 rownames()와 colnames()의 역할은 행렬과 동일하다. 다만 데이터 프레임에서는 함수 names()가 함수 colnames()와 같은 역할을 하고 있으며, 함수 length()도 전체 데이터의 개수가 아닌 열의 개수, 즉 변수의 개수를 구한다. colnames(df1) ## [1] &quot;x&quot; &quot;y&quot; names(df1) ## [1] &quot;x&quot; &quot;y&quot; rownames(df1) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; length(df1) ## [1] 2 2.5.2 데이터 프레임의 인덱싱 함수 typeof()로 확인할 수 있는 데이터 프레임의 유형은 리스트이다. typeof(df1) ## [1] &quot;list&quot; 따라서 리스트에 적용되는 인덱싱 방법을 사용할 수 있다. 또한 데이터 프레임은 행렬과 같이 2차원 구조를 갖고 있기 때문에 행렬에 적용되는 인덱싱 방법도 사용할 수도 있다. 리스트에서는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호를 인덱싱 기호로 사용하고 있다. 즉, df1[a] 또는 df1[[a]]의 형태가 된다. 데이터 프레임에 이 방식을 적용하면, 데이터 프레임을 구성하고 있는 열, 즉 변수 중 일부분을 선택할 수 있다. 대괄호 안에 들어가는 벡터 a는 숫자형 또는 문자형이 되는데, 숫자형인 경우에는 선택할 열의 위치를, 문자형인 경우에는 선택할 열의 이름을 지정하면 된다. 하나의 대괄호 기호와 겹쳐진 두 개의 대괄호 기호의 차이는 선택된 객체의 구조인데, 하나의 대괄호 기호로 선택한 결과는 데이터 프레임이 되고, 겹쳐진 두 개의 대괄호 기호로 선택한 결과는 벡터가 된다. 따라서 여러 변수를 선택할 때에는 하나의 대괄호 기호를 사용해야 한다. df1[1] ## x ## 1 2 ## 2 4 ## 3 6 df1[[1]] ## [1] 2 4 6 df1[&quot;x&quot;] ## x ## 1 2 ## 2 4 ## 3 6 df1[[&quot;x&quot;]] ## [1] 2 4 6 데이터 프레임을 대상으로 통계분석을 할 때에는 분석 대상이 되는 개별 변수를 벡터 형태로 선택하는 경우가 많다. 따라서 df1[[“x”]]의 형태가 자주 사용되는데, 이것을 조금 더 편리하게 하는 방식이 $ 기호의 사용이다. 즉 df1[[“x”]]은 df1$x와 동일하다. df1$x ## [1] 2 4 6 데이터 프레임도 행렬과 같은 2차원 구조이므로 행렬의 인덱싱 방법을 동일하게 적용할 수 있다. 이 경우에는 선택한 변수의 개수에 따라 결과 객체의 구조가 결정되는데, 선택한 변수가 하나이면 벡터가 되고 두 개 이상이면 데이터 프레임이 된다. df1[,1] ## [1] 2 4 6 df1[1,] ## x y ## 1 2 a df1[c(1,2),] ## x y ## 1 2 a ## 2 4 b 2.5.3 함수 with() 데이터 프레임의 개별 변수를 벡터 형태로 선택할 때 겹쳐진 두 개의 대괄호 기호 또는 $ 기호를 사용하여 개별 변수를 선택할 수 있다. 그러나 이러한 방법은 변수를 선택할 때 마다 데이터 프레임의 이름을 함께 입력해야 하는 번거로운 방법이기도 하다. 데이터 프레임이라는 것이 가장 빈번하게 사용되는 구조의 데이터 객체이기 때문에 조금 더 편하게 변수에 접근할 수 있는 방법이 필요한데, 이러한 경우에 사용할 수 있는 함수가 바로 with() 이다. 함수 with()의 일반적인 사용 형태는 with(데이터 프레임, R 명령문)으로, 함수 with() 안에서는 지정된 데이터 프레임에 속한 변수를 인덱싱 기법 없이 그냥 사용할 수 있다. 데이터 프레임 airquality는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의 질과 관련된 몇몇 변수들로 이루어진 데이터 프레임이다. 처음 3개 케이스를 출력해 보자. head(airquality, n = 3) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 데이터 프레임 airquality에 있는 변수 Temp를 표준화시켜보자. 변수 Temp는 데이터 프레임 airquality의 열 벡터이기 때문에 인덱싱 기법을 사용하지 않은 상태에서는 R이 변수 Temp를 찾지 못한다. 따라서 다음에 주어진 첫 번째 문장에서 오류가 발생한 것이다. 두 번째 문장이 데이터 프레임의 인덱싱이 사용된 방법인데, 데이터 프레임의 이름을 여러 번 입력해야 한다는 것이 번거로운 작업이 될 수 있다. 세 번째에서는 함수 with() 안에 airquality를 한 번만 선언하고 이어지는 R 명령문에서는 변수 이름만을 사용하여 표준화 과정을 실행시켰다. 두 번째와 세 번째 명령문의 실행 결과는 당연히 동일하며, 더 간편한 방법을 선택하는 것이 좋을 것이다. z.Temp &lt;- (Temp - mean(Temp))/sd(Temp) ## Error in eval(expr, envir, enclos): object &#39;Temp&#39; not found z.Temp &lt;- (airquality$Temp - mean(airquality$Temp))/sd(airquality$Temp) z.Temp &lt;- with(airquality, (Temp - mean(Temp))/sd(Temp)) 2.6 tibble: 개선된 형태의 데이터 프레임 tibble은 tidyverse에 속한 패키지들이 공통적으로 사용하는 개선된 형태의 데이터 프레임이다. 기존의 데이터 프레임에 몇 가지 기능을 추가함으로써 조금 더 사용하기 편리한 형태를 취하고 있다. tibble과 관련된 작업을 하기 위해서는 패키지 tibble을 불러와야 하는데, Core tidyverse에 속한 패키지이므로 library(tidyverse)를 실행하면 다른 core tidyverse패키지들과 함께 세션에 올라오게 된다. library(tidyverse) 2.6.1 tibble 생성 기존의 전통적인 데이터 프레임을 tibble로 전환하기 위해서는 함수 as_tibble()을 사용하면 된다. as_tibble(cars) ## # A tibble: 50 × 2 ## speed dist ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 ## 7 10 18 ## 8 10 26 ## 9 10 34 ## 10 11 17 ## # ℹ 40 more rows 앞 절에서 살펴보았던 전통적인 데이터 프레임의 출력 형태와는 많이 다른 모습을 보이고있다. 개별 벡터를 이용한 tibble의 생성은 함수 tibble()로 할 수 있다. 길이가 1인 스칼라는 순환법칙이 적용되며, 함께 입력된 변수를 이용하여 다른 변수를 만들 수 있다. tibble(x = 1:3, y = x + 1, z = 1) ## # A tibble: 3 × 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 1 ## 2 2 3 1 ## 3 3 4 1 함께 입력되는 변수를 이용하여 다른 변수를 만들 수 있는 기능은 매우 유용하게 사용될 수 있는데, 함수 data.frame()에서는 가능하지 않던 것이다. data.frame(x = 1:3, y = x + 1) ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found 함수 tibble()에서는 열(변수) 단위로 자료를 입력해야 했는데, 경우에 따라서 행 단위로 입력하는 것이 더 편리할 때가 있다. 이런 경우에는 함수 tribble()을 사용해야 한다. 첫 줄의 변수 이름은 기호 ~으로 시작되는 공식으로 정의되며, 각 자료는 콤마로 구분된다. tribble( ~x, ~y, 1, &quot;a&quot;, 2, &quot;b&quot;, 3, &quot;c&quot; ) ## # A tibble: 3 × 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 a ## 2 2 b ## 3 3 c 2.6.2 tibble과 전통적인 데이터 프레임의 차이 Tibble과 전통적인 데이터 프레임은 출력 방식과 자료의 부분을 선택하는 인덱싱 방식에서 차이가 있으며 행 이름(row name)를 다루는 방식에서도 차이가 있다. 출력 방식의 차이 먼저 출력 방식에서 보면 전통적인 데이터 프레임은 대규모 데이터를 대상으로 하는 경우에 불편한 측면이 있다. 전통적 데이터 프레임은 가능한 모든 자료를 화면에 출력하게 되어 있는데, 이런 출력 방식은 대규모 자료의 경우 내용을 확인하기 매우 어려운 측면이 있다. 이에 반하여 tibble은 처음 10개 케이스만을 출력하며, 변수도 화면의 크기에 따라 출력되는 개수를 조절하여, 한 화면에서 자료의 특성을 비교적 편하게 확인할 수 있다. 패키지 MASS에 있는 데이터 프레임 Cars93는 1993년 미국에서 판매된 93 종류 자동차에 대한 자료이며, 전통적 데이터 프레임이다. 데이터 프레임 Cars93를 불러와 보자. 패키지에 있는 특정 데이터만 불러오는 경우에는 함수 library()로 패키지의 모든 내용을 다 불러오는 것보다 함수 data()를 사용하는 것이 더 효과적이다. data(Cars93, package = &quot;MASS&quot;) as_tibble(Cars93) ## # A tibble: 93 × 27 ## Manufacturer Model Type Min.Price Price Max.Price MPG.city MPG.highway ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Acura Integra Small 12.9 15.9 18.8 25 31 ## 2 Acura Legend Midsi… 29.2 33.9 38.7 18 25 ## 3 Audi 90 Compa… 25.9 29.1 32.3 20 26 ## 4 Audi 100 Midsi… 30.8 37.7 44.6 19 26 ## 5 BMW 535i Midsi… 23.7 30 36.2 22 30 ## 6 Buick Century Midsi… 14.2 15.7 17.3 22 31 ## 7 Buick LeSabre Large 19.9 20.8 21.7 19 28 ## 8 Buick Roadmaster Large 22.6 23.7 24.9 16 25 ## 9 Buick Riviera Midsi… 26.3 26.3 26.3 19 27 ## 10 Cadillac DeVille Large 33 34.7 36.3 16 25 ## # ℹ 83 more rows ## # ℹ 19 more variables: AirBags &lt;fct&gt;, DriveTrain &lt;fct&gt;, Cylinders &lt;fct&gt;, ## # EngineSize &lt;dbl&gt;, Horsepower &lt;int&gt;, RPM &lt;int&gt;, Rev.per.mile &lt;int&gt;, ## # Man.trans.avail &lt;fct&gt;, Fuel.tank.capacity &lt;dbl&gt;, Passengers &lt;int&gt;, ## # Length &lt;int&gt;, Wheelbase &lt;int&gt;, Width &lt;int&gt;, Turn.circle &lt;int&gt;, ## # Rear.seat.room &lt;dbl&gt;, Luggage.room &lt;int&gt;, Weight &lt;int&gt;, Origin &lt;fct&gt;, ## # Make &lt;fct&gt; 변수 이름과 더불어 변수의 유형을 바로 밑 줄에 표시하고 있으며, 화면 크기 때문에 자료가 출력되지 않은 변수는 이름과 유형을 가장 밑에 나열해 두었다. 만일 조금 더 많은 자료를 확인하고자 한다면 함수 print()를 옵션과 함께 사용하면 된다. 예를 들어 처음 20개 케이스와 모든 변수를 다 출력하고자 한다면 다음과 같이 옵션 n = 20과 width = Inf를 사용한다. print(as_tibble(Cars93), n = 20, width = Inf) 행 이름 처리 방식의 차이 자료가 출력될 때 전통적인 데이터 프레임의 경우에는 행 이름이 함께 출력되지만, tibble에서는 생략된다. 데이터 프레임 mtcars를 출력해 보자. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 mtcars_t &lt;- as_tibble(mtcars) print(mtcars_t, n = 6) ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## # ℹ 26 more rows 생략된 행 이름은 함수 rownames_to_column()을 사용하면 변수로 전환할 수 있으며, 변수 이름은 var=에 지정하면 된다. mtcars_d &lt;- rownames_to_column(mtcars, var = &quot;rowname&quot;) mtcars_t &lt;- as_tibble(mtcars_d) mtcars_t ## # A tibble: 32 × 12 ## rowname mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # ℹ 22 more rows 인덱싱 방법의 차이 데이터 프레임의 일부분을 선택하는 인덱싱 기법은 tibble에서도 동일하게 적용된다. 한 가지 차이점은 기호 $을 이용하는 경우인데, 데이터 프레임에서는 변수이름이 부분 매칭만 되어도 선택되지만, tibble에서는 엄격한 기준이 적용되어 변수의 전체 이름을 다 사용해야 선택된다. df1 &lt;- data.frame(xyz = 1:3, abc = letters[1:3]) df1$x ## [1] 1 2 3 tb1 &lt;- as_tibble(df1) tb1$x ## Warning: Unknown or uninitialised column: `x`. ## NULL tb1$xyz ## [1] 1 2 3 흔한 상황은 아니지만, 만일 tibble을 입력했을 때 처리를 못하는 함수가 있다면, tibble을 전통적인 데이터 프레임으로 전환해야 한다. 데이터 프레임으로의 전환은 함수 as.data.frame()을 사용하면 된다. 이러한 전환이 필요한 상황 중 하나는 대괄호를 이용하여 행렬 방식으로 인덱싱을 실시하는 경우이다. 전통적 데이터 프레임의 경우 행렬 방식으로 자료를 부분 선택할 때 선택된 변수가 두 개 이상이면 데이터 프레임이 유지되지만, 선택된 변수가 한 개라면 벡터가 된다. 즉, mtcars[,1:2]는 데이터 프레임이지만 mtcars[,1]은 벡터가 되는 것이다. 반면에 tibble의 경우에는 선택되는 변수의 개수와 관계 없이 그대로 tibble 속성이 유지가 된다. 따라서 mtcars_t[,1:2]와 mtcars_t[,1] 모두 tibble이며, mtcars_t[1,1]도 tibble 속성을 그대로 유지하고 있다. 따라서 데이터 프레임에서 행렬 방식으로 하나의 변수를 선택했을 때 벡터가 되어야 작동이 되는 경우라면 tibble을 사용해서는 안 되는 상황이 되는 것이다. 2.7 리스트 리스트는 R에서 가장 포괄적인 형태의 데이터 구조이다. 그 구성요소로서 벡터, 배열, 데이터 프레임, 함수, 다른 리스트 등이 될 수 있는, 한마디로 여러 다른 유형의 객체들을 하부 구조로 하여 한데 묶은 또 다른 객체라고 할 수 있다. 리스트의 생성 리스트는 함수 list()로 만들 수 있다. 문자형 벡터, 숫자형 벡터, 데이터 프레임과 다른 리스트로 이루어진, 리스트 x를 만들어보자. x &lt;- list(a = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), b = 1:3, c = list(-1, -5), d = data.frame(x1 = c(&quot;s1&quot;, &quot;s2&quot;), x2 = 1:2)) x ## $a ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; ## ## $b ## [1] 1 2 3 ## ## $c ## $c[[1]] ## [1] -1 ## ## $c[[2]] ## [1] -5 ## ## ## $d ## x1 x2 ## 1 s1 1 ## 2 s2 2 리스트의 인덱싱 리스트의 인덱싱 기호는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호이다. 대괄호 하나를 사용하여 선택하면 원래의 구조가 그대로 유지되어 항상 리스트가 되고, 겹쳐진 두 개의 대괄호를 사용하면 해당되는 구성요소의 객체 구조가 된다. 즉, x[1]은 x의 첫 번째 구성 요소인 문자형 벡터 하나로만 이루어진 리스트가 되며, x[[1]]은 x의 첫 번째 구성요소인 문자형 벡터가 된다. x[1] ## $a ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; x[[1]] ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; str(x[1]) ## List of 1 ## $ a: chr [1:3] &quot;one&quot; &quot;two&quot; &quot;three&quot; str(x[[1]]) ## chr [1:3] &quot;one&quot; &quot;two&quot; &quot;three&quot; 따라서 x[[4]]는 네 번째 구성요소인 데이터 프레임이 되는 것이며, x[[4]][2]은 해당 데이터 프레임의 두 번째 열만으로 구성된 데이터 프레임이 되고, x[[4]][[2]]는 숫자형 벡터가 된다. x[[4]] ## x1 x2 ## 1 s1 1 ## 2 s2 2 x[[4]][2] ## x2 ## 1 1 ## 2 2 x[[4]][[2]] ## [1] 1 2 데이터 프레임의 경우와 같이 리스트에서도 $ 기호를 사용하여 인덱싱을 할 수 있다. 즉, x$a는 x[[\"a\"]]와 같은 것이며, 따라서 x$a[1:2]는 x[[\"a\"]][1:2]와 같은 것이다. x$a ## [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; x$a[1:2] ## [1] &quot;one&quot; &quot;two&quot; 리스트는 매우 중요한 구조 형태인데, 그것은 산만하게 흩어져 있는 정보들을 간편하게 묶을 수 있다는 장점과 대부분의 R 함수들이 실행 결과를 리스트의 형태로 생성하기 때문이다. 앞으로 많은 예제를 통하여 R 함수들의 실행 결과로 생성되는 리스트를 볼 수 있을 것이다. 리스트로 생성된 결과물 중 우리가 원하는 결과는 대부분의 경우 그 일부분이 될 것이기 때문에 리스트의 인덱싱 기법을 사용하여 적절하게 선택해야 할 것이다. 2.8 연습문제 1. 데이터 프레임 iris는 세 가지 종류 붓꽃 setosa , versicolor , virginica의 꽃잎과 꽃받침의 길이와 폭을 측정한 자료이다. 각 종류별로 50송이를 측정하여 처음 50개 행에는 setosa, 51부터 100번째 행에는 versicolor, 마지막 50개 행에는 viginica의 측정값이 입력되어 있다. iris의 1~3 행 51~53 행 101~103 행을 다음과 같이 출력해 보자. ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 51 7.0 3.2 4.7 1.4 versicolor ## 52 6.4 3.2 4.5 1.5 versicolor ## 53 6.9 3.1 4.9 1.5 versicolor ## 101 6.3 3.3 6.0 2.5 virginica ## 102 5.8 2.7 5.1 1.9 virginica ## 103 7.1 3.0 5.9 2.1 virginica iris의 변수 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width에는 꽃잎과 꽃받침의 길이와 폭을 측정한 결과가 입력되어 있다. 세 가지 붓꽃 종류별로 네 변수의 평균값을 각각 계산해 보자 150송이 중 Petal.Width의 값이 1 이하이고 Petal.Length가 4 이하인 붓꽃이 모두 몇 송이가 있는지 알아보자. 또한 세 종류의 붓꽃별로는 각각 몇 송이가 있는지 알아보자. 2. 데이터 프레임 mtcars는 1974년에 발행된 어떤 잡지에 소개된 32대 자동차의 연비와 관련된 자료이다. 숫자형 변수 mpg에 대한 다음의 조건으로 요인 grade를 생성해 보자. 단, \\(\\bar{x}\\) 와 \\(sd\\) 는 변수 mpg의 평균 및 표준편차이다. \\[ \\mbox{grade} = \\begin{cases} \\mbox{Bad}, &amp; \\mbox{if mpg}~ \\leq \\overline{x} - sd \\\\ \\mbox{Good}, &amp; \\mbox{if}~~~ \\overline{x} - sd &lt;~ \\mbox{mpg}~ \\leq \\overline{x} + sd \\\\ \\mbox{Excellent}, &amp; \\mbox{if mpg}~ \\geq \\overline{x} + sd \\end{cases} \\] mtcars의 행 이름을 데이터 프레임에 변수 이름 model로 추가해 보자 요인 grade가 Excellent인 자동차의 변수 model과 mpg의 값을 출력해 보자. 요인 grade가 Bad인 자동차들의 평균 mpg 값을 계산해 보자. 3. 데이터 프레임 mtcars는 32대 자동차의 연비와 관련된 자료가 입력되어 있으며, 자동차 모델 이름은 행 이름으로 입력되어 있다. 변수 mpg 의 값이 mpg 의 평균보다 큰 자동차의 모델 이름을 다음과 같이 벡터로 출력해 보자. ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Datsun 710&quot; &quot;Hornet 4 Drive&quot; ## [5] &quot;Merc 240D&quot; &quot;Merc 230&quot; &quot;Fiat 128&quot; &quot;Honda Civic&quot; ## [9] &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; &quot;Fiat X1-9&quot; &quot;Porsche 914-2&quot; ## [13] &quot;Lotus Europa&quot; &quot;Volvo 142E&quot; 변수 mpg 의 값이 mpg 의 평균보다 크고, 변수 gear가 4 또는 5이며, 변수 am이 1인 자동차를 선택해서 다음과 같이 데이터 프레임으로 출력해 보자. ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 4. 데이터 프레임 iris는 세 가지 종류 붓꽃 setosa , versicolor , virginica의 꽃잎과 꽃받침의 길이와 폭을 측정한 자료이다. 변수 Sepal.Length가 5 이하고, Sepal.Width가 2.5 이하인 붓꽃을 선택해서 다음과 같은 데이터 프레임 형태로 출력해 보자. ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 42 4.5 2.3 1.3 0.3 setosa ## 58 4.9 2.4 3.3 1.0 versicolor ## 61 5.0 2.0 3.5 1.0 versicolor ## 94 5.0 2.3 3.3 1.0 versicolor ## 107 4.9 2.5 4.5 1.7 virginica 붓꽃 setosa 중에 변수 Petal.Length가 3 이하고, Petal.Width가 1 이하인 케이스가 몇 송이가 되는지 확인해 보자. 5. 벡터 letters는 영문자 소문자로 이루어진 문자형 벡터이다. letters의 첫 번째, 세 번째, 다섯 번째와 마지막 문자를 선택해서 다음의 벡터 ex2_5_1을 만들어 보자. ex2_5_1 ## [1] &quot;acez&quot; 벡터 ex2_5_1을 이용해서 다음의 벡터 ex2_5_2를 만들어 보자. ex2_5_2 ## [1] &quot;acez,ACEZ&quot; 벡터 letters를 이용해서 다음의 벡터 ex2_5_3를 만들어 보자. ex2_5_3 ## [1] &quot;aaa&quot; &quot;bab&quot; &quot;cab&quot; &quot;abb&quot; &quot;bbc&quot; &quot;cbc&quot; &quot;acc&quot; &quot;bcc&quot; &quot;ccc&quot; 6. 다음의 code를 실행해서 문자형 벡터 a1, a2, a3를 생성하자. a1 &lt;- rep(&quot;a&quot;, times = 5) a2 &lt;- rep(&quot;b&quot;, times = 3) a3 &lt;- rep(&quot;c&quot;, times = 4) 벡터 a1, a2, a3를 이용해서 다음의 벡터 ex2_6_1을 만들어 보자. ex2_6_1 ## [1] &quot;aaaaa,bbb,cccc&quot; 벡터 ex2_6_1의 문자열은 같은 문자가 연속적으로 반복되어 있는데, 이렇게 동일 문자가 연속 반복된 문자열에서 반복 횟수를 계산할 수 있는 code를 작성해 보자. 벡터 ex2_6_1에서 동일 문자가 연속해서 반복되는 횟수를 계산해서 해당 문자 다음에 표시하고, 이어서 콤마로 구분한 벡터 ex2_6_2를 만들어 보자. ex2_6_2 ## [1] &quot;a5,b3,c4&quot; 7. 전통적 데이터 프레임과 tibble로 구성된 다음과 같은 리스트 ex2_7를 만들어 보자. ex2_7 ## $df1 ## name Sales ## 1 Park 14 ## 2 Lee 16 ## 3 Kim 21 ## ## $df2 ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 200 리스트 ex2_7의 첫 번째 요소인 데이터 프레임에서 변수 Sales가 20을 초과하는 행을 선택해서 다음과 같이 출력해 보자. ## name Sales ## 3 Kim 21 리스트 ex2_7의 두 번째 요소인 tibble에서 변수 gender가 \"F\"인 행들의 변수 income의 평균값을 계산해 보자. "],["데이터-입력.html", "3 장 데이터 입력 3.1 텍스트 파일 불러오기: 패키지 readr 함수의 활용 3.2 Excel 파일 불러오기 3.3 SAS 데이터 파일 불러오기 3.4 HTML 테이블 불러오기 3.5 연습문제", " 3 장 데이터 입력 2장에서는 다양한 R 데이터 객체에 대해 살펴보았다. 지금부터는 모든 통계분석 및 그래프 작성의 첫 단계라고 할 수 있는 데이터 입력 방법에 대해 살펴보자. R은 텍스트 파일, 다른 통계 소프트웨어 전용 데이터 파일, Excel 파일 및 HTML 테이블 등 다양한 유형의 데이터 파일을 비교적 간단하게 불러올 수 있다. 3.1 텍스트 파일 불러오기: 패키지 readr 함수의 활용 많은 경우에 데이터 파일은 텍스트 파일의 형태로 저장되어 있다. 통계 데이터 세트는 행과 열의 2차원 형태로 구성되는데, 입력 형식은 매우 다양할 수 있다. 즉, 각각의 자료들이 빈칸으로 구분된 경우, 콤마로 구분된 경우, 고정 포맷 구조로 구성된 경우 등이 있게 된다. 따라서 이렇게 각기 다른 구성 형식의 텍스트 파일을 불러오는데 적합한 함수가 필요한 것이다. 외부 텍스트 파일을 불러오는 작업은 base R 함수인 read.table() 또는 read.csv()로 할 수 있으나, 크기가 큰 텍스트 파일을 불러와야 하는 경우에는 시간이 많이 걸린다는 문제가 있다. 이 절에서는 tidyverse에 속한 패키지 readr의 함수를 사용하여 효율적으로 텍스트 파일을 불러오는 방법을 살펴보겠다. 패키지 readr에는 텍스트 파일의 구성 형식에 맞추어 사용할 수 있는 다양한 함수가 마련되어 있다. 각각의 자료들이 하나 이상의 빈 칸으로 구분된 경우에는 read_table(), 콤마로 구분된 경우에는 함수 read_csv(), 탭으로 구분된 경우에는 함수 read_tsv(), 그 외 다른 형태의 구분자로 구분된 경우는 함수 read_delim()을 사용할 수 있으며, 고정된 포맷 구조를 갖는 경우에는 함수 read_fwf()을 사용하여 자료를 불러올 수 있다. 이 함수들은 불러올 파일의 경로를 포함한 파일 이름이 첫 번째 입력 요소가 된다. 파일 이름이 .gz 또는 .zip 등으로 끝나는 압축 파일은 자동으로 압축을 해제하고 자료를 불러온다. 또한 http://, https://, ftp://, ftps://로 시작되는 웹 서버에 있는 텍스트 파일도 불러올 수 있다. 3.1.1 함수 read_table()로 데이터 파일 불러오기 자료들이 하나 이상의 빈칸으로 구분된 경우에는 read_table()를 사용하여 파일을 불러올 수 있다. 1) 데이터 파일의 첫 줄에 변수 이름이 입력되어 있는 경우 예를 들어 파일 data2_1.txt에 세 변수의 자료가 다음과 같이 있다고 하자. data2_1.txt 이런 경우에는 함수 read_table()에 파일의 위치와 함께 파일의 이름만 입력하면 된다. library(tidyverse) read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_1.txt&quot;) ## ## ── Column specification ───────────────────────────────────────────────────────── ## cols( ## age = col_double(), ## gender = col_character(), ## income = col_double() ## ) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 패키지 readr에 속한 함수들은 각 변수의 유형을 스스로 파악한다. 각 변수마다 처음 1000개의 자료를 읽고 정해진 규칙에 의하여 문자형, 정수형, 숫자형, 논리형 등으로 유형을 결정한다. 스스로 자료의 유형을 파악한 경우에는 각 변수별로 파악된 결과를 출력한다. 각 변수의 유형은 사용자가 직접 선언할 수도 있는데, 가장 간단한 방법은 입력 요소 col_types에 변수의 유형을 나타내는 문자를 변수가 입력된 순서대로 나열하여 지정하는 것이다. 자료의 유형을 나타내는 문자에는 c(문자형), i(정수형), d(실수형), n(숫자형), l (논리형), f(요인), D(날짜) 등이 있다. 예를 들어 파일 data2_1.txt의 경우에는 다음과 같이 자료의 유형을 선언하여 자료를 불러올 수 있다. read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_1.txt&quot;, col_types = &quot;dcd&quot;) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 2) 데이터만 파일에 입력되어 있는 경우 첫 줄에 변수 이름이 입력되어 있지 않은 데이터 파일도 많이 있다. 예를 들어 파일 data2_2.txt에 세 변수에 대한 데이터가 다음과 같이 있다고 하자. data2_2.txt 이런 경우에는 입력 요소 col_names에 FALSE를 지정하거나 변수 이름을 나타내는 문자형 벡터를 지정해야 한다. 아무것도 지정하지 않으면 데이터 파일의 첫 줄에 입력된 자료가 각 변수의 이름으로 사용되는 오류가 발생한다. FALSE를 지정한 경우에 변수 이름은 X1, X2, X3 등이 된다. read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_2.txt&quot;, col_names = FALSE) ## # A tibble: 4 × 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_2.txt&quot;, col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;)) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 3) 데이터 파일에 주석이 입력된 경우 데이터 파일에 주석이 있는 경우, 해당 행을 무시하기 위해서는 주석이 시작됨을 나타내는 기호를 입력 요소 comment에 지정하면 된다. 만일 기호 #을 주석 기호로 사용했다면 comment = \"#\"을 입력하면 된다. 또한 만일 주석이 데이터 파일의 처음 몇 개 행에 입력되어 있다면, 입력 요소 skip을 사용하여 해당되는 처음 몇 개 행을 읽지 않고 그냥 넘기는 방법을 사용할 수도 있다. data2_3.txt 파일 data2_3.txt의 처음 세 줄이 # 기호로 시작되는 주석이 입력되어 있다. 이 파일을 두 가지 방법을 사용해서 불러와 보자. read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_3.txt&quot;, comment = &quot;#&quot;) ## # A tibble: 4 × 3 ## x1 x2 x3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 24 1 2000 ## 2 35 0 3100 ## 3 28 0 3800 ## 4 21 0 2800 read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_3.txt&quot;, skip = 3) ## # A tibble: 4 × 3 ## x1 x2 x3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 24 1 2000 ## 2 35 0 3100 ## 3 28 0 3800 ## 4 21 0 2800 4) 데이터 파일에 결측값이 NA가 아닌 다른 기호로 입력된 경우 데이터에 결측값이 있는 것은 당연한 것으로 봐야 한다. R에서는 결측값을 NA로 표시하기 때문에 데이터에 결측값이 있다면 해당되는 자리에 NA를 입력해야 한다. 그러나 경우에 따라서 결측값이 다른 숫자나 문자 혹은 기호로 데이터 파일에 입력될 수도 있는데, 예를 들어 SAS의 경우 결측값은 점(.)으로 표시한다. 이렇듯 다른 기호로 결측값이 입력된 경우 에는 옵션 na에 해당 기호를 지정해 주어야 한다. 만일 결측값이 점(.)으로만 입력되어 있다면 na = \".\"으로 지정하면 되지만 NA와 점(.)이 모두 결측값을 나타내는 기호로 사용되었다면 na = c(\".\", \"NA\")로 두 기호를 모두 지정해야 한다. data2_4.txt 파일 data2_4.txt에는 NA와 점(.)이 모두 결측값을 나타내는 기호로 사용되어 있다. 이 파일을 옵션 na를 사용해서 불러 보자. na = \".\"로 점(.)만을 결측값으로 지정하면, income 변수의 네 번째 자료인 NA는 결측값이 아닌 문자형 자료로 인식된다. 따라서 변수 income의 유형은 숫자형이 아닌 문자형이 된다. read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_4.txt&quot;, na = &quot;.&quot;) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 24 M 2000 ## 2 NA F 3100 ## 3 28 &lt;NA&gt; 3800 ## 4 21 F NA na = c(\".\", \"NA\")로 두 기호를 모두 결측값으로 지정해서 다시 불러 보자. read_table(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data2_4.txt&quot;, na = c(&quot;.&quot;, &quot;NA&quot;)) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 NA F 3100 ## 3 28 &lt;NA&gt; 3800 ## 4 21 F NA 함수 file.choose() 외부 파일을 R로 불러오는 과정에서 파일이 저장되어 있는 폴더의 정확한 위치를 잊는 경우가 가끔 있다. 혹은 정확하다고 생각되는 파일의 경로를 입력했는데도 파일을 열 수 없다는 오류가 발생하는 경우도 있다. 이런 경우에 함수 file.choose()를 이용하면 굳이 윈도우 파일 탐색기를 이용하여 파일의 위치를 다시 확인하지 않고도 파일에 접근할 수 있다. 예를 들어 함수 read_table() 등에 파일의 위치와 더불어 파일 이름을 입력하는 대신 read_table(file.choose())를 실행하면 탐색기 창이 나타나서 접근하고자 하는 파일을 쉽게 찾을 수 있다. 3.1.2 함수 read_csv()로 CSV 데이터 파일 불러오기 CSV(Comma Separated Values) 파일이란 각 자료들이 콤마로 구분된 형식의 데이터 파일을 의미한다. Excel을 포함하는 많은 소프트웨어들이 CSV 형식의 데이터 파일을 읽어 올 수도 있고 작업결과를 CSV 형식으로 저장할 수도 있기 때문에 자주 사용되는 형식의 데이터 파일이라고 하겠다. data3_1.txt 파일 data3_1.txt에는 자료들이 콤마로 구분되어 있고, 첫 줄에는 변수 이름이 입력되어 있다고 하자. 이 경우에는 read_csv()에 파일의 위치를 포함한 이름을 입력하면 파일을 불러올 수 있다. read_csv(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data3_1.txt&quot;) ## # A tibble: 4 × 3 ## `var 1` `var 2` `var 3` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 함수 read_csv()로 생성된 tibble의 변수 이름이 backtick(`) 기호로 감싸져 있는 것을 볼 수 있다. R에서 변수 이름은 반드시 문자로 시작해야 하며, 중간에 빈칸이 없어야 하는 등의 규칙이 있는데, 이러한 규칙에 어긋난 문자열이라도 tibble에서는 backtick 기호로 감싸서 정상적인 변수 이름으로 사용하고 있음을 보여주고 있다. Backtick 기호는 키보드에서 tab 키 바로 위에 있는 것이며, 인용부호와는 다른 기호이다. 함수 read_table()에서 살펴보았던 col_types, col_names, na, comment, skip은 read_csv()에서도 동일하게 작동되는 요소들이다. 예를 들어 data3_2.txt에 다음과 같이 자료가 입력되어 있다고 하자. 첫 줄에 주석이 있고, 결측값이 기호 NA와 점(.)으로 표시되어 있으며, 변수 이름은 입력되지 않았다. data3_2.txt 이제 각 변수의 유형을 스스로 파악하게 해 보자. read_csv(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data3_2.txt&quot;, col_names = FALSE, comment = &quot;#&quot;, na = c(&quot;.&quot;, &quot;NA&quot;)) ## Rows: 4 Columns: 3 ## ── Column specification ───────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (2): X1, X3 ## lgl (1): X2 ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. ## # A tibble: 4 × 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; ## 1 24 NA 2000 ## 2 35 FALSE 3100 ## 3 NA FALSE 3800 ## 4 21 FALSE NA 위 실행결과에서 자세하게 살펴볼 두 가지 중요한 사항이 있다. 첫 번째 사항은 CSV 파일에서는 자료를 입력하지 않고 빈칸으로 남겨두면 결측값으로 자동 처리된다는 것이다. 이것은 빈칸으로 남겨져 있는 변수 X1의 세 번째 자료가 NA로 처리된 것으로 알 수 있다. 각 자료가 콤마로 구분되어 있다는 것은 곧 각 자료의 입력 영역이 확보되어 있다는 것을 의미하기 때문에 빈칸으로 남겨진 영역을 결측값으로 자연스럽게 처리할 수 있는 것이다. 하지만 결측값을 빈칸으로 그냥 남겨두는 것은 좋은 작업 방식은 아니라고 할 수 있으며, 문제가 있을 수 있다는 경고 문구가 출력된다. 두 번째 사항은 변수 유형 파악에 오류가 발생할 수도 있으니 반드시 결과를 확인해야 한다는 것이다. 위 실행 결과에서 문자형 변수 X2의 유형이 논리형으로 파악됐는데, 이것은 변수 X2의 자료가 NA와 F로만 이루어져 있어서 F를 FALSE로 인식했기 때문이다. 이런 경우에는 변수 유형을 사용자가 직접 지정해야 한다. read_csv(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data3_2.txt&quot;, col_names = FALSE, col_types = &quot;dcd&quot;, comment = &quot;#&quot;, na = c(&quot;.&quot;, &quot;NA&quot;)) ## # A tibble: 4 × 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 &lt;NA&gt; 2000 ## 2 35 F 3100 ## 3 NA F 3800 ## 4 21 F NA 3.1.3 함수 read_fwf()로 고정 포맷 구조를 갖는 데이터 파일 불러오기 데이터 파일 중에는 각 자료의 입력 위치가 고정되어 있는 경우가 있다. 예를 들어 파일 data4.txt에 다음과 같은 형식으로 세 변수의 데이터가 입력되어 있다고 하자. data4.txt 변수 age는 1-2열, gender는 3열, income은 4-7열에 각각 입력되어 있다. 이러한 경우 각 자료들이 빈칸이나 콤마 등으로 구분되어 있어야만 사용할 수 있는 함수 read_table() 또는 read_csv() 등은 그야말로 무용지물이 된다. 이러한 형식의 파일을 읽기 위해서는 각 자료의 고정된 위치를 지정할 수 있어야 하는데, 함수 read_fwf()에 바로 그러한 기능이 있다. 고정된 위치 지정은 입력 요소 col_positions에 함수 fwf_widths() 또는 fwf_positions()를 연결하는 것이다. 각 변수의 자료가 입력되는 영역의 폭으로 위치를 지정하는 것은 fwf_widths(widths, col_names)로 하면 되고, 각 변수의 시작 열과 끝 열을 지정해서 자료의 위치를 나타내기 위해서는 fwf_positions(start, end, col_names)로 하면 된다. 옵션 col_names를 생략하면 변수 이름은 X1, X2, X3 등으로 지정된다. 이제 data4.txt를 읽어보자. fwf_widths()에 widths=c(2,1,4)를 지정하면 첫 번째 변수 age는 두 개의 열, 두 번째 변수 gender는 한 개의 열, 마지막 변수 income은 네 개의 열을 차지하고 있다는 것이다. read_fwf(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data4.txt&quot;, col_positions = fwf_widths(widths = c(2, 1, 4), col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;))) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 fwf_positions()에 start=c(1,3,4)와 end=c(2,3,7)을 지정하면 첫 번째 변수 age는 1~2열에, 두 번째 변수 gender는 3열에, 마지막 변수 income은 4~7열에 입력되어 있다는 것을 나타낸다. read_fwf(&quot;https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/data4.txt&quot;, col_positions = fwf_positions(start = c(1, 3, 4), end = c(2, 3, 7), col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;))) ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 RStudio 메뉴에서 불러오기 외부 텍스트 파일을 불러오는 작업은 RStudio의 메뉴를 이용해서도 할 수 있다. 메인 메뉴 에서 File &gt; Import Dataset &gt; From Text (readr)… 을 선택하면 나타나는 별도의 창에서 필요한 사항을 선택하면 read_table() 혹은 read_csv() 등을 사용하여 파일을 불러오게 된다. 만일 base R 함수인 read.table() 혹은 read.csv() 등을 이용하고자 한다면 File &gt; Import Dataset &gt; From Text (base)…을 선택해서 불러올 수 있다. 또한 다음 절에서 살펴볼 Excel 파일이나, SAS 데이터 파일 등을 불러오는 작업도 File &gt; Import Dataset의 하부 메뉴를 이용해서 할 수 있다. 데이터 프레임을 외부 텍스트 파일로 저장하기 R에서 생성되고 수정된 데이터 프레임을 외부 텍스트 파일로 저장시켜 다른 소프트웨어에서도 사용할 수 있도록 하는 것도 중요한 작업이다. 데이터 프레임을 외부 텍스트 파일로 저장하는 작업은 자료들을 어떤 기호로 구분할 것인지에 따라 패키지 readr의 함수 write_delim(), write_csv() 또는 write_tsv() 등을 사용할 수 있다. 자료들을 빈칸으로 구분하려면 write_delim(), 콤마로 구분하려면 write_csv(), 탭으로 구분하려면 write_tsv()를 사용하면 된다. 데이터 프레임을 외부 텍스트 파일로 저장하는 작업은 write.csv()와 같은 base R 함수로도 할 수 있다. Base R의 함수들은 데이터 프레임의 행 이름을 텍스트 파일의 첫 번째 열에 배치하고, 모든 문자 및 변수 이름에 인용부호를 붙이는 것이 디폴트인 반면에 패키지 readr의 함수들은 데이터 프레임의 행 이름을 절대 저장하지 않으며 인용 부호는 필요한 경우에만 사용된다. 또한 패키지 readr의 함수들의 실행 속도가 2배 정도 빠른 것으로 되어 있다. Base 패키지인 datasets에 있는 데이터 프레임 women은 30대 미국 여성 15명의 몸무게와 키가 측정되어 있는 데이터 세트이다. 키는 인치 단위, 몸무게는 파운드 단위로 측정되었다. 데이터 프레임 women을 Data 폴더에 텍스트 파일로 저장하기 위해 다음 프로그램을 각각 실행해 보고 생성되는 텍스트 파일을 확인하기 바란다. write_delim(women, &quot;Data/women.txt&quot;) write_csv(women, &quot;Data/women.csv&quot;) write_tsv(women, &quot;Data/women.tsv&quot;) 3.2 Excel 파일 불러오기 Excel에서 데이터를 만들고 가공하는 경우가 많기 때문에 Excel 스프레드시트에 있는 데이터를 R로 불러오는 것은 상당히 중요한 작업이 된다. Excel 파일을 R로 불러오는 방법에는 몇가지가 있는데, 그 중 tidyverse에 속한 패키지 readxl의 함수 read_excel()의 사용법을 살펴보자. 함수 read_excel()은 Excel 2003 이하 버전의 파일 형식인 xls 파일과 Excel 2007 이상 버전의 파일 형식인 xlsx 파일을 모두 불러올 수 있다. 다만 아직은 함수에 URL을 입력해서 웹 서버에 있는 Excel 파일을 직접 불러올 수는 없다. 예제 데이터로 폴더 Data에 있는 파일 data5.xlsx`에 다음과 같이 자료가 입력되어 있다고 하자. 자료는 첫 번째 시트에 입력되어 있다. data5.xlsx 입력할 데이터가 있는 시트 번호를 지정하지 않으면, 디폴트로 첫 번째 시트의 데이터를 입력한다. 만일 다른 시트의 데이터를 입력하고자 한다면, 옵션 sheet에 시트 번호를 지정하면 된다. library(readxl) read_excel(&quot;Data/data5.xlsx&quot;) ## # A tibble: 5 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 2800 ## 5 31 M 3500 시트의 전체 데이터 중 일부분만을 입력하고자 한다면, 옵션 range에 입력하고자 하는 데이터 범위 사각형의 왼쪽 위 모서리와 오른쪽 아래 모서리의 셀 번호를 지정하면 된다. read_excel(&quot;Data/data5.xlsx&quot;, range = &quot;A1:B5&quot;) ## # A tibble: 4 × 2 ## age gender ## &lt;dbl&gt; &lt;chr&gt; ## 1 24 M ## 2 35 F ## 3 28 F ## 4 21 F Excel 파일을 CSV 파일로 전환한 후 불러오기 함수 read_excel()을 사용하면 Excel 파일을 R로 불러오는 데에는 큰 문제가 없겠지만, 어떤 이유로 해서 Excel 파일을 직접 R로 불러올 수 없는 경우에 대안으로 사용할 수 있는 방법이다. Excel 파일을 CSV 파일로 전환하여 저장하는 방법은 Excel의 메인 메뉴에서 파일 &gt; 다른 이름으로 저장을 선택한 후 CSV 파일 형식으로 저장하면 된다. 저장된 CSV 파일은 함수 read_csv()로 불러올 수 있다. 3.3 SAS 데이터 파일 불러오기 SAS는 범용 통계 소프트웨어로서 매우 두터운 사용자 층을 형성하고 있다. 따라서 SAS 전용 데이터 파일을 R로 불러오는 것도 중요한 작업이다. SAS 전용 데이터 파일을 R로 직접 불러오는 방법을 알아보자. 패키지 haven의 함수 read_sas()로 SAS 전용 데이터 파일 불러오기 예를 들어 Data 폴더에 다음의 SAS 명령문으로 생성된 데이터 파일 data6.sas7bdat가 있다고 하자. LIBNAME mysas &#39;D:\\Data&#39;; DATA mysas.data6; INPUT age gender $ income; CARDS; 24 M 2000 35 F 3100 28 F 3800 21 F 3500 31 M 3500 RUN; 패키지 haven도 tidyverse 계열에 속하는 패키지이므로, 함수 read_sas()은 tibble을 생성한다. library(haven) read_sas(&quot;Data/data6.sas7bdat&quot;) ## # A tibble: 5 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 3500 ## 5 31 M 3500 SAS 전용 데이터 파일을 CSV 파일로 전환한 후 불러오기 SAS 전용 데이터 파일은 SAS의 PROC EXPORT를 사용하여 CSV 파일로 전환하여 저장할 수 있다. Excel의 경우처럼 R로 직접 불러오는 방법에 대한 대안으로 사용할 수 있다. SAS 전용 데이터 파일인 data6.sas7bdat을 CSV 파일인 data6.csv로 출력하는 SAS 명령문은 다음과 같다. LIBNAME mysas &#39;D:\\Data&#39;; PROC EXPORT DATA=mysas.data6 OUTFILE=&#39;D:\\Data\\data6.csv&#39; DBMS=CSV; RUN; 패키지 haven에는 SPSS 데이터 파일과 Stata 데이터 파일을 불러올 수 있는 함수도 있다. SPSS 데이터 파일은 read_spss(), Stata DTA 파일은 read_stata()를 사용하면 어렵지 않게 불러올 수 있다. 3.4 HTML 테이블 불러오기 웹 페이지를 보다 보면 중요한 정보가 있는 HTML 테이블을 자주 만나게 되는데, 이 테이블에 있는 데이터를 R로 바로 불러들일 수 있다면 분석 과정에 큰 도움이 될 것이다. 문제는 웹 페이지에 있는 HTML 테이블이라는 것이 사람들에게 시각적으로 보여지는 측면이 강조되는 대상이어서 거기에 있는 정보를 ‘긁어모아’ 컴퓨터에 입력하는 것이 조금 복잡한 작업이 될 수 있다는 점이다. 그러나 패키지 rvest를 이용하면 비교적 간편하게 HTML 테이블의 데이터를 긁어모아 R에 입력시킬 수 있다. 패키지 rvest에서 HTML 테이블을 불러오는데 필요한 함수는 read_html()과 html_elements(), html_table()이다. 함수 read_html()은 원하는 HTML 테이블이 있는 웹 페이지를 읽어오는 데 사용된다. HTML 테이블의 내용은 &lt;table&gt; 태그 사이에 존재하기 때문에 &lt;table&gt; 노드(node)를 찾는 것이 다음 순서인데, 이 작업은 함수 html_elements()로 할 수 있다. 이어서 선택된 노드의 HTML 테이블 데이터를 R로 불러오는 작업은 함수 html_table()로 하게 된다. \\(\\bullet\\) 예제 1: Wikipedia 웹 페이지에 있는 HTML 테이블 데이터 불러오기 그림 3.1은 Wikipedia에서 “World population”을 검색하면 열리는 웹 페이지에 있는 “10 most densely populated countries”라는 제목의 HTML 테이블을 보여주고 있다. 검색은 2023-08-23에 실시된 것을 바탕으로 하고 있으며, 차후에 HTML 테이블의 배치가 변경되면 아래 예제 프로그램도 적절히 변경해야 할 것이다. 그림 3.1: 예제 1에서 사용된 HTML 테이블 원하는 웹 페이지의 URL을 함수 read_html()에 입력하여 얻은 결과에서 table 노드를 함수 html_elements()로 찾아보자. 함수 html_elements()는 결과를 리스트 형태로 출력한다. library(rvest) URL &lt;- &quot;https://en.wikipedia.org/wiki/World_population&quot; web &lt;- read_html(URL) tbl &lt;- html_elements(web, &quot;table&quot;) 모두 29개의 table 노드가 발견되었고, 그 중 처음 6개의 내용을 출력해 보자. length(tbl) ## [1] 29 head(tbl) ## {xml_nodeset (6)} ## [1] &lt;table class=&quot;wikitable&quot; style=&quot;text-align:center; float:right; clear:rig ... ## [2] &lt;table class=&quot;wikitable&quot;&gt;\\n&lt;caption&gt;Current world population and latest p ... ## [3] &lt;table class=&quot;box-Notice plainlinks metadata ambox ambox-notice&quot; role=&quot;pr ... ## [4] &lt;table class=&quot;wikitable sortable&quot;&gt;\\n&lt;caption&gt;Population by region (2020 e ... ## [5] &lt;table class=&quot;wikitable sortable&quot;&gt;&lt;tbody&gt;\\n&lt;tr&gt;\\n&lt;th scope=&quot;col&quot;&gt;Rank\\n&lt;/ ... ## [6] &lt;table class=&quot;wikitable&quot; style=&quot;font-size:90%&quot;&gt;\\n&lt;caption&gt;World populatio ... 함수 html_elements()의 결과로 생성된 리스트 객체인 tbl의 29개 구성요소 중 우리가 원하는 HTML 테이블에 해당되는 노드를 찾아서 함수 html_table()에 입력하면, 해당 테이블 데이터가 R로 입력된다. 문제는 몇 번째 노드가 우리가 원하는 테이블에 관한 것인지 알기가 어렵다는 점이다. 시행착오를 거치면, 원하는 테이블이 2023년 8월에는 8번째 노드에 있다는 것을 알 수 있었고, 따라서 html_table(tbl[8])을 실행하면 테이블의 데이터를 불러올 수 있다. 그러나 HTML 테이블이 많은 웹 페이지에서는 다른 체계적인 방법이 필요할 것이다. 웹 페이지에서 HTML 테이블을 체계적으로 찾는 방법 중 하나는 해당 테이블 노드의 XPath를 알아내는 것이다. XPath는 웹 문서에서 원하는 태그나 속성 등을 쉽게 찾기 위해 개발된 것으로 윈도우의 파일 경로와 비슷한 개념이라고 하겠다. 크롬 웹 브라우저를 대상으로 웹 페이지에서 원하는 HTML 테이블의 XPath를 알아내는 방법은 다음과 같다. 원하는 웹 페이지로 이동 F12 키를 눌러서(또는 마우스 오른쪽 버튼 클릭 &gt; 검사 클릭) 개발자 도구 실행. 창이 분리되며 오른쪽 창에 html 코드가 나타남. Ctrl + F 키를 눌러서 나타난 찾기 창에 &lt;table을 입력하고 찾기 실행 원하는 테이블에 해당되는 노드를 찾게 되면 그림 3.2에서와 같이 테이블이 하이라이트가 된다. 이어서 마우스 오른쪽 버튼을 클릭 나타난 별도 메뉴에서 Copy &gt; Copy XPath를 클릭 그림 3.2: 예제 1의 HTML 테이블 XPath 복사 원하는 HTML 테이블의 XPath의 값은 2023년 8월에 확인한 것으로는 //*[@id=\"mw-content-text\"]/div[1]/table[7]이며, 이것을 함수 html_elements()안에 옵션 xpath에 지정하면 된다. X_path &lt;- &#39;//*[@id=&quot;mw-content-text&quot;]/div[1]/table[7]&#39; node_1 &lt;- html_elements(web, xpath = X_path) tbl_1 &lt;- html_table(node_1) tbl_1 ## [[1]] ## # A tibble: 10 × 5 ## Rank Country Population `Area(km2)` `Density(pop/km2)` ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Singapore 5,921,231 719 8,235 ## 2 2 Bangladesh 165,650,475 148,460 1,116 ## 3 3 Palestine[note 3][103] 5,223,000 6,025 867 ## 4 4 Taiwan[note 4] 23,580,712 35,980 655 ## 5 5 South Korea 51,844,834 99,720 520 ## 6 6 Lebanon 5,296,814 10,400 509 ## 7 7 Rwanda 13,173,730 26,338 500 ## 8 8 Burundi 12,696,478 27,830 456 ## 9 9 India 1,389,637,446 3,287,263 423 ## 10 10 Netherlands 17,400,824 41,543 419 함수 html_table()로 생성된 객체 tbl_1은 하나의 데이터 프레임으로 구성된 리스트이다. 변수 이름을 수정하고 입력된 자료를 출력해 보자.. top_pop &lt;- tbl_1[[1]] names(top_pop) &lt;- c(&quot;rank&quot;, &quot;country&quot;, &quot;pop&quot;, &quot;area&quot;, &quot;density&quot;) top_pop ## # A tibble: 10 × 5 ## rank country pop area density ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Singapore 5,921,231 719 8,235 ## 2 2 Bangladesh 165,650,475 148,460 1,116 ## 3 3 Palestine[note 3][103] 5,223,000 6,025 867 ## 4 4 Taiwan[note 4] 23,580,712 35,980 655 ## 5 5 South Korea 51,844,834 99,720 520 ## 6 6 Lebanon 5,296,814 10,400 509 ## 7 7 Rwanda 13,173,730 26,338 500 ## 8 8 Burundi 12,696,478 27,830 456 ## 9 9 India 1,389,637,446 3,287,263 423 ## 10 10 Netherlands 17,400,824 41,543 419 변수 pop, area, density이 숫자가 아닌 문자형 벡터로 입력되었음을 알 수 있다. 이것은 숫자에 콤마가 함께 입력되어 있기 때문인데, 이제 변수 pop을 숫자형으로 변환하여 평균을 구해 보자. 숫자형으로 변환하는 방법은 pop에 포함된 콤마를 2장에서 살펴본 함수 gsub()를 사용하여 제거하고, 이어서 함수 as.numeric()을 사용하여 유형을 숫자형으로 변환하면 된다. pop &lt;- top_pop$pop pop &lt;- gsub(&quot;,&quot;, &quot;&quot;, pop) mean(as.numeric(pop)) ## [1] 169042554 \\(\\bullet\\) 예제 2: KBO 홈페이지 기록실에 있는 자료 불러오기 KBO 홈페이지의 기록실에 있는 자료를 불러와 보자. 자료를 불러온 시점은 2023-08-23이며, 내용은 KBO 정규 시즌 중 타자들의 팀 기록이다. 불러오고자 하는 HTML 테이블은 그림 3.3에서 볼 수 있다. 해당 웹 페이지에는 하나의 HTML 테이블만이 있기 때문에 굳이 XPath를 복사해야 할 필요는 없다. 한글이 포함된 HTML 테이블을 불러와 보자. 그림 3.3: 예제 2에서 사용된 HTML 테이블 R 버전 4.2.0부터 한글 인코딩이 UTF-8 방식으로 되어 있다면, locale 조정 없이 바로 불러올 수 있다. URL_2 &lt;- &quot;https://www.koreabaseball.com/Record/Team/Hitter/Basic1.aspx&quot; web_2 &lt;- read_html(URL_2) node_2 &lt;- html_elements(web_2, &quot;table&quot;) tbl_2 &lt;- html_table(node_2)[[1]] 합계가 들어간 마지막 행을 삭제하고, 결과를 출력해 보자. tbl_2 &lt;- tbl_2[-nrow(tbl_2),] tbl_2 ## # A tibble: 10 × 15 ## 순위 팀명 AVG G PA AB R H `2B` `3B` HR TB RBI ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 LG 0.285 104 4197 3588 578 1022 176 19 66 1434 539 ## 2 2 KIA 0.269 100 3897 3430 484 921 151 16 69 1311 451 ## 3 3 NC 0.268 102 4021 3505 480 938 161 24 67 1348 452 ## 4 4 KT 0.267 107 4211 3724 508 993 177 11 63 1381 467 ## 5 5 삼성 0.266 107 4165 3688 474 980 164 17 67 1379 450 ## 6 6 롯데 0.262 104 4019 3503 473 917 159 15 52 1262 439 ## 7 7 SSG 0.256 103 3993 3502 455 898 165 9 89 1348 425 ## 8 8 키움 0.254 114 4506 3971 468 1007 174 20 49 1368 448 ## 9 9 두산 0.253 103 3962 3479 431 880 145 24 71 1286 395 ## 10 10 한화 0.241 104 4104 3567 441 860 154 7 75 1253 414 ## # ℹ 2 more variables: SAC &lt;int&gt;, SF &lt;int&gt; 일반적으로 웹 페이지에 있는 HTML 테이블을 R로 불러온 후에도 실제 분석 데이터로 사용하기 위해서는 많은 추가 작업이 필요하게 된다. 3.5 연습문제 1. 다음은 Wikipedia에서 covid-19 관련 자료가 있는 웹 페이지(https://en.wikipedia.org/wiki/COVID-19_pandemic_by_country_and_territory)에 있는 HTML 테이블의 일부분이다. R로 불러와서 tibble ex3_1에 입력하고, 다음과 같이 출력해 보자. ex3_1 ## # A tibble: 223 × 4 ## `` Location `Vaccinated[a]` `Percent[b]` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;&quot; World[c][d] 5,620,635,452 70.48% ## 2 &quot;&quot; China[e] 1,310,292,000 91.89% ## 3 &quot;&quot; India 1,027,416,053 72.50% ## 4 &quot;&quot; European Union[f] 337,972,446 75.08% ## 5 &quot;&quot; United States[g] 270,227,181 81.39% ## 6 &quot;&quot; Indonesia 203,845,350 73.99% ## 7 &quot;&quot; Brazil 189,643,431 88.08% ## 8 &quot;&quot; Pakistan 165,567,890 70.21% ## 9 &quot;&quot; Bangladesh 151,501,145 88.50% ## 10 &quot;&quot; Japan 104,705,133 84.47% ## # ℹ 213 more rows 자료가 없는 ex3_1의 첫 번째 변수를 제거하고, 세 번째 변수 Vaccinated[a]와 네 번째 변수 Percent[b]는 이름을 Vaccinated와 Percent로 변경하자. 또한 첫 번째 행과 자료가 잘못 입력된 마지막 행도 제거해 보자. 변경된 데이터 프레임의 처음 3개 행과 마지막 3개 행의 내용은 다음과 같다. head(ex3_1, n = 3) ## # A tibble: 3 × 3 ## Location Vaccinated Percent ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 China[e] 1,310,292,000 91.89% ## 2 India 1,027,416,053 72.50% ## 3 European Union[f] 337,972,446 75.08% tail(ex3_1, n = 3) ## # A tibble: 3 × 3 ## Location Vaccinated Percent ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Niue 1,650 102.23% ## 2 Pitcairn Islands 47 100.00% ## 3 North Korea 0 0.00% 변수 Percent는 백신 접종률을 나타내는 변수이다. 백신 접종률이 95%를 초과하는 나라를 선택해서 ex3_2에 입력하고, 다음과 같이 출력해 보자. ex3_2 ## # A tibble: 11 × 3 ## Location Vaccinated Percent ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Cuba 10767477 96.0 ## 2 United Arab Emirates 9991089 100 ## 3 Portugal 9789941 95.3 ## 4 Qatar 2852178 106. ## 5 Macau 679703 97.8 ## 6 Brunei 451149 100. ## 7 Gibraltar 42175 129. ## 8 Nauru 13106 103. ## 9 Tokelau 2203 116. ## 10 Niue 1650 102. ## 11 Pitcairn Islands 47 100 2. 웹서버 https://raw.githubusercontent.com/yjyjpark/R-and-statistical-analysis/master/Data/에 있는 파일 ex3-2.csv에는 1993년 미국에서 판매된 93대 자동차의 생산 회사(Manufacturer)와 차량 모델 (Model) 의 최소 가격 (Min.Price) 및 최대 가격 (Max.Price)이 입력되어 있다. 파일 ex3-2.csv를 불러와서 데이터 프레임에 입력하고 다음과 같이 출력해 보자. ## # A tibble: 93 × 4 ## Manufacturer Model Min.Price Max.Price ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Acura Integra $12,900 $18,800.00 ## 2 Acura Legend $29,200 $38,700.00 ## 3 Audi 90 $25,900 $32,300.00 ## # ℹ 90 more rows 변수 Manufacturer와 Model을 하나의 변수 model로 통합하고 , 변수 Min.Price와 Max.Price의 평균으로 변수 price를 생성해 보자. 이어서 두 변수 model 과 price로 이루어진 데이터 프레임을 만들어 다음과 같이 출력해 보자 ## # A tibble: 93 × 2 ## model price ## &lt;chr&gt; &lt;dbl&gt; ## 1 Acura Integra 15850 ## 2 Acura Legend 33950 ## 3 Audi 90 29100 ## # ℹ 90 more rows 변수 price의 값이 가장 큰 자동차와 가장 작은 지동차의 model 값을 각각 구하고 두 자동차의 price 차이도 구해 보자 3. 다음은 Wikipedia에서 우리나라의 2012년 20개 주요 수출품목 자료가 있는 웹 페이지(https://en.wikipedia.org/wiki/List_of_exports_of_South_Korea) 에 있는 HTML 테이블의 일부분이다. 대한민국 주요 수출품목 HTML 테이블을 R로 불러와 다음과 같이 출력해 보자. export |&gt; print(n = 6) ## # A tibble: 20 × 3 ## `#` Country Value ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Refined petroleum 51,540 ## 2 2 Integrated circuits 49,126 ## 3 3 Cars 42,484 ## 4 4 Passenger and Cargo Ships 29,010 ## 5 5 LCDs 23,978 ## 6 6 Car parts 20,496 ## # ℹ 14 more rows 변수 이름을 다음과 같이 rank, item, value로 변경하자. export |&gt; print(n = 3) ## # A tibble: 20 × 3 ## rank item value ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 Refined petroleum 51,540 ## 2 2 Integrated circuits 49,126 ## 3 3 Cars 42,484 ## # ℹ 17 more rows 변수 value는 각 품목의 수출액이다. 각 품목의 수출액이 20개 전체 품목의 총 수출액에서 차지하는 비율을 나타내는 변수 prop를 다음과 같이 생성해 보자. export |&gt; print(n = 5) ## # A tibble: 20 × 4 ## rank item value prop ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Refined petroleum 51540 16.2 ## 2 2 Integrated circuits 49126 15.5 ## 3 3 Cars 42484 13.4 ## 4 4 Passenger and Cargo Ships 29010 9.14 ## 5 5 LCDs 23978 7.56 ## # ℹ 15 more rows 변수 prop의 값이 5 이상인 품목만을 선택해서 다음의 형태로 출력해 보자. export_5 ## # A tibble: 6 × 3 ## item value prop ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Refined petroleum 51540 16.24% ## 2 Integrated circuits 49126 15.48% ## 3 Cars 42484 13.39% ## 4 Passenger and Cargo Ships 29010 9.14% ## 5 LCDs 23978 7.56% ## 6 Car parts 20496 6.46% 변수 prop의 값이 5 이상인 품목의 평균 수출액을 계산해 보자. 4. 파일 airs.csv에는 1973년 5월 뉴욕시에서 측정된 공기의 질과 관련된 자료가 입력되어 있다. R로 불러와서 다음과 같이 출력해 보자. print(airs, n = 4) ## # A tibble: 31 × 5 ## Day Ozone Solar.R Wind Temp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 41 190 7.4 67 ## 2 2 36 118 8 72 ## 3 3 12 149 12.6 74 ## 4 4 18 313 11.5 62 ## # ℹ 27 more rows 네 변수들의 평균을 다음의 형태로 출력해 보자. 평균값이 NA로 나온 변수가 있는 이유는 무엇인가? ## Ozone Solar.R Wind Temp ## NA NA 11.62258 65.54839 변수의 평균값이 NA가 되지 않도록 조치해서 다음의 형태로 다시 출력해 보자. ## Ozone Solar.R Wind Temp ## 23.61538 181.29630 11.62258 65.54839 변수 Ozone과 Solor.R의 결측값이 있는 행은 모두 제거하고, 그 결과를 airs_1에 할당하라. airs_1의 변수 Ozone이 평균값 이상인 그룹과 평균값 미만인 그룹으로 구분해 주는 변수 Oz.Gp를 생성해서, 다음과 같이 airs_1에 추가하자. airs_1 |&gt; print(n = 4) ## # A tibble: 24 × 6 ## Day Ozone Solar.R Wind Temp Oz.Gp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 1 41 190 7.4 67 High ## 2 2 36 118 8 72 High ## 3 3 12 149 12.6 74 Low ## 4 4 18 313 11.5 62 Low ## # ℹ 20 more rows airs_1의 변수 Oz.Gp의 값이 High인 그룹과 Low인 그룹에서 변수 Solor.R, Wind, Temp의 평균값에 어떤 차이가 있는지 확인하고, 그 효과를 설명해 보자. airs_L &lt;- airs_1[airs_1$Oz.Gp == &quot;Low&quot;,] airs_H &lt;- airs_1[airs_1$Oz.Gp == &quot;High&quot;,] 5. 파일 cars.csv에는 234대 자동차의 제조회사, 모델, 엔진 기통 수, 변속기 종류, 연비가 입력되어 있다. R로 불러와서 다음과 같이 출력해 보자. cars |&gt; print(n = 3) ## # A tibble: 234 × 5 ## manufacturer model cyl trans mpg ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 audi a4 4 auto 29 ## 2 audi a4 4 manual 29 ## 3 audi a4 4 manual 31 ## # ℹ 231 more rows 변수 manufacturer와 model을 변수 maker로 통합해 보자. 두 변수 값을 통합할 때 구분자는 \"-\"을 사용하라. 통합 결과는 다음과 같다. cars |&gt; print(n = 3) ## # A tibble: 234 × 4 ## maker cyl trans mpg ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 audi-a4 4 auto 29 ## 2 audi-a4 4 manual 29 ## 3 audi-a4 4 manual 31 ## # ℹ 231 more rows 변수 maker의 값이 동일한 자동차가 많이 입력되어 있다. 변수 maker에는 몇 종류의 서로 다른 자동차 모델이 입력되어 있는지 확인해 보자. 변수 cyl의 값이 4이고 trans의 값이 \"auto\"인 자동차의 대수와 변수 cyl의 값이 8이고 trans의 값이 \"auto\"인 자동차의 대수를 확인하자. 변수 cyl의 값이 4이고 trans의 값이 \"auto\"인 자동차의 변수 mpg의 평균값과 변수 cyl의 값이 8이고 trans의 값이 \"auto\"인 자동차의 변수 mpg의 평균값을 계산하고 비교해 보자. "],["dplyr에-의한-데이터-다듬기.html", "4 장 dplyr에 의한 데이터 다듬기 4.1 행을 작업 대상으로 하는 함수 4.2 열을 작업 대상으로 하는 함수 4.3 여러 행 자료의 요약: summarise() 4.4 그룹 데이터 프레임 4.5 다수의 열을 대상으로 하는 작업: across() 4.6 행 단위 작업: rowwise() 4.7 연습문제", " 4 장 dplyr에 의한 데이터 다듬기 R에 입력된 데이터 세트는 대부분의 경우 바로 통계분석이 가능한 상태가 아니다. 분석에 필요한 적절한 변수가 없거나, 특정 조건을 만족하는 자료만을 선택해야 하거나, 자료의 순서를 바꿔야 하거나, 그룹별로 자료를 합치거나 또는 나눠야 하는 등등의 작업이 필요한 경우가 대부분이다. 이러한 데이터 다듬기는 최적의 통계 예측모형 적합 등을 위해 반드시 필요한 절차이지만, 시간이 매우 많이 소요되는 힘든 작업이다. 따라서 일관된 법칙에 따라 편리하고 효율적으로 적용할 수 있는 데이터 다듬기 기법이 절실하게 필요한 상황이라고 하겠다. 통계 데이터 세트는 변수가 열, 관찰값이 행을 이루고 있는 2차원 구조를 가지고 있으며 데이터 프레임으로 입력된다. 이 장에서 살펴볼 내용은 패키지 dplyr에서 수행할 수 있는 다양한 데이터 프레임 다듬기 기법이다. 먼저 데이터 프레임 다듬기 작업에 사용되는 매우 중요하면서도 기본적인 dplyr 함수들을 살펴볼 것이다. 이어서 이러한 기본 dplyr 함수들 이 그룹으로 구분된 데이터에 대해서는 어떻게 작용을 하는지 살펴볼 것이며, 여러 개의 변수들을 대상으로 반복적으로 실행해야 하는 동일한 작업을 함수 across()를 이용하면 얼마나 간편하게 할 수 있는지를 살펴볼 것이다. 또한 행 단위로 작업이 이루어져야 하는 경우에 함수 rowwise()가 어떤 역할을 하는지도 살펴볼 것이다. 기본 dplyr 함수들은 세 가지 그룹으로 나누어 볼 수 있다. 함수 filter(), slice(), arrange(), distinct()와 같이 데이터 프레임의 행을 작업 대상으로 하는 함수가 있고, 함수 select(), rename(), mutate(), relocate()와 같이 열을 대상으로 작업을 하는 함수가 있으며, 요약 통계량을 계산하는 함수 summarise()가 있다. 기본 dplyr 함수들이 공통으로 갖고 있는 특징은 데이터 프레임(또는 tibble)이 함수들의 첫 번째 입력요소라는 것이다. 두 번째 특징은 각 함수 안에서 입력된 데이터 프레임의 변수를 인덱싱 기호($) 없이 사용할 수 있다는 것이다. 마지막 특징은 이 함수들이 생성하는 결과는 또 다른 데이터 프레임(또는 tibble)이라는 것이다. 기본 함수들이 갖고 있는 이러한 특징을 이용해서 조금 더 효율적인 프로그램이 가능하도록 dplyr에서는 pipe 기능을 사용하도록 하자. Pipe 기능 Pipe 기능이란 한 명령문의 결과물을 바로 다음 명령문의 입력 요소로 직접 사용할 수 있도록 명령문들을 서로 연결하는 기능을 의미한다. 이것이 가능하다면, 분석 중간 단계로 생성되는 무수한 객체들을 따로 저장할 필요가 없기 때문에 프로그램 자체가 매우 깔끔하게 정리되며, 분석 흐름을 쉽게 이해할 수 있게 된다. Pipe 연산자 %&gt;%는 tidyverse에 속한 패키지인 magrittr에서 정의된 것으로 tidyverse에 속한 다른 패키지에서도 사용이 가능하다. RStudio에서 pipe 연산자 %&gt;%의 입력은 Shift+Ctrl+M 키를 함께 누르면 된다. 기본적인 형태는 lhs %&gt;% rhs인데, lhs는 데이터 객체이거나 데이터 객체를 생성하는 함수가 되고, rhs는 lhs를 입력 요소로 하는 함수가 된다. 예를 들어 x %&gt;% f()는 객체 x를 함수 f()의 입력 요소로 하는 f(x)를 의미한다. 만일 rhs에 다른 요소가 있다면 lhs는 rhs의 첫 번째 입력 요소가 된다. 따라서 x %&gt;% f(y)는 f(x,y)를 의미한다. 만일 lhs가 rhs의 첫 번째 요소가 아닌 경우에는 원하는 위치에 점(.)을 찍어야 한다. 예를 들어, x %&gt;% f(y,.)은 f(y,x)를 의미한다. Base R에도 R 버전 4.1.0부터 pipe 연산자 |&gt;가 도입되었다. 패키지 tidyverse를 불러오지 않아도 사용할 수 있다는 것이 장점으로 볼 수 있는 연산자이다. 사용법은 lhs |&gt; rhs이며, lhs와 rhs의 의미는 %&gt;%의 경우와 같다. RStudio의 메뉴 Tools &gt; Global Options...에서 Use native pipe operator, |&gt;를 선택하면, Shift+Ctrl+M 키를 단축키로 사용할 수 있다. 앞으로 이 책에서는 두 pipe 연산자를 혼용해서 사용하도록 하겠다. 4.1 행을 작업 대상으로 하는 함수 4.1.1 조건에 의한 행 선택: filter() 함수 filter()를 이용하면, 주어진 데이터 프레임에서 특정한 조건을 만족하는 행을 선택 할 수 있다. 조건을 설정할 때는 비교 연산자(&gt;, &gt;=, &lt;, &lt;=, !=, ==)와 논리 연산자(&amp;, |, !)가 사용되며, 연산자 %in%이 매우 유용하게 사용된다. 예제를 통해 자세한 사용법을 확인해 보자. 예제: mtcars 변수 mpg의 값이 30 이상인 자동차를 선택해 보자. 함수 filter()에 전통적인 데이터 프레임을 입력하면 결과로 전통적인 데이터 프레임이 출력되고, tibble을 입력하면 결과가 tibble로 출력된다. 데이터 프레임 mtcars를 tibble로 전환하고 선택 조건과 더불어 함수 filter()에 입력해 보자. library(tidyverse) mtcars_t &lt;- as_tibble(mtcars) mtcars_t |&gt; filter(mpg &gt;= 30) ## # A tibble: 4 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 2 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 3 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 4 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 변수 mpg의 값이 30 이상이고 변수 wt의 값이 1.8 미만인 자동차를 선택해 보자. 함수 filter()에서는 콤마(,)가 논리 연산자 &amp; 와 같은 기능을 갖고 있다. mtcars_t |&gt; filter(mpg &gt;= 30, wt &lt; 1.8) ## # A tibble: 2 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 2 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 변수 mpg의 값이 30 이하이고, 변수 cyl의 값이 6 또는 8이며, 변수 am의 값이 1인 자동차를 선택해 보자. 이 경우에, 변수 cyl의 값이 6 또는 8인 사건에 대하여 논리 연산자를 사용해서 cyl == 6|cyl == 8으로 조건을 설정하는 것보다는, cyl %in% c(6,8)로 쓰는 것이 훨씬 간단한 방법이 된다. mtcars_t |&gt; filter(mpg &lt;= 30, cyl %in% c(6,8), am == 1) ## # A tibble: 5 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 ## 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 ## 5 15 8 301 335 3.54 3.57 14.6 0 1 5 8 변수 mpg의 값이 mpg의 중앙값과 \\(Q_{3}\\) 사이에 있는 자동차를 선택해 보자. 여기서 \\(Q_{3}\\)는 0.75분위수를 의미하는 것으로서, \\(p\\) 분위수란 전체 데이터 중 \\((100 \\times p)\\)% 데이터보다는 크고, 나머지 \\((100 \\times (1-p))\\)% 데이터보다는 작은 수를 의미한다. 분위수의 계산은 함수 quantile()로 하는데, 벡터 x의 0.75분위수의 계산은 quantile(x, probs = 0.75)로 할 수 있다. mtcars_t |&gt; filter( mpg &gt;= median(mpg), mpg &lt;= quantile(mpg, probs = 0.75) ) ## # A tibble: 10 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 6 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 7 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 ## 9 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 ## 10 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 벡터 x가 특정 두 숫자 사이에 있는지를 확인하는 방법은 x &gt;= left &amp; x &lt;= right가 되는데, 이것을 함수 between()을 이용해서 between(x, left, right)로 할 수 있다. between(1:5, 2, 4) ## [1] FALSE TRUE TRUE TRUE FALSE 따라서 위 예제는 다음과 같이 실행해도 동일한 결과를 얻는다. mtcars_t |&gt; filter( between(mpg, median(mpg), quantile(mpg, probs = 0.75)) ) ## # A tibble: 10 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 6 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 7 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 ## 9 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 ## 10 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 예제: airquality 데이터 프레임 airquality는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의 질과 관련된 조사 결과를 담은 데이터 세트이다. airs라는 이름의 tibble로 전환하고, 처음 5개 케이스를 출력해 보자. airs &lt;- as_tibble(airquality) %&gt;% print(n = 5) ## # A tibble: 153 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 41 190 7.4 67 5 1 ## 2 36 118 8 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## # ℹ 148 more rows 변수 Ozone 또는 Solar.R이 결측값인 행을 선택해 보자. 결측값의 확인은 함수 is.na()로 할 수 있다. airs %&gt;% filter(is.na(Ozone) | is.na(Solar.R)) %&gt;% print(n = 5) ## # A tibble: 42 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 NA NA 14.3 56 5 5 ## 2 28 NA 14.9 66 5 6 ## 3 NA 194 8.6 69 5 10 ## 4 7 NA 6.9 74 5 11 ## 5 NA 66 16.6 57 5 25 ## # ℹ 37 more rows 4.1.2 위치에 의한 행 선택: slice() 및 그와 관련된 함수 위치에 의한 행 선택이란 데이터 프레임에서 선택하고자 하는 행 번호를 지정해서 선택하는 것을 의미한다. 함수 slice()에 의한 행 선택 함수 slice()에는 행의 번호를 직접 지정해서 특정 행을 선택하거나 제거할 수 있다. 양의 정수를 입력하면 해당 위치의 행이 선택되고, 음의 정수를 입력하면 해당 위치의 행이 제거된다. 입력되는 정수는 모두 양수이거나 모두 음수이어야 한다. 데이터 프레임 iris를 tibble로 전환하고 5번째 행부터 10번째 행까지 선택해 보자. iris_t &lt;- as_tibble(iris) iris_t |&gt; slice(5:10) ## # A tibble: 6 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5 3.6 1.4 0.2 setosa ## 2 5.4 3.9 1.7 0.4 setosa ## 3 4.6 3.4 1.4 0.3 setosa ## 4 5 3.4 1.5 0.2 setosa ## 5 4.4 2.9 1.4 0.2 setosa ## 6 4.9 3.1 1.5 0.1 setosa 이번에는 5번째 행부터 10번째 행을 제거해 보자. iris_t |&gt; slice(-(5:10)) |&gt; print(n = 3) ## # A tibble: 144 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## # ℹ 141 more rows 이번에는 iris의 마지막 행을 선택해 보자. 이 경우 유용하게 사용될 함수가 n()이다. 이 함수는 데이터 프레임의 행의 개수를 세는 함수로서 단독으로는 사용될 수 없고 dplyr 기본 함수들과 함께 사용되어야 한다. iris_t |&gt; slice(n()) ## # A tibble: 1 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.9 3 5.1 1.8 virginica 함수 slice_head()와 slice_tail()에 의한 행 선택 데이터 프레임의 처음 몇 개 행을 선택하거나 마지막 몇 개 행을 선택하고자 할 때 사용되는 함수이다. 행의 개수를 지정하는 경우에는 n을 사용하고 행의 비율을 지정하는 경우에 는 prop를 사용하면 된다. 데이터 프레임 iris의 처음 3개 행과 마지막 3개 행을 각각 선택해 보자. iris_t |&gt; slice_head(n = 3) ## # A tibble: 3 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa iris_t |&gt; slice_tail(n = 3) ## # A tibble: 3 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 6.5 3 5.2 2 virginica ## 2 6.2 3.4 5.4 2.3 virginica ## 3 5.9 3 5.1 1.8 virginica 함수 slice_sample()에 의한 행 선택 데이터 프레임의 일부 행을 단순임의추출방법으로 선택할 때 사용되는 함수이다. 행의 개수를 지정해서 추출하는 경우에는 n을 사용하고, 행의 비율을 지정해서 추출하는 경우에는 prop를 사용하면 된다. 두 함수 모두 비복원추출이 디폴트로 적용되며, 만일 복원추출을 원한다면, replace=TRUE를 입력하면 된다. 데이터 프레임 iris에서 3개 행을 임의추출해 보자. iris_t |&gt; slice_sample(n = 3) ## # A tibble: 3 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 4.9 3.1 1.5 0.1 setosa ## 2 4.6 3.1 1.5 0.2 setosa ## 3 6.5 3 5.8 2.2 virginica 전체 행 중 2%의 행을 비복원추출로 선택해 보자. iris_t |&gt; slice_sample(prop = 0.02) ## # A tibble: 3 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 7.7 3 6.1 2.3 virginica ## 2 5.8 2.6 4 1.2 versicolor ## 3 5.6 2.7 4.2 1.3 versicolor 이번에는 전체 행 중 2%의 행을 복원추출로 선택해 보자. iris_t |&gt; slice_sample(prop = 0.02, replace = TRUE) ## # A tibble: 3 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 6.5 3 5.5 1.8 virginica ## 2 5.1 2.5 3 1.1 versicolor ## 3 7.7 3 6.1 2.3 virginica 함수 slice_max()와 slice_min()에 의한 행 선택 특정 변수가 가장 큰 값을 갖거나 혹은 가장 작은 값을 갖는 행을 선택할 때 사용되는 함수이다. 기준으로 사용할 변수를 입력하고 이어서 행의 개수를 지정하는 경우에는 n을, 행의 비율을 지정하는 경우에는 prop를 입력하면 된다. 데이터 프레임 iris에서 변수 Sepal.Width의 값이 가장 큰 두 개 행을 선택해 보자. iris_t |&gt; slice_max(Sepal.Width, n = 2) ## # A tibble: 2 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.7 4.4 1.5 0.4 setosa ## 2 5.5 4.2 1.4 0.2 setosa 이번에는 Petal.Length의 값이 가장 작은 두 개 행을 선택해 보자. iris_t |&gt; slice_min(Petal.Length, n = 2) ## # A tibble: 2 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 4.6 3.6 1 0.2 setosa ## 2 4.3 3 1.1 0.1 setosa 4.1.3 행의 정렬: arrange() 함수 arrange()는 특정 변수를 기준으로 데이터 프레임의 행을 재배열할 때 사용된다. 함수에는 정렬의 기준이 되는 변수를 입력하면 되는데, 2개 이상의 정렬 기준 변수를 입력하게 되면 추가된 변수는 앞선 변수가 같은 값을 갖는 행들의 정렬 기준으로 사용된다. 정렬은 오름차순이 디폴트이며, 내림차순으로 배열하고자 할 때에는 기준 변수를 함수 desc()와 함께 사용해야 한다. 예제: mtcars 데이터 프레임 mtcars를 tibble로 전환하고 변수 mpg의 값이 가장 좋지 않은 자동차부터 시작해서 더 좋아지는 순서로 다시 배열해 보자. 연비가 좋지 않다는 것은 연비가 낮다는 것을 의미하는 것이므로 변수 mpg를 오름차순 정렬 변수로 사용하면 된다. mtcars_t &lt;- as_tibble(mtcars) mtcars_t |&gt; arrange(mpg) |&gt; print(n = 5) ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 2 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## # ℹ 27 more rows 데이터 프레임 mtcars_t를 변수 mpg의 값이 가장 좋지 않은 자동차부터 시작해서 더 좋아지는 순서로 다시 배열을 하되, mpg 값이 같은 자동차의 경우에는 변수 wt의 값이 높은 자동차부터 배열해 보자. 변수 wt를 두 번째 정렬 기준 변수로 입력하되, 내림차순 정렬이 필요하므로 함수 desc()를 이용한다. mtcars_t |&gt; arrange(mpg, desc(wt)) |&gt; print(n = 5) ## # A tibble: 32 × 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## 2 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 ## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 ## # ℹ 27 more rows 예제: airquality 데이터 프레임 airquality를 tibble로 전환하고, 5월 1일부터 5월 10일까지의 자료만을 대상으로 변수 Ozone의 값이 가장 낮았던 날부터 다시 배열해 보자. airs_1 &lt;- as_tibble(airquality) |&gt; filter(Month == 5, Day &lt;= 10) airs_1 |&gt; arrange(Ozone) ## # A tibble: 10 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 8 19 20.1 61 5 9 ## 2 12 149 12.6 74 5 3 ## 3 18 313 11.5 62 5 4 ## 4 19 99 13.8 59 5 8 ## 5 23 299 8.6 65 5 7 ## 6 28 NA 14.9 66 5 6 ## 7 36 118 8 72 5 2 ## 8 41 190 7.4 67 5 1 ## 9 NA NA 14.3 56 5 5 ## 10 NA 194 8.6 69 5 10 위의 정렬 결과를 보면 변수 Ozone이 결측값인 행이 가장 뒤로 배열되어 있다. 이것이 문제는 아니지만, 어떤 경우에는 결측값인 행을 가장 앞으로 배열하는 것이 필요할 때도 있다. 데이터 프레임 airs_1을 변수 Ozone이 결측값인 행부터 다시 배열해 보자. 이것은 배열 기준으로 논리형 벡터를 사용해야 되는 문제인데, TRUE와 FALSE의 배열에서 FALSE가 우선 순위에 있기 때문에 !is.na(Ozone)을 배열 기준으로 사용하면 된다. airs_1 |&gt; arrange(!is.na(Ozone)) ## # A tibble: 10 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 NA NA 14.3 56 5 5 ## 2 NA 194 8.6 69 5 10 ## 3 41 190 7.4 67 5 1 ## 4 36 118 8 72 5 2 ## 5 12 149 12.6 74 5 3 ## 6 18 313 11.5 62 5 4 ## 7 28 NA 14.9 66 5 6 ## 8 23 299 8.6 65 5 7 ## 9 19 99 13.8 59 5 8 ## 10 8 19 20.1 61 5 9 이번에는 데이터 프레임 airs_1을 변수 Ozone의 값이 가장 높은 날부터 다시 배열하되 결측값이 있는 행을 가장 앞으로 배열해 보자. 이때는 !is.na(Ozone)을 첫 번째 배열 기준으로 하여 결측값이 있는 행을 가장 앞으로 배치하고, desc(Ozone)을 두 번째 배열 기준으로 입력해서 결측값이 아닌 행들을 변수 Ozone의 내림차순으로 다시 배열해야 된다. airs_1 |&gt; arrange(!is.na(Ozone), desc(Ozone)) ## # A tibble: 10 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 NA NA 14.3 56 5 5 ## 2 NA 194 8.6 69 5 10 ## 3 41 190 7.4 67 5 1 ## 4 36 118 8 72 5 2 ## 5 28 NA 14.9 66 5 6 ## 6 23 299 8.6 65 5 7 ## 7 19 99 13.8 59 5 8 ## 8 18 313 11.5 62 5 4 ## 9 12 149 12.6 74 5 3 ## 10 8 19 20.1 61 5 9 4.1.4 중복된 행의 제거: distinct() 함수 distinct()는 중복 입력된 행을 제거해서, 서로 다른 값을 갖고 있는 행만 선택할 때 사용되는 함수이다. 따라서 함수에는 중복 여부를 결정할 변수를 입력해야 되는데, 입력한 변수가 없다면 모든 변수들을 대상으로 중복 여부를 결정한다. 함수 distinct()로 생성되는 데이터 프레임은 중복 여부를 확인하기 위해서 입력한 변수만 유지되는데, 옵션 .keep_all=TRUE가 지정되면 다른 모든 변수도 유지된다. 다만, 이 경우에는 중복된 행 중 첫 번째 행이 선택된다. 단순한 형태의 데이터 프레임으로 함수 distinct()의 작동 방식을 살펴보자. df1 &lt;- tibble(id = rep(1:3, times = 2:4), x1 = c(1:2, 1:3, 1:4)) df1 ## # A tibble: 9 × 2 ## id x1 ## &lt;int&gt; &lt;int&gt; ## 1 1 1 ## 2 1 2 ## 3 2 1 ## 4 2 2 ## 5 2 3 ## 6 3 1 ## 7 3 2 ## 8 3 3 ## 9 3 4 변수 id가 중복되지 않은 행들을 선택해 보자. df1 |&gt; distinct(id) ## # A tibble: 3 × 1 ## id ## &lt;int&gt; ## 1 1 ## 2 2 ## 3 3 변수 id만 있는 데이터 프레임이 생성되는 것을 알 수 있다. 옵션 .keep_all=TRUE를 추가하면, 변수 x1도 유지되는데, 중복된 행 중에 처음 나타난 행이 선택됨을 알 수 있다. df1 |&gt; distinct(id, .keep_all = TRUE) ## # A tibble: 3 × 2 ## id x1 ## &lt;int&gt; &lt;int&gt; ## 1 1 1 ## 2 2 1 ## 3 3 1 변수 id가 중복된 행 중에 첫 번째 위치한 행이 아닌, 변수 x1이 가장 큰 값을 갖는 행을 선택해 보자. 이 문제는 변수 id가 중복된 행들을 변수 x1의 내림차순으로 정렬한 데이터 프레임을 대상으로 중복된 행을 제거하면 된다. df1 |&gt; arrange(id, desc(x1)) |&gt; distinct(id, .keep_all = TRUE) ## # A tibble: 3 × 2 ## id x1 ## &lt;int&gt; &lt;int&gt; ## 1 1 2 ## 2 2 3 ## 3 3 4 함수 distinct()로 모든 변수의 값이 중복된 행을 제거하는 예제를 살펴보자. df2 &lt;- tibble(id = rep(1:3, each = 2), x1 = c(2, 2, 3, 1, 4, 4)) df2 ## # A tibble: 6 × 2 ## id x1 ## &lt;int&gt; &lt;dbl&gt; ## 1 1 2 ## 2 1 2 ## 3 2 3 ## 4 2 1 ## 5 3 4 ## 6 3 4 df2 |&gt; distinct() ## # A tibble: 4 × 2 ## id x1 ## &lt;int&gt; &lt;dbl&gt; ## 1 1 2 ## 2 2 3 ## 3 2 1 ## 4 3 4 4.2 열을 작업 대상으로 하는 함수 4.2.1 열의 선택: select() 데이터 세트의 크기가 커짐에 따라 변수의 개수가 수백 또는 수천이 되는 경우를 접하는 것이 더 이상 드문 상황은 아니다. 이러한 경우, 분석에 필요한 변수를 선택하여 데이터 세트의 크기를 줄이는 것은 매우 중요한 작업이 된다. 함수 select()에서는 패키지 tidyselect에 의해 구현되는 효과적인 변수 선택 방법을 이용할 수 있다. 여기에서 작동되는 &lt;tidy-select&gt; 방식은 기본적으로 변수들의 집합을 구성하는 것으로 생각하면 된다. 구체적인 선택 방법은 열 번호 또는 열 이름에 의한 방법과 변수의 유형에 의한 방법, 그리고 변 수 선택과 관련된 몇몇 함수들을 이용하는 방법으로 구분할 수 있다. 열 번호(또는 열 이름)에 의한 선택 가장 기본적인 방법은 열 번호를 콤마로 구분하여 나열하는 것이다. 연속된 열 변호는 콜론(:) 연산자를 이용해서 나타낼 수 있다. 데이터 프레임 mtcars의 행 이름을 변수 row.name으로 추가하고 tibble로 전환해 보자. mtcars_t &lt;- mtcars |&gt; rownames_to_column(var = &quot;row.name&quot;) |&gt; as_tibble() |&gt; print(n = 3) ## # A tibble: 32 × 12 ## row.name mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 선택해 보자. 이 경우에는 열 번호를 함수 c() 없이 그냥 나열해도 결과는 동일하다. mtcars_t |&gt; select(1:3, 7) |&gt; print(n = 3) ## # A tibble: 32 × 4 ## row.name mpg cyl wt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 2.62 ## 2 Mazda RX4 Wag 21 6 2.88 ## 3 Datsun 710 22.8 4 2.32 ## # ℹ 29 more rows 열(변수) 이름은 열 번호와 같은 취급을 받는다. 따라서 다음 방법도 같은 결과를 생성한다. mtcars_t %&gt;% select(row.name:cyl, wt) %&gt;% print(n = 3) ## # A tibble: 32 × 4 ## row.name mpg cyl wt ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 2.62 ## 2 Mazda RX4 Wag 21 6 2.88 ## 3 Datsun 710 22.8 4 2.32 ## # ℹ 29 more rows 열을 제거하고자 하는 경우에는 논리 부정 연산자(!) 또는 마이너스(-) 연산자를 사용해야 한다. 함수 c() 안에 제거하고자 하는 열 번호를 나열하고 논리 부정 연산자를 그 앞에 붙이면 나열된 열로 이루어진 집합의 여집합이 구성되어, 해당되는 열들이 제거되는 것이다. 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 제거해 보자. mtcars_t |&gt; select(!c(1:3, 7)) |&gt; print(n = 3) ## # A tibble: 32 × 8 ## disp hp drat qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 160 110 3.9 16.5 0 1 4 4 ## 2 160 110 3.9 17.0 0 1 4 4 ## 3 108 93 3.85 18.6 1 1 4 1 ## # ℹ 29 more rows 마이너스 연산자는 차집합을 구성하게 된다. 예컨대 select(1:4, -1)은 처음 네 변수 중 첫 번째 변수를 제거하라는 의미가 된다. 그러나 만일 select(1:4, !1)과 같이 논리 부정 연산자를 사용하면 처음 네 변수와 첫 번째 변수를 제외한 나머지 변수와의 합집합을 구성하는 것이 되어서 결국 모든 변수를 다 선택하게 된다. 비록 두 연산자의 의미는 다르지만, 마이너스 연산자가 첫 번째로 입력되면 같은 효과를 볼 수 있다. 따라서 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수의 제거는 다음과 같이 할 수도 있다. mtcars_t |&gt; select(-c(1:3, 7)) |&gt; print(n = 3) ## # A tibble: 32 × 8 ## disp hp drat qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 160 110 3.9 16.5 0 1 4 4 ## 2 160 110 3.9 17.0 0 1 4 4 ## 3 108 93 3.85 18.6 1 1 4 1 ## # ℹ 29 more rows 변수 유형에 의한 선택 변수의 유형과 같은 특정 조건을 만족하는 변수 선택에 유용하게 사용되는 방법이다. 사용 방법은 함수 where()에 실행 결과가 TRUE 또는 FALSE 중 하나가 되는 일명 predicate 함수를 입력해서 그 결과가 TRUE가 되는 변수를 선택하는 것이다. 함수 where()에 입력되는 함수 형태는 두 가지로 구분된다. 첫 번째는 함수의 이름만 입력하는 형태이다. 예를 들어, 변수의 유형 파악은 함수 is.numeric() 또는 is.character() 등 is.*() 형태의 함수로 할 수 있는데, 숫자형 변수를 선택한다면 where(is.numeric), 문자형 변수를 선택한다면 where(is.character)와 같이 입력하는 것이다. 두 번째는 패키지 purrr 방식의 형태로써, 여러 함수를 결합하거나, 함수의 디폴트 값을 변경해서 사용하는 경우에 적용되는 방식이다. 기본적인 형태는 물결표(~)로 시작을 하며 .x를 개별 변수 대신 사용하면 된다. 예를 들어 평균값이 5 이하인 변수를 선택한다면, where(~ mean(.x) &lt;= 5)와 같이 입력하면 된다. 패키지 purrr은 core tidyverse에 속한 패키지로서 효율적인 프로그래밍 기법을 제공하고 있다. 자세한 소개는 7장에서 찾아볼 수 있다. 패키지 ggplot2의 데이터 프레임 mpg를 살펴보자. mpg |&gt; print(n = 3) ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # ℹ 231 more rows 데이터 프레임 mpg에서 숫자형 변수만 선택해 보자. mpg |&gt; select(where(is.numeric)) |&gt; print(n = 3) ## # A tibble: 234 × 5 ## displ year cyl cty hwy ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1.8 1999 4 18 29 ## 2 1.8 1999 4 21 29 ## 3 2 2008 4 20 31 ## # ℹ 231 more rows 몇 가지 변수 유형을 함께 고려해야 하는 경우에는 논리 연산자 &amp;와 |을 사용하게 된다. 예를 들어 숫자형 변수이거나 문자형 변수의 선택은 다음과 같다. mpg %&gt;% select(where(is.numeric) | where(is.character)) %&gt;% print(n = 3) ## # A tibble: 234 × 11 ## displ year cyl cty hwy manufacturer model trans drv fl class ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1.8 1999 4 18 29 audi a4 auto(l5) f p compa… ## 2 1.8 1999 4 21 29 audi a4 manual(m5) f p compa… ## 3 2 2008 4 20 31 audi a4 manual(m6) f p compa… ## # ℹ 231 more rows 이번에는 숫자형 변수 중에 평균 값이 5 이하인 변수를 선택해 보자. 먼저 함수 select()를 연속해서 사용하는 방법이다. mpg %&gt;% select(where(is.numeric)) |&gt; select(where(~ mean(.x) &lt;= 5)) |&gt; print(n = 3) ## # A tibble: 234 × 1 ## displ ## &lt;dbl&gt; ## 1 1.8 ## 2 1.8 ## 3 2 ## # ℹ 231 more rows 조금 다른 방법은 &amp;&amp; 연산자를 사용하는 방법이다. mpg |&gt; select(where( ~ is.numeric(.x) &amp;&amp; mean(.x) &lt;= 5)) |&gt; print(n = 3) ## # A tibble: 234 × 1 ## displ ## &lt;dbl&gt; ## 1 1.8 ## 2 1.8 ## 3 2 ## # ℹ 231 more rows &amp;&amp; 연산자는 &amp;와 같이 AND 논리 연산자이지만, 수행 방식에는 차이가 있다. &amp; 논리 연산자는 벡터의 구성 요소별 비교 연산을 수행하지만, &amp;&amp; 논리 연산자는 비교 대상 요소의 길이가 1이 되어야 하며, 왼쪽부터 차례로 비교 연산을 수행한다. 따라서 위 연산은 숫자형 변수 여부의 확인(is.numeric(.x)) 결과가 TRUE이고, 이어서 평균이 5 이하 여부의 확인(mean(.x) &lt;= 5) 결과가 TRUE가 되는 변수만 선택하는 것이다. 길이가 1을 초과하는 경우에 &amp;&amp; 연산자는 오류가 발생한다. (c(1, -1) &gt; 0) &amp;&amp; (-2 &lt; 0) ## Error in (c(1, -1) &gt; 0) &amp;&amp; (-2 &lt; 0): &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; &amp; 연산자의 경우에는 비교되는 벡터의 길이가 다르면, 순환법칙이 적용되서 길이를 동일하게 만들고 각 구성요소에 대한 비교를 실시한다. (c(1, -1) &gt; 0) &amp; (-2 &lt; 0) ## [1] TRUE FALSE 변수 선택과 관련된 함수의 이용 변수 선택에 매우 유용하게 사용되는 함수들이 있다. 먼저 특정 위치의 열을 선택할 때 사용할 수 있는 함수들이다. everything() : 모든 변수 선택 last_col() : 마지막 변수 선택 변수 이름을 구성하고 있는 문자열에 대한 매칭 작업으로 변수를 선택할 때 사용할 수 있는 함수들이다. starts_with(\"x\"): 이름이 x로 시작하는 변수 선택 ends_with(\"x\"): 이름이 x로 끝나는 변수 선택 contains(\"x\"): 이름에 x가 있는 변수 선택 num_range(\"x\", 1:10): x1, x2, … , x10과 동일 변수 이름이 입력된 문자형 벡터를 이용하여 변수를 선택할 때 사용할 수 있는 함수들 이다. all_of(vec): 문자형 벡터 vec에 이름이 입력된 변수 선택. 해당 데이터 프레임에 없는 변수 이름이 vec에 입력되어 있으면 오류 발생. any_of(vec): 함수 all_of()와 동일함. 단, 데이터 프레임에 없는 변수 이름이 입력 되어도 오류가 발생하지 않음. 예제로 데이터 프레임 mtcars_t에서 첫 번째 변수와 마지막 변수를 선택해 보자. mtcars_t %&gt;% select(1, last_col()) %&gt;% print(n = 3) ## # A tibble: 32 × 2 ## row.name carb ## &lt;chr&gt; &lt;dbl&gt; ## 1 Mazda RX4 4 ## 2 Mazda RX4 Wag 4 ## 3 Datsun 710 1 ## # ℹ 29 more rows 이번에는 mtcars_t에서 이름이 m으로 시작하는 변수를 선택해 보자. mtcars_t %&gt;% select(starts_with(&quot;m&quot;)) %&gt;% print(n = 3) ## # A tibble: 32 × 1 ## mpg ## &lt;dbl&gt; ## 1 21 ## 2 21 ## 3 22.8 ## # ℹ 29 more rows 이름이 p로 끝나는 변수도 선택해 보자. mtcars_t %&gt;% select(ends_with(&quot;p&quot;)) %&gt;% print(n = 3) ## # A tibble: 32 × 2 ## disp hp ## &lt;dbl&gt; &lt;dbl&gt; ## 1 160 110 ## 2 160 110 ## 3 108 93 ## # ℹ 29 more rows 이름에 A가 있는 변수를 선택해 보자. mtcars_t %&gt;% select(contains(&quot;A&quot;)) %&gt;% print(n = 3) ## # A tibble: 32 × 5 ## row.name drat am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 3.9 1 4 4 ## 2 Mazda RX4 Wag 3.9 1 4 4 ## 3 Datsun 710 3.85 1 4 1 ## # ℹ 29 more rows 대문자 A가 이름에 있는 변수 선택을 요구했지만, 결과는 모두 소문자 a가 이름에 있는 변수가 선택되었다. 이런 결과가 나온 이유는 옵션 ignore.case = TRUE가 디폴트로 설정되어서 대문자와 소문자를 구분하지 않기 때문이다. 이 옵션은 함수 starts_with()와 ends_with()에도 동일하게 TRUE가 디폴트이다. 만일 대문자를 구분해서 문자열 매칭 작업을 하면 다음과 같이 해당되는 변수가 없다는 결과가 나온다. mtcars_t %&gt;% select(contains(&quot;A&quot;, ignore.case = FALSE)) ## # A tibble: 32 × 0 문자형 벡터 vars에 다음과 같이 변수 이름을 입력해 보자. 앞에서 생성된 데이터 프레임 mtcars_t에는 변수 mpg와 wt는 있지만, 변수 model은 없는 상태이다. vars &lt;- c(&quot;model&quot;, &quot;mpg&quot;, &quot;wt&quot;) 함수 any_of()를 사용하면 mtcars_t에 있는 두 변수가 선택된다. mtcars_t |&gt; select(any_of(vars)) |&gt; print(n = 3) ## # A tibble: 32 × 2 ## mpg wt ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 2.62 ## 2 21 2.88 ## 3 22.8 2.32 ## # ℹ 29 more rows 함수 all_of()를 사용하게 되면 model이 mtcars_t에 없는 변수이기 때문에 오류가 발생하게 된다. mtcars_t |&gt; select(all_of(vars)) ## Error in `all_of()`: ## ! Can&#39;t subset columns that don&#39;t exist. ## ✖ Column `model` doesn&#39;t exist. 당연한 것이지만, 지금까지 살펴본 세 가지 변수 선택 방법은 서로 혼합해서 사용할 수 있다. 예를 들어 숫자형 변수 중에 이름에 a가 있는 변수는 다음과 같이 선택할 수 있다. mtcars_t %&gt;% select(where(is.numeric) &amp; contains(&quot;c&quot;)) %&gt;% print(n = 3) ## # A tibble: 32 × 3 ## cyl qsec carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6 16.5 4 ## 2 6 17.0 4 ## 3 4 18.6 1 ## # ℹ 29 more rows 벡터 형태로 변수 선택: 함수 pull() 데이터 프레임의 한 변수를 선택하여 벡터로 추출하고자 한다면 함수 pull()을 사용하면 된다. 변수 선택 방법은 옵션 var에 변수 이름을 지정하거나, 위치를 나타내는 정수를 지정하는 것이다. 양의 정수는 첫 번째 변수를 시작점으로 하는 위치이고, 음의 정수는 마지막 변수 를 시작점으로 하는 위치이다. 디폴트는 var = -1로 설정되어 있어서, 마지막 변수가 선택된다. 데이터 프레임 mtcars를 대상으로 마지막 변수와 세 번째 변수, 그리고 변수 am을 벡터 형태로 선택해 보자. mtcars_t |&gt; pull() ## [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 mtcars_t |&gt; pull(var = 3) ## [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 mtcars_t |&gt; pull(var = am) ## [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 4.2.2 열 이름 변경: rename()과 rename_with() 변수 이름이 매우 복잡하거나 사용하기 불편해서 이름을 변경해야 하는 경우가 많다. 함수 select()로도 변수 이름을 변경할 수 있으나, 함수 내에서 이름이 명시되지 않은 변수는 선택되지 않은 변수가 되어 제거되고, 이름이 변경된 변수만 남게 된다. 변수에 새로운 이름을 주는 방식은 new_name = old_name이 되는데, old_name 자리에는 변수 이름 또는 변수의 열 번호가 올 수 있다. mtcars_t |&gt; select(model = row.name) |&gt; print(n = 3) ## # A tibble: 32 × 1 ## model ## &lt;chr&gt; ## 1 Mazda RX4 ## 2 Mazda RX4 Wag ## 3 Datsun 710 ## # ℹ 29 more rows mtcars_t |&gt; select(model = 1) |&gt; print(n = 3) ## # A tibble: 32 × 1 ## model ## &lt;chr&gt; ## 1 Mazda RX4 ## 2 Mazda RX4 Wag ## 3 Datsun 710 ## # ℹ 29 more rows 함수 select()에서 이름이 변경되지 않은 변수도 모두 그대로 유지하려면 함수 everything()을 함께 사용하면 된다. mtcars_t |&gt; select(model = 1, everything()) |&gt; print(n = 3) ## # A tibble: 32 × 12 ## model mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 함수 rename()을 사용하면 이름이 변경되지 않은 변수도 모두 그대로 유지가 된다. 변수에 새로운 이름을 주는 방식은 함수 select()와 동일하게 new_name = old_name이다. mtcars_t %&gt;% rename(model = row.name) %&gt;% print(n = 3) ## # A tibble: 32 × 12 ## model mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 많은 변수의 이름을 어떤 공통된 양식에 따라 모두 바꿔야 하는 경우, 하나씩 new_name = old_name으로 변경하는 방식은 매우 비효율적이 될 수 있다. 예컨대 대문자로 입력된 변수 이름을 모두 소문자로 변경하거나, 이름 중간에 들어간 점(.)을 밑줄(_)로 변경해야 하는 경우에 하나씩 변경하는 방식이 아닌 해당되는 변수의 이름을 한꺼번에 모두 바꿀 수 있는 방식이 필요한 것이다. 이러한 작업은 함수 rename_with()로 할 수 있다. 데이터 프레임 mtcars_t의 모든 변수 이름을 대문자로 변경해 보자. 함수 rename_with()에는 기존의 변수 이름을 새로운 이름으로 바꿀 수 있는 함수를 지정해야 한다. 모든 변수를 대문자로 변경하는 작업이므로 함수 toupper()를 사용하면 되는데, 하나의 함수만을 사용하는 경우에는 함수 이름을 입력하면 된다. mtcars_t |&gt; rename_with(toupper) |&gt; print(n = 3) ## # A tibble: 32 × 12 ## ROW.NAME MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 모든 변수가 이름 변경 대상이 되는 것이 디폴트이다. 변경 대상 변수를 선택을 해야 하는 경우에는 함수 select()에서 사용했던 &lt;tidy-select&gt;의 방식으로 선택하여 함수 rename_with()의 세 번째 입력요소로 지정하면 된다. 이름에 a가 포함되어 있는 변수의 이름을 대문자로 바꾸어 보자. mtcars_t |&gt; rename_with(toupper, contains(&quot;a&quot;)) |&gt; print(n = 3) ## # A tibble: 32 × 12 ## ROW.NAME mpg cyl disp hp DRAT wt qsec vs AM GEAR CARB ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 데이터 프레임 iris의 변수 이름에는 점(.)이 포함되어 있고, 대문자도 있다. 먼저 변수 이름에 있는 점을 밑줄로 바꿔보자. 특정 문자의 치환은 함수 gsub()로 할 수 있는데, 메타 문자인 점(.)을 치환해야 하기 때문에 옵션 fixed = TRUE를 포함해야 한다. 따라서 함수 rename_with()에 입력되는 이름 변경을 위한 함수는 purrr 형태를 취하게 된다. iris |&gt; as_tibble() |&gt; rename_with(~ gsub(&quot;.&quot;, &quot;_&quot;, .x, fixed = TRUE)) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## Sepal_Length Sepal_Width Petal_Length Petal_Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## # ℹ 147 more rows 이번에는 점을 밑줄로 바꾸고, 이름에는 있는 대문자를 모두 소문자로 바꾸어 보자. iris |&gt; as_tibble() |&gt; rename_with(~ tolower(gsub(&quot;.&quot;, &quot;_&quot;, .x, fixed = TRUE))) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## sepal_length sepal_width petal_length petal_width species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## # ℹ 147 more rows 4.2.3 열의 위치 변경: relocate() 열의 위치를 변경해야 하는 경우에 사용할 수 있는 함수이다. 위치를 바꿀 열은 &lt;tidy-select&gt; 방식을 사용하여 선택할 수 있어서, 여러 열의 위치를 한꺼번에 옮길 수 있다. 제일 앞으로 이동되는 것이 디폴트 위치이며 옵션 .after 혹은 .before에서 위치를 지정할 수 있다. 데이터 프레임 iris의 마지막 변수 Species를 첫 번째 위치로 이동해 보자. iris_t &lt;- as_tibble(iris) iris_t |&gt; relocate(Species) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 1.4 0.2 ## 2 setosa 4.9 3 1.4 0.2 ## 3 setosa 4.7 3.2 1.3 0.2 ## # ℹ 147 more rows 다른 방법으로 이름이 th로 끝나는 변수를 모두 Species 다음으로 이동하면 변수 Species를 첫 번째 위치로 이동하는 것이 된다. iris_t |&gt; relocate(ends_with(&quot;th&quot;), .after = Species) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 1.4 0.2 ## 2 setosa 4.9 3 1.4 0.2 ## 3 setosa 4.7 3.2 1.3 0.2 ## # ℹ 147 more rows 또 다른 방법으로 이름이 th로 끝나는 변수를 마지막 변수 다음으로 이동하면 변수 Species를 첫 번째 위치로 이동하는 것이 된다. iris_t |&gt; relocate(ends_with(&quot;th&quot;), .after = last_col()) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 1.4 0.2 ## 2 setosa 4.9 3 1.4 0.2 ## 3 setosa 4.7 3.2 1.3 0.2 ## # ℹ 147 more rows 특정 변수를 제일 앞으로 이동하는 작업은 함수 select()에 everything()을 함께 사용해서 할 수도 있다. iris_t |&gt; select(Species, everything()) |&gt; print(n = 3) ## # A tibble: 150 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.1 3.5 1.4 0.2 ## 2 setosa 4.9 3 1.4 0.2 ## 3 setosa 4.7 3.2 1.3 0.2 ## # ℹ 147 more rows 4.2.4 새로운 열의 추가: mutate()와 transmute() 데이터 프레임을 구성하고 있는 기존의 변수들을 이용하여 새로운 변수를 만들어 데이터 프레임에 추가해야 할 경우가 종종 있다. 이러한 작업을 수행하는 함수가 mutate()이다. 데이터 프레임이 함수 mutate()의 첫 번째 입력 요소가 되고, 이어서 새로운 변수를 만드는 표현식이 차례로 입력된다. 새롭게 만들어진 변수는 데이터 프레임의 제일 마지막 변수로 추가되는 것이 디폴트이다. 만일 추가된 변수의 위치를 변경하고자 한다면, 옵션 .after 또는 .before에서 지정하면 된다. 만일 새롭게 만들어진 변수로만 데이터 프레임을 구성하고자 한다면 함수 transmute()를 사용하면 된다. 함수 mutate()와 transmute()에서 새로운 변수를 만들 때 유용하게 사용되는 함수들의 목록이 RStudio의 메뉴 Help &gt; Cheatsheets &gt; Data Transformation with dplyr에 잘 정리되어 있다. 예제: mtcars 다음의 조건에 의하여 새로운 변수 kml과 gp_kml을 만들고 데이터 프레임에 첫 번째와 두번째 변수로 추가해 보자. ∙ 변수 kml: 1 mpg(mile per gallon)는 0.43 kml(kilometer per liter) ∙ 변수 gp_kml: kml이 10 이상이면 \"good\", 10 미만이면 \"bad\" 연속형 변수 kml을 기반으로 범주의 개수가 두 개인 범주형 변수 gp_kml를 생성하는 작업은 함수 if_else()를 사용하는 것이 효과적이다. 기본적인 사용법은 if_else(condition, true, false)이며 condition이 만족되면 true의 값을 갖고, 아니면 false의 값을 갖게 된다. 조건의 만족 여부에 따라 할당되는 두 가지 값의 유형은 같아야 한다. as_tibble(mtcars) |&gt; mutate(kml = 0.43*mpg, gp_kml = if_else(kml &gt;= 10, &quot;good&quot;, &quot;bad&quot;), .before = 1) |&gt; print(n=3) ## # A tibble: 32 × 13 ## kml gp_kml mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9.03 bad 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 9.03 bad 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 9.80 bad 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 만일 새롭게 생성된 변수만 유지하고 나머지 변수는 모두 삭제하려고 한다면, 함수 transmute()를 사용하면 된다. as_tibble(mtcars) |&gt; transmute(kml = 0.43*mpg, gp_kml = if_else(kml &gt;= 10, &quot;good&quot;, &quot;bad&quot;) ) |&gt; print(n=3) ## # A tibble: 32 × 2 ## kml gp_kml ## &lt;dbl&gt; &lt;chr&gt; ## 1 9.03 bad ## 2 9.03 bad ## 3 9.80 bad ## # ℹ 29 more rows 연속형 변수를 기반으로 범주의 개수가 3개 이상이 되는 범주형 변수를 생성하려는 경우에 함수 if_else()를 사용하는 것은 적절하지 않을 수 있다. 이러한 경우에는 함수 case_when()이 효과적인 대안이 된다. 기본적인 형태는 LHS ~ RHS로서, LHS는 조건이고, RHS에는 할당하려는 값이 된다. 다음 구조에서는 condition_1이 TRUE이면 value_1, condition_1은 FALSE이나 condition_2가 TRUE이면 value_2, 두 조건 모두 FALSE이면 value_3를 출력하게 된다. case_when( condition_1 ~ value_1, condition_2 ~ value_2, TRUE ~ value_3 ) LHS에 제시되는 조건들은 순서대로 평가가 된다. 따라서 가장 좁은 범위의 조건이 가장 먼저 제시되어야 하고, 범위를 넓혀가는 조건이 잇따라 제시되어야 한다. 제시되는 조건의 개수에는 제한이 없다. 또한 RHS에 제시된 값들은 모두 같은 유형이어야 한다. 이제 다음의 변경된 조건으로 변수 gp_kml을 생성해 보자. ∙ 변수 gp_kml: kml이 11 이상이면 \"excellent\", 11 미만 8 이상이면 \"good\", 8 미만이면 \"bad\" as_tibble(mtcars) |&gt; mutate(kml = 0.43*mpg, gp_kml = case_when( kml &lt; 8 ~ &quot;bad&quot;, kml &lt; 11 ~ &quot;good&quot;, TRUE ~ &quot;excellent&quot; ), .before = 1) |&gt; print(n=3) ## # A tibble: 32 × 13 ## kml gp_kml mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9.03 good 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 9.03 good 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 9.80 good 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows LHS에 “excellent”에 대한 조건을 먼저 제시하려면 다음과 같이 진행하면 된다. as_tibble(mtcars) |&gt; mutate(kml = 0.43*mpg, gp_kml = case_when( kml &gt;= 11 ~ &quot;excellent&quot;, kml &gt;= 8 ~ &quot;good&quot;, TRUE ~ &quot;bad&quot; ), .before = 1) |&gt; print(n=3) ## # A tibble: 32 × 13 ## kml gp_kml mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9.03 good 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 9.03 good 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 9.80 good 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## # ℹ 29 more rows 4.3 여러 행 자료의 요약: summarise() 변수들의 요약통계량을 계산할 때 유용하게 사용되는 함수가 summarise()이다. 첫 번째 입력 요소는 데이터 프레임이고, 이어서 name = fun의 형태로 원하는 요약통계량 값을 계산할 함수와 열의 이름을 입력한다. 예를 들어 데이터 프레임 mpg의 변수 hwy의 전체 케이스와 서로 다른 값을 갖고 있는 케이스의 개수, 그리고 평균값을 계산해 보자. 전체 케이스는 함수 n()으로, 서로 다른 값을 갖는 케이스의 개수는 n_distinct()로 계산한다. mpg |&gt; summarise(n = n(), n_hwy = n_distinct(hwy), avg_hwy = mean(hwy)) ## # A tibble: 1 × 3 ## n n_hwy avg_hwy ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 234 27 23.4 dplyr 1.0.0 버전부터 길이가 2 이상이 되는 벡터를 결과로 출력하는 함수도 사용할 수 있게 됐다. 이 경우, 길이가 1인 요약통계량의 값이 함께 있다면 반복이 되어서 길이를 맞춘다. mpg |&gt; summarise(avg_hwy = mean(hwy), rng_hwy = range(hwy)) ## Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in ## dplyr 1.1.0. ## ℹ Please use `reframe()` instead. ## ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()` ## always returns an ungrouped data frame and adjust accordingly. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## # A tibble: 2 × 2 ## avg_hwy rng_hwy ## &lt;dbl&gt; &lt;int&gt; ## 1 23.4 12 ## 2 23.4 44 길이가 서로 다른 벡터로는 데이터 프레임을 구성할 수 없다. 다만 예외적으로 길이가 1인 벡터에게만 반복을 허용하는 것이다. 따라서 평균값과 범위(최소, 최대), 그리고 사분위수(0.25분위수, 0.5분위수, 0.75분위수)를 함께 나타내려는 다음 시도는 잘못된 것이다. mpg |&gt; summarise(avg_hwy = mean(hwy), rng_hwy = range(hwy), q_hwy = quantile(hwy, probs = c(0.25,0.5,0.75))) ## Error in `summarise()`: ## ! Can&#39;t recycle `q_hwy = quantile(hwy, probs = c(0.25, 0.5, 0.75))`. ## Caused by error: ## ! `q_hwy` must be size 2 or 1, not 3. ## ℹ An earlier column had size 2. 함수 summarise()는 사실 그 자체만으로는 그렇게 특별히 유용한 함수라고 하기 어렵다. 그러나 전체 데이터를 몇 개의 그룹으로 구분하는 함수 group_by()와 함께 사용하면 매우 강력한 분석 도구가 된다. 4.4 그룹 데이터 프레임 dplyr 기본 함수들은 그룹으로 구분된 데이터 프레임을 대상으로 작업할 때 더욱 강력한 위력을 발휘할 수 있다. 이 절에서는 함수 group_by()를 사용하여 그룹 데이터 프레임을 생성하는 방법과 dplyr 기본 함수들이 그룹 데이터 프레임에서는 어떤 방식으로 작동되는지에 대해 살펴보도록 하자. 4.4.1 그룹 데이터 프레임의 생성: group_by() 함수 group_by()는 한 개 이상의 변수를 이용하여 전체 데이터를 그룹으로 구분하는 기능을 갖고 있다. 첫 번째 입력요소는 데이터 프레임이고, 이어서 그룹을 구분하는 데 사용될 변수를 나열하면 된다. 실행결과는 tibble이며, 실행 전의 tibble과 출력된 형태에서는 큰 차이를 볼 수 없으나 grouped_df라는 class 속성이 추가된 tibble이 된다. by_cyl &lt;- mpg |&gt; group_by(cyl) |&gt; print(n = 3) ## # A tibble: 234 × 11 ## # Groups: cyl [4] ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # ℹ 231 more rows by_cyl_drv &lt;- mpg %&gt;% group_by(cyl, drv) %&gt;% print(n = 3) ## # A tibble: 234 × 11 ## # Groups: cyl, drv [9] ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # ℹ 231 more rows 그룹 데이터 프레임 by_cyl를 출력해 보면 Groups: cyl [4]라는 결과가 나타나는데, 이것은 변수 cyl에 의해 4개 그룹이 구성되었다는 것을 의미한다. 또한 by_cyl_drv의 경우에는 cyl과 drv의 조합으로 9개 그룹이 생성되었다는 것을 알 수 있다. 그룹별 자료 개수 확인 각 그룹에 속한 자료의 개수는 함수 tally() 또는 count()를 사용하면 알 수 있다. 함수 tally()는 그룹 변수 지정 기능이 없어서 그룹 데이터 프레임을 입력하면 각 그룹별 자료의 개수를 출력하지만, 일반 데이터 프레임을 입력하면 전체 자료 개수를 출력한다. by_cyl %&gt;% tally() ## # A tibble: 4 × 2 ## cyl n ## &lt;int&gt; &lt;int&gt; ## 1 4 81 ## 2 5 4 ## 3 6 79 ## 4 8 70 mpg %&gt;% tally() ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 234 반면에 함수 count()는 그룹 변수를 지정해서, 각 그룹별 자료의 개수를 계산할 수 있다. by_cyl %&gt;% count() ## # A tibble: 4 × 2 ## # Groups: cyl [4] ## cyl n ## &lt;int&gt; &lt;int&gt; ## 1 4 81 ## 2 5 4 ## 3 6 79 ## 4 8 70 mpg %&gt;% count(cyl) ## # A tibble: 4 × 2 ## cyl n ## &lt;int&gt; &lt;int&gt; ## 1 4 81 ## 2 5 4 ## 3 6 79 ## 4 8 70 그룹 변수의 변경 기존의 그룹 데이터 프레임에 그룹을 구성하는 변수를 추가해서 더 세분화된 그룹을 구성할 수 있다. 변수 cyl로 구성된 그룹 데이터 프레임에 drv로 생성되는 그룹을 추가하기 위해서는 옵션 .add=TRUE를 지정해야 한다. by_cyl %&gt;% group_by(drv, .add = TRUE) %&gt;% tally() ## # A tibble: 9 × 3 ## # Groups: cyl [4] ## cyl drv n ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 4 4 23 ## 2 4 f 58 ## 3 5 f 4 ## 4 6 4 32 ## 5 6 f 43 ## 6 6 r 4 ## 7 8 4 48 ## 8 8 f 1 ## 9 8 r 21 옵션 .add=TRUE를 추가하지 않으면 기존의 그룹 변수가 새로운 그룹 변수로 대체된다. by_cyl %&gt;% group_by(drv) %&gt;% tally() ## # A tibble: 3 × 2 ## drv n ## &lt;chr&gt; &lt;int&gt; ## 1 4 103 ## 2 f 106 ## 3 r 25 함수 group_by()로 구성된 그룹은 함수 ungroup()으로 해체할 수 있다. by_cyl %&gt;% ungroup() %&gt;% tally() ## # A tibble: 1 × 1 ## n ## &lt;int&gt; ## 1 234 4.4.2 그룹 데이터 프레임에서 기본 함수들의 작동 방식 지금부터는 그룹 데이터 프레임에서 dplyr 기본 함수들의 작동 방식을 예제를 통해서 살펴보자. 함수 summarise() 그룹 데이터 프레임에 대해서는 각 그룹별 요약 통계량을 계산한다. 예제로 데이터 프레임 airquality를 대상으로 다음의 문제를 해결해 보자. 변수 Ozone의 월별 평균값 월별로 변수 Ozone의 결측값이 있는 날수와 실제 관측된 날수 월별로 첫날과 마지막 날의 변수 Ozone의 값 월별로 변수 Ozone의 가장 작은 값과 가장 큰 값 월별로 변수 Ozone의 개별 값이 전체 기간 동안의 평균값보다 작은 날수 다섯 문제 모두 월별로 구분된 데이터 프레임이 필요하기 때문에 변수 Month로 그룹을 구성한 데이터 프레임을 만들어야 한다. airs_M &lt;- airquality |&gt; group_by(Month) 변수 Ozone에는 많은 수의 결측값이 있다. 따라서 함수 mean()에는 반드시 옵션 na.rm = TRUE를 함께 입력해야 결측값을 제외한 평균값이 계산된다. # 1 airs_M |&gt; summarise(avg_OZ = mean(Ozone, na.rm = TRUE)) ## # A tibble: 5 × 2 ## Month avg_OZ ## &lt;int&gt; &lt;dbl&gt; ## 1 5 23.6 ## 2 6 29.4 ## 3 7 59.1 ## 4 8 60.0 ## 5 9 31.4 결측값이 있는 날수는 함수 is.na()로 생성된 논리형 벡터를 함수 sum()에 입력하여 TRUE의 개수를 세면 알 수 있다. 또한 실제 관측이 있던 날수는 결측값이 아닌 날수이므로 함수 is.na()의 결과를 반대로 바꿔주고 함수 sum()에 입력하면 된다. # 2 airs_M |&gt; summarise(n_miss = sum(is.na(Ozone)), n_obs = sum(!is.na(Ozone))) ## # A tibble: 5 × 3 ## Month n_miss n_obs ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 5 5 26 ## 2 6 21 9 ## 3 7 5 26 ## 4 8 5 26 ## 5 9 1 29 월별 첫날과 마지막날의 변수 Ozone 값을 출력하기 위해서는 함수 first()와 last()를 이용해야 한다. 벡터 x에 대해서 first(x)와 last(x)는 각각 x[1]과 x[length(x)]의 결과가 출력된다. 유사한 기능을 가진 함수로 nth()가 있다. 벡터 x에 대해서 nth(x, 2)는 x[2]의 결과가 출력되며, nth(x, -2)는 끝에서 두 번째 자료인 x[length(x)-1]이 출력된다. # 3 airs_M |&gt; summarise(first_Oz = first(Ozone), last_Oz = last(Ozone)) ## # A tibble: 5 × 3 ## Month first_Oz last_Oz ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 5 41 37 ## 2 6 NA NA ## 3 7 135 59 ## 4 8 39 85 ## 5 9 96 20 함수 max()와 min()도 옵션 na.rm = TRUE을 입력해야 결측값을 제외하고 가장 큰 값과 가장 작은 값을 구한다. # 4 airs_M |&gt; summarise(max_Oz = max(Ozone, na.rm = TRUE), min_Oz = min(Ozone, na.rm = TRUE)) ## # A tibble: 5 × 3 ## Month max_Oz min_Oz ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 5 115 1 ## 2 6 71 12 ## 3 7 135 7 ## 4 8 168 9 ## 5 9 96 7 월별로 변수 Ozone의 개별 값이 전체 기간 동안의 평균값보다 작은 날수를 세어보자. 전체 기간 동안의 평균값은 따로 계산해서 사용하는 것이 더 편리하다. # 5 m_Oz &lt;- mean(airquality$Ozone, na.rm = TRUE) airs_M |&gt; summarise(low_Oz = sum(Ozone &lt; m_Oz, na.rm = TRUE)) ## # A tibble: 5 × 2 ## Month low_Oz ## &lt;int&gt; &lt;int&gt; ## 1 5 24 ## 2 6 8 ## 3 7 8 ## 4 8 10 ## 5 9 22 함수 select() 그룹을 구성하고 있는 변수는 선택 대상이 아니어도 항상 포함된다. mpg |&gt; group_by(cyl) |&gt; select(hwy) |&gt; print(n=3) ## # A tibble: 234 × 2 ## # Groups: cyl [4] ## cyl hwy ## &lt;int&gt; &lt;int&gt; ## 1 4 29 ## 2 4 29 ## 3 4 31 ## # ℹ 231 more rows 함수 arrange() 옵션 .by_group=TRUE를 추가하면, 그룹 변수가 첫 번째 정렬 변수로 사용된다. 그룹 변수 cyl로 먼저 정렬을 하고 이어서 각 그룹 내에서 hwy에 의해 정렬을 해 보자. mpg |&gt; group_by(cyl) |&gt; arrange(hwy, .by_group = TRUE) |&gt; print(n=3) ## # A tibble: 234 × 11 ## # Groups: cyl [4] ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 toyota 4runner 4wd 2.7 1999 4 manu… 4 15 20 r suv ## 2 toyota 4runner 4wd 2.7 1999 4 auto… 4 16 20 r suv ## 3 toyota toyota tac… 2.7 1999 4 manu… 4 15 20 r pick… ## # ℹ 231 more rows 함수 mutate()와 transmute() 그룹 데이터 프레임에서 mean()과 같은 요약통계량 함수나 min_rank()와 같은 순위 계산 함수는 각 그룹별로 그 결과를 계산하기 때문에 이러한 함수를 사용해서 새로운 열을 생성하는 경우에는 그룹이 구성되지 않은 데이터 프레임의 경우와 다른 결과를 생성하게 된다. mpg |&gt; select(cyl, hwy) |&gt; mutate(std_hwy = hwy - mean(hwy), rank = min_rank(hwy)) |&gt; print(n=3) ## # A tibble: 234 × 4 ## cyl hwy std_hwy rank ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 4 29 5.56 187 ## 2 4 29 5.56 187 ## 3 4 31 7.56 213 ## # ℹ 231 more rows mpg |&gt; select(cyl, hwy) |&gt; group_by(cyl) |&gt; mutate(std_hwy = hwy - mean(hwy), rank = min_rank(hwy)) |&gt; print(n=3) ## # A tibble: 234 × 4 ## # Groups: cyl [4] ## cyl hwy std_hwy rank ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 4 29 0.198 38 ## 2 4 29 0.198 38 ## 3 4 31 2.20 60 ## # ℹ 231 more rows 함수 min_rank()는 입력된 벡터의 순위를 계산하는 함수로서 오름차순으로 순위가 계산되며, 크기가 같은 자료들에 대해서는 해당되는 순위 중 가장 작은 순위가 모두에게 부여된다. 함수 filter() 요약통계량 함수를 사용해서 조건을 설정한다면 각 그룹별로 다른 조건에 의한 행 선택이 이루어진다. 데이터 프레임 mpg에서 cyl의 그룹별로 hwy가 가장 큰 값을 갖는 행을 찾아보자. mpg |&gt; group_by(cyl) |&gt; select(1:2, hwy) |&gt; filter(hwy == max(hwy)) |&gt; arrange(hwy, .by_group = TRUE) ## # A tibble: 8 × 4 ## # Groups: cyl [4] ## cyl manufacturer model hwy ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 4 volkswagen jetta 44 ## 2 4 volkswagen new beetle 44 ## 3 5 volkswagen jetta 29 ## 4 5 volkswagen jetta 29 ## 5 5 volkswagen new beetle 29 ## 6 6 chevrolet malibu 29 ## 7 8 chevrolet corvette 26 ## 8 8 chevrolet corvette 26 함수 slice() 그룹별로 각각 행을 선택할 수 있게 된다. 데이터 프레임 airquality에서 변수 Ozone의 매달 첫날과 마지막날, 가장 큰 값과 가장 작은 값을 갖는 행을 다음과 같이 선택할 수 있다. airs_M &lt;- airquality %&gt;% group_by(Month) %&gt;% select(1, 5, 6) airs_M %&gt;% slice_head(n = 1) ## # A tibble: 5 × 3 ## # Groups: Month [5] ## Ozone Month Day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 41 5 1 ## 2 NA 6 1 ## 3 135 7 1 ## 4 39 8 1 ## 5 96 9 1 airs_M %&gt;% slice_tail(n = 1) ## # A tibble: 5 × 3 ## # Groups: Month [5] ## Ozone Month Day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 37 5 31 ## 2 NA 6 30 ## 3 59 7 31 ## 4 85 8 31 ## 5 20 9 30 airs_M %&gt;% slice_min(Ozone, n = 1) ## # A tibble: 6 × 3 ## # Groups: Month [5] ## Ozone Month Day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 5 21 ## 2 12 6 19 ## 3 7 7 15 ## 4 9 8 2 ## 5 9 8 22 ## 6 7 9 24 airs_M %&gt;% slice_max(Ozone, n = 1) ## # A tibble: 5 × 3 ## # Groups: Month [5] ## Ozone Month Day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 115 5 30 ## 2 71 6 9 ## 3 135 7 1 ## 4 168 8 25 ## 5 96 9 1 4.5 다수의 열을 대상으로 하는 작업: across() 함수 summarise() 등에서 여러 열을 대상으로 동일한 작업을 수행해야 하는 경우가 있다. 예를 들어 모든 숫자형 변수의 평균값을 계산해야 하는 경우, 숫자형 변수를 하나하나 mean()에 적용해서 평균값을 계산해야 한다면 무척 번거로운 일이 될 것이다. 이와 같이 여러 열을 대상으로 작업을 해야 하는 경우에는 함수 across()를 활용하는 것이 필수적이다. 함수 across()는 summarise()나 mutate()와 같은 dplyr 기본 함수 안에서 사용하는 것으로서 사용법은 across(.cols = everything(), .fns = NULL, ..., .names = NULL)이다. 첫 번째 입력 요소 .cols에는 &lt;tidy-select&gt; 방식으로 작업 대상이 되는 열을 지정한다. 아무것도 지정하지 않으면 모든 열이 선택되는 것이 디폴트이다. 두 번째 입력 요소 .fns에는 선택된 각각의 열에 적용되는 함수를 지정한다. 적용될 함수는 다음과 같이 3 가지 방법으로 지정할 수 있다. 하나의 함수: 예) mean purrr에서 적용되는 방식의 함수: 예) ~ mean(.x, na.rm = TRUE) 여러 함수의 리스트: 예) list(mean = mean, n_miss = ~ sum(is.na(.x))) 하나의 함수만을 다른 부가적인 입력 요소 없이 사용하는 경우에는 함수의 이름만 지정하면 된다. 패키지 purrr은 core tidyverse에 속한 패키지로서 효율적인 프로그래밍 기법을 제공하고 있다. 자세한 소개는 7장에서 찾아볼 수 있다. 함수의 기본적인 형식은 항상 물결표(~)로 시작을 하며 한 변수만 적용 대상인 경우에는 점(.) 또는 .x를 개별 열(변수) 대신 사용하면 된다. 여러 함수를 적용해야 하는 경우에는 list() 안에 name = fun의 형식으로 나열해 주면 된다. 마지막 입력 요소 .names는 결과물로 생성되는 열 이름의 작성에 관련된 것이다. 패키지 glue에서 제공하는 방식을 사용하게 되며, 선택된 열을 {col}로, 사용된 함수를 {fn}으로 각각 표시한다. 디폴트는 하나의 함수만이 .fns에 지정되면 {col}, 여러 함수가 리스트로 지정되면 {col}_{fn}이 새로 생성된 열의 이름이 된다. 함수 summarise()와 함께 사용 예제를 통하여 함수 across()를 summarise()와 함께 사용하면 작업의 효율성을 얼마나 높일 수 있는지 살펴보자. 우선 데이터 프레임 iris에서 모든 숫자형 변수들의 평균값을 구해보자. iris_t &lt;- as_tibble(iris) iris_t |&gt; summarise(across(where(is.numeric), mean)) ## # A tibble: 1 × 4 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.84 3.06 3.76 1.20 숫자형 변수에 대해서는 평균을 계산하고 요인에 대해서는 수준의 개수를 구해보자. iris_t |&gt; summarise(across(where(is.numeric), mean), across(where(is.factor), nlevels) ) ## # A tibble: 1 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 5.84 3.06 3.76 1.20 3 전체 행의 개수와 숫자형 변수의 표준편차를 구해보자. iris_t |&gt; summarise(n = n(), across(where(is.numeric), sd)) ## # A tibble: 1 × 5 ## n Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0.828 0.436 1.77 0.762 전체 행 개수 n이 150이 아닌 NA가 된 이유는 n이 숫자이기 때문에 across()에 의하여 다른 4개의 열과 더불어 표준편차를 계산하는 열로 선택된 것이고, 숫자 하나에 대해서는 표준편차를 계산할 수 없기 때문이다. 이 문제는 n의 계산을 across() 다음으로 배치하면 해결된다. 이와 같이 across()에서 where(is.numeric)으로 열을 선택하는 경우, 숫자 요약 과정에 대해서는 주의할 필요가 있다. iris_t |&gt; summarise(across(where(is.numeric), sd), n = n()) ## # A tibble: 1 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 0.828 0.436 1.77 0.762 150 이름이 Se로 시작하는 변수의 평균과 표준편차를 구해보자. iris_t |&gt; summarise(across(starts_with(&quot;Se&quot;), list(M = mean, SD = sd))) ## # A tibble: 1 × 4 ## Sepal.Length_M Sepal.Length_SD Sepal.Width_M Sepal.Width_SD ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.84 0.828 3.06 0.436 결과로 생성되는 열의 이름을 다른 형식으로 바꿔보자. iris_t |&gt; summarise(across(starts_with(&quot;Se&quot;), list(M = mean, SD = sd), .names=&quot;{fn}_{col}&quot;)) ## # A tibble: 1 × 4 ## M_Sepal.Length SD_Sepal.Length M_Sepal.Width SD_Sepal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.84 0.828 3.06 0.436 각 숫자형 변수들의 결측값 개수를 구해보자. iris_t |&gt; summarise(across(where(is.numeric), ~ sum(is.na(.x)))) ## # A tibble: 1 × 4 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 0 0 0 0 변수 Species별로 각 숫자형 변수의 자료에서 중복되지 않은 숫자의 개수를 구해보자. iris |&gt; group_by(Species) |&gt; summarise(across(where(is.numeric), ~ length(unique(.x)))) ## # A tibble: 3 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 setosa 15 16 9 6 ## 2 versicolor 21 14 19 9 ## 3 virginica 21 13 20 12 함수 unique()는 중복되지 않은 자료를 추출하는 기능을 갖고 있어서, 그 결과를 length()에 입력하면 중복되지 않는 숫자의 개수를 계산할 수 있다. 동일한 결과는 함수 n_distinct()를 사용해도 얻을 수 있다. iris |&gt; group_by(Species) |&gt; summarise(across(where(is.numeric), n_distinct)) ## # A tibble: 3 × 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 setosa 15 16 9 6 ## 2 versicolor 21 14 19 9 ## 3 virginica 21 13 20 12 데이터 프레임 airquality에서 변수 Ozone과 Solar.R의 평균과 표준편차를 구해보자. mean_sd &lt;- list( mean = ~ mean(.x, na.rm = TRUE), sd = ~ sd(.x, na.rm = TRUE) ) as_tibble(airquality) |&gt; summarise(across(c(Ozone, Solar.R), mean_sd)) ## # A tibble: 1 × 4 ## Ozone_mean Ozone_sd Solar.R_mean Solar.R_sd ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 42.1 33.0 186. 90.1 다른 기본 함수와 함께 사용 데이터 프레임 iris에서 요인을 문자형 변수로 전환해 보자. 마지막 변수 Species의 유형이 문자형으로 변환되었음을 확인할 수 있다. iris_t |&gt; mutate(across(where(is.factor), as.character)) |&gt; print(n=3) ## # A tibble: 150 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## # ℹ 147 more rows 이번에는 센티미터 단위로 측정된 자료를 인치 단위로 변환해 보자. iris_t |&gt; mutate(across(where(is.numeric), ~ .x/2.54)) |&gt; print(n=3) ## # A tibble: 150 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 2.01 1.38 0.551 0.0787 setosa ## 2 1.93 1.18 0.551 0.0787 setosa ## 3 1.85 1.26 0.512 0.0787 setosa ## # ℹ 147 more rows 기존의 자료를 그대로 유지하려면, 옵션 .names에 새롭게 생성된 변수의 이름을 지정하면 된다. iris_t |&gt; mutate(across(where(is.numeric), ~ .x/2.54, .names=&quot;{col}_inch&quot;), .before = 1) |&gt; print(n = 3) ## # A tibble: 150 × 9 ## Sepal.Length_inch Sepal.Width_inch Petal.Length_inch Petal.Width_inch ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2.01 1.38 0.551 0.0787 ## 2 1.93 1.18 0.551 0.0787 ## 3 1.85 1.26 0.512 0.0787 ## # ℹ 147 more rows ## # ℹ 5 more variables: Sepal.Length &lt;dbl&gt;, Sepal.Width &lt;dbl&gt;, ## # Petal.Length &lt;dbl&gt;, Petal.Width &lt;dbl&gt;, Species &lt;fct&gt; 이름에 Len이 있는 변수의 자료가 모두 6.5 이상이 되는 행을 선택해 보자. iris_t |&gt; filter(across(contains(&quot;Len&quot;), ~ .x &gt;= 6.5)) ## Warning: Using `across()` in `filter()` was deprecated in dplyr 1.0.8. ## ℹ Please use `if_any()` or `if_all()` instead. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## # A tibble: 4 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 7.6 3 6.6 2.1 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2 virginica 함수 filter()에는 across() 대신 if_any()나 if_all()의 사용이 권장되고 있다. 이름에 Len이 있는 변수의 자료가 모두 6.5 이상이 되는 행을 선택하는 문제는 if_all()을 사용하면 된다. iris_t |&gt; filter(if_all(contains(&quot;Len&quot;), ~ .x &gt;= 6.5)) ## # A tibble: 4 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 7.6 3 6.6 2.1 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2 virginica 데이터 프레임 airquality에서 적어도 하나의 결측값이 있는 행은 모두 제거해 보자. 모든 행을 대상으로 하는 것이므로 첫 번째 입력 요소인 .cols는 생략할 수 있다. 다만, 첫 번째 입력 요소가 없는 상태이기 때문에 두 번째 입력 요소에는 반드시 이름을 붙여야 한다. as_tibble(airquality) |&gt; filter(if_all(.fns = ~ !is.na(.x))) |&gt; print(n = 3) ## Warning: Using `if_all()` without supplying `.cols` was deprecated in dplyr 1.1.0. ## ℹ Please supply `.cols` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. ## # A tibble: 111 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 41 190 7.4 67 5 1 ## 2 36 118 8 72 5 2 ## 3 12 149 12.6 74 5 3 ## # ℹ 108 more rows 결측값이 있는 행의 제거는 함수 na.omit()으로도 할 수 있다. as_tibble(airquality) %&gt;% na.omit() %&gt;% print(n = 3) ## # A tibble: 111 × 6 ## Ozone Solar.R Wind Temp Month Day ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 41 190 7.4 67 5 1 ## 2 36 118 8 72 5 2 ## 3 12 149 12.6 74 5 3 ## # ℹ 108 more rows 함수 distinct()와 count()도 across()와 함께 사용할 수 있는데, 이 두 함수의 경우에는 입력 요소 .fns를 지정할 필요가 없다. 데이터 프레임 mpg에서 처음 두 변수는 manufacturer와 model이다. 두 변수의 자료가 중복되지 않는 행을 선택해 보자. 함수 distinct()에 변수의 이름을 단순 나열하는 방법을 사용할 수 있지만, 함수 across()를 사용하면 &lt;tidy-select&gt; 방식을 사용할 수 있게 된다. mpg |&gt; distinct(manufacturer, model, .keep_all = TRUE) |&gt; print(n = 3) ## # A tibble: 38 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 quattro 1.8 1999 4 manua… 4 18 26 p comp… ## 3 audi a6 quattro 2.8 1999 6 auto(… 4 15 24 p mids… ## # ℹ 35 more rows mpg |&gt; distinct(across(1:2), .keep_all = TRUE) |&gt; print(n = 3) ## # A tibble: 38 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 quattro 1.8 1999 4 manua… 4 18 26 p comp… ## 3 audi a6 quattro 2.8 1999 6 auto(… 4 15 24 p mids… ## # ℹ 35 more rows mpg |&gt; distinct(across(starts_with(&quot;m&quot;)), .keep_all = TRUE) |&gt; print(n = 3) ## # A tibble: 38 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 quattro 1.8 1999 4 manua… 4 18 26 p comp… ## 3 audi a6 quattro 2.8 1999 6 auto(… 4 15 24 p mids… ## # ℹ 35 more rows 변수 manufacturer와 model로 구성되는 각 그룹에 속한 행의 개수를 계산해서 내림차순으로 정렬해보자. 이 문제는 함수 count()를 사용하면 되며, 내림차순으로 정렬하는 것은 옵션 sort=TRUE를 추가하면 된다. 함수 count에서도 변수의 이름을 단순 나열하는 방법을 사용할 수 있지만, 함수 across()를 사용하면 &lt;tidy-select&gt; 방식을 사용할 수 있게 된다. mpg |&gt; count(manufacturer, model, sort = TRUE) %&gt;% print(n = 3) ## # A tibble: 38 × 3 ## manufacturer model n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge caravan 2wd 11 ## 2 dodge ram 1500 pickup 4wd 10 ## 3 dodge dakota pickup 4wd 9 ## # ℹ 35 more rows mpg |&gt; count(across(1:2), sort = TRUE) %&gt;% print(n = 3) ## # A tibble: 38 × 3 ## manufacturer model n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge caravan 2wd 11 ## 2 dodge ram 1500 pickup 4wd 10 ## 3 dodge dakota pickup 4wd 9 ## # ℹ 35 more rows mpg |&gt; count(across(starts_with(&quot;m&quot;)), sort=TRUE) |&gt; print(n = 3) ## # A tibble: 38 × 3 ## manufacturer model n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge caravan 2wd 11 ## 2 dodge ram 1500 pickup 4wd 10 ## 3 dodge dakota pickup 4wd 9 ## # ℹ 35 more rows 이 문제는 함수 group_by()와 tally()를 함께 사용해도 된다. mpg |&gt; group_by(across(1:2)) %&gt;% tally(sort = TRUE) %&gt;% print(n = 3) ## # A tibble: 38 × 3 ## # Groups: manufacturer [15] ## manufacturer model n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 dodge caravan 2wd 11 ## 2 dodge ram 1500 pickup 4wd 10 ## 3 dodge dakota pickup 4wd 9 ## # ℹ 35 more rows 4.6 행 단위 작업: rowwise() dplyr은 열 단위 작업에 특화되어 있다고 할 수 있다. 이것은 관찰값이 행, 변수가 열을 구성하고 있는 데이터 프레임에서 주된 분석 대상이 되는 것은 행이 아닌 열이기 때문이다. 이러한 측면에서 R의 큰 장점 중에 하나인 벡터 연산이 주로 열 단위로 이루어지는 것은 당연한 현상이다. 하지만 경우에 따라서는 행 단위의 연산을 해야 하는데, 이것은 매우 번거로울 수 있다. 예컨대, 각 행마다 여러 열 자료들의 합계 등의 요약 통계량을 구해야 한다면 루프 연산을 사용해야 한다. 함수 rowwise()를 사용하면 행 단위 연산이 가능하게 되는데, 이것은 각각의 행이 개별 그룹으로 취급을 받기 때문이다. 간단한 예를 가지고 작동 방식을 살펴보자. df1 &lt;- tibble(x = 1:2, y = 3:4, z = 5:6) df1 |&gt; rowwise() ## # A tibble: 2 × 3 ## # Rowwise: ## x y z ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 3 5 ## 2 2 4 6 함수 rowwise()로 생성된 데이터 프레임은 입력된 데이터 프레임 df1과 차이가 없어 보인다. 다만 rowwise_df라는 class 속성이 추가되는 것인데, 이것으로 인하여 함수 summarise()나 mutate()의 작동 방식이 달라진다. 함수 rowwise()로 구성된 행 단위의 그룹은 ungroup()으로 해체할 수 있다. 행 단위로 세 변수 x, y, z의 합을 나타내는 열을 생성해 보자. df1 |&gt; rowwise() |&gt; mutate(total = sum(c(x, y, z))) ## # A tibble: 2 × 4 ## # Rowwise: ## x y z total ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 3 5 9 ## 2 2 4 6 12 함수 rowwise() 없이 mutate(df1, total = sum(c(x, y, z)))를 실행하면 모든 행을 대상으로 세 변수의 합을 계산하게 된다. 행 단위 연산을 수행할 때에도 대부분의 경우에는 많은 열을 대상으로 작업을 하게 된다. 함수 rowwise()로 생성된 데이터 프레임을 대상으로 summarise()나 mutate()로 작업을 할 때, &lt;tidy-select&gt; 방식으로 열을 선택하기 위해서는 함수 c_across()를 함께 사용해야 한다. 사용법은 c_across(cols = everything())이며 cols에 &lt;tidy-select&gt; 방식으로 선택할 열을 지정하면 된다. 다음에 주어진 데이터 프레임 df2의 모든 숫자형 변수의 행 단위 합을 계산해 보자. df2 &lt;- tibble(id = 1:3, w = 10:12, x = 20:22, y = 30:32, z = 40:42) df2 |&gt; rowwise() |&gt; summarise(total = sum(c_across(where(is.numeric)))) ## # A tibble: 3 × 1 ## total ## &lt;int&gt; ## 1 101 ## 2 106 ## 3 111 함수 rowwise() 안에서도 &lt;tidy-select&gt; 방식으로 열을 선택해서 지정할 수 있는데, 이렇게 지정된 열은 각 행의 ID 변수 역할을 하게 되어서 연산 과정에 포함되지 않는다. df2 |&gt; rowwise(id) |&gt; mutate(total = sum(c_across(where(is.numeric)))) ## # A tibble: 3 × 6 ## # Rowwise: id ## id w x y z total ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 10 20 30 40 100 ## 2 2 11 21 31 41 104 ## 3 3 12 22 32 42 108 행 단위 연산으로 생성된 데이터 프레임을 대상으로 아무런 문제없이 열 단위 연산을 수 행할 수 있다. 데이터 프레임 df2의 각 열을 행 단위 합 total에 대한 비율로 변환해 보자. df2 |&gt; rowwise(id) |&gt; mutate(total = sum(c_across(where(is.numeric)))) |&gt; ungroup() |&gt; mutate(across(w:z, ~ .x/total)) ## # A tibble: 3 × 6 ## id w x y z total ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 0.1 0.2 0.3 0.4 100 ## 2 2 0.106 0.202 0.298 0.394 104 ## 3 3 0.111 0.204 0.296 0.389 108 함수 ungroup()을 제외하고 실행해도 동일한 결과를 얻을 수 있지만, rowwise_df class 속성이 생성된 데이터 프레임에 그대로 남아있게 된다. 4.7 연습문제 데이터 프레임 iris는 세 가지 종류 붓꽃 setosa , versicolor , virginica의 꽃잎과 꽃받침의 길이와 폭을 측정한 자료이다. 변수 Species가 \"setosa\"인 붓꽃 중에 변수 Sepal.Length의 값이 가장 큰 붓꽃을 선택해서 다음과 같은 형태로 출력해 보자. ex1_1 ## # A tibble: 1 × 2 ## Species Sepal.Length ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 5.8 \"versicolor\"와 \"virginica\" 중에 Petal.Length와 Petal.Width의 합이 가장 작은 붓꽃을 찾아서 다음과 같은 형태로 출력해 보자. ex1_2 ## # A tibble: 1 × 3 ## Species Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 versicolor 3 1.1 붓꽃 setosa 중에 변수 Petal.Length가 3 이하고, Petal.Width가 1 이하인 케이스가 몇 송이가 되는지 확인해 보자. 데이터 프레임 mpg에는 234대 자동차의 연비와 관련된 자료가 입력되어 있다. mpg %&gt;% print(n = 3) ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa… ## 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa… ## 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa… ## # ℹ 231 more rows 변수 manufacturer에는 몇 종류의 회사가 입력되어 있는지 확인해서, 다음의 형태로 출력해 보자. ex2_1 ## # A tibble: 15 × 1 ## manufacturer ## &lt;chr&gt; ## 1 audi ## 2 chevrolet ## 3 dodge ## 4 ford ## 5 honda ## 6 hyundai ## 7 jeep ## 8 land rover ## 9 lincoln ## 10 mercury ## 11 nissan ## 12 pontiac ## 13 subaru ## 14 toyota ## 15 volkswagen 변수 manufacturer의 값이 같은 자동차가 많이 있는데, 각 manufacturer별로 변수 cty의 값이 가장 큰 자동차를 선택해 보자. 선택된 자동차의 변수 manufacturer, model, displ과 cty를 다음의 형태로 출력해 보자. ex2_2 ## # A tibble: 15 × 4 ## manufacturer model displ cty ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 audi a4 1.8 21 ## 2 chevrolet malibu 2.4 22 ## 3 dodge caravan 2wd 2.4 18 ## 4 ford mustang 3.8 18 ## 5 honda civic 1.6 28 ## 6 hyundai sonata 2.4 21 ## 7 jeep grand cherokee 4wd 3 17 ## 8 land rover range rover 4.2 12 ## 9 lincoln navigator 2wd 5.4 12 ## 10 mercury mountaineer 4wd 4 14 ## 11 nissan altima 2.5 23 ## 12 pontiac grand prix 3.1 18 ## 13 subaru impreza awd 2.2 21 ## 14 toyota corolla 1.8 28 ## 15 volkswagen new beetle 1.9 35 모든 문자형 변수의 이름을 대문자로 수정하고 순서를 앞으로 이동해서 mpg_ch에 할당해 보자. mpg_ch의 형태는 다음과 같다. mpg_ch %&gt;% print(n = 3) ## # A tibble: 234 × 11 ## MANUFACTURER MODEL TRANS DRV FL CLASS displ year cyl cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 audi a4 auto(l5) f p compa… 1.8 1999 4 18 29 ## 2 audi a4 manual(m5) f p compa… 1.8 1999 4 21 29 ## 3 audi a4 manual(m6) f p compa… 2 2008 4 20 31 ## # ℹ 231 more rows 다음은 Wikipedia에서 covid-19 관련 자료가 있는 웹 페이지(https://en.wikipedia.org/wiki/COVID-19_pandemic_by_country_and_territory)에 있는 HTML 테이블의 일부분이다. R로 불러와서 다음과 같이 tibble 형태로 출력해 보자. ex3_1 ## # A tibble: 240 × 5 ## `` Country `Deaths / million` Deaths Cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;&quot; World[a] 872 6,955,128 769,773,882 ## 2 &quot;&quot; Peru 6,501 221,364 4,517,034 ## 3 &quot;&quot; Bulgaria 5,661 38,397 1,299,201 ## 4 &quot;&quot; Bosnia and Herzegovina 5,057 16,352 403,057 ## 5 &quot;&quot; Hungary 4,896 48,801 2,203,356 ## 6 &quot;&quot; North Macedonia 4,748 9,941 348,374 ## 7 &quot;&quot; Georgia 4,572 17,122 1,850,905 ## 8 &quot;&quot; Croatia 4,537 18,288 1,274,154 ## 9 &quot;&quot; Slovenia 4,448 9,431 1,344,668 ## 10 &quot;&quot; Montenegro 4,232 2,654 251,133 ## # ℹ 230 more rows 자료가 없는 ex3_1의 첫 번째 변수를 제거하고, 변수 'Deaths / million'의 이름을 Death_rate로 변경하자. 또한 첫 번째 행과 잘못된 자료가 입력된 마지막 8개 행도 제거해서, ex3_2에 할당해 보자. 변경된 데이터 프레임의 처음 3개 행과 마지막 3개 행의 내용은 다음과 같다. ex3_2 %&gt;% slice_head(n = 3) ## # A tibble: 3 × 4 ## Country Death_rate Deaths Cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Peru 6,501 221,364 4,517,034 ## 2 Bulgaria 5,661 38,397 1,299,201 ## 3 Bosnia and Herzegovina 5,057 16,352 403,057 ex3_2 %&gt;% slice_tail(n = 3) ## # A tibble: 3 × 4 ## Country Death_rate Deaths Cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Chad 10 194 7,698 ## 2 Burundi 1 15 54,358 ## 3 North Korea 0 6 1 백만명당 사망자 수를 나타내는 변수 Death_rate의 값이 가장 작은 3개 나라를 선택해서 다음과 같이 출력해 보자. ex3_3 ## # A tibble: 3 × 4 ## Country Death_rate Deaths Cases ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 North Korea 0 6 1 ## 2 Burundi 1 15 54358 ## 3 Chad 10 194 7698 변수 Cases는 감염자 수를 나타내고, 변수 Deaths는 사망자 수를 나타내고 있다. 감염자 수에 대한 사망자 수의 비율, 즉 Deaths/Cases의 값이 가장 낮은 3개 나라를 선택해서 다음과 같이 출력해 보자. ex3_4 ## # A tibble: 3 × 4 ## Country Death_rate Deaths Cases ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Nauru 78 1 5393 ## 2 Burundi 1 15 54358 ## 3 Cook Islands 117 2 7152 전통적 데이터 프레임과 tibble로 구성된 리스트를 만들어 보자. 다음과 같은 리스트 ex4를 만들어 보자. ex4 ## $df1 ## name Sales ## 1 Park 14 ## 2 Lee 16 ## 3 Kim 21 ## ## $df2 ## # A tibble: 4 × 3 ## age gender income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 24 M 2000 ## 2 35 F 3100 ## 3 28 F 3800 ## 4 21 F 200 리스트 ex4의 첫 번째 요소인 데이터 프레임에서 변수 Sales가 20을 초과하는 행을 선택해서 다음과 같이 출력해 보자. 단, 패키지 dplyr의 함수를 전혀 사용하지 않는다. ex4_1 ## name Sales ## 3 Kim 21 리스트 ex4의 두 번째 요소인 tibble에서 변수 gender가 \"F\"인 행들의 변수 income의 평균값을 패키지 dplyr의 함수를 사용해서 계산해 보자. "],["chapter-ggplot2.html", "5 장 ggplot2에 의한 자료 시각화 5.1 ggplot2 시작하기 5.2 시각적 요소와의 연결: Mapping 5.3 그룹별 그래프 작성: Facet 5.4 기하 객체: Geometric object 5.5 통계적 변환: Statistical transformation 5.6 위치 조정: Position adjustments 5.7 좌표계: Coordinate system 5.8 연습문제", " 5 장 ggplot2에 의한 자료 시각화 자료의 시각화(Visualization)란 자료의 구조를 꿰뚫어 볼 수 있는 명쾌한 그래프를 이용하는 자료 분석방법을 의미한다. 잘 그려진 그래프는 자료의 모습을 있는 그대로 보여 주는 유일한 분석방법이며, 다른 어떠한 분석기법에 의한 결과보다도 더 많은 정보를 전달해 줄 수 있는 방법이기도 하다. 그림 5.1은 자료 시각화의 위력을 잘 보여주는 예로서 Cleveland (1993) 에 의한 놀라운 발견이다. 1930년대 초 미네소타 주의 농경학자들이 보리 종류에 따른 수확량의 차이를 알아보기 위한 경작 실험을 실시하였다. 6군데 경작지에 10종류 보리를 2년간 경작하였는데, Morris 지역만이 1932년의 수확량이 1931년의 수확량 보다 많다는 것을 알 수 있다. 6개 경작지가 모두 근처에 있다는 점을 고려해 보면 유독 Morris 지역에서만 다른 결과가 나왔다는 것이 상당히 의심스럽다고 할 수 있으며, 데이터가 바뀌었을 가능성을 생각해 볼 수 있는 상황이다. 그림 5.1: 보리 자료에 대한 다중 패널 점그림 자료 시각화에 특히 강점이 있는 R에는 몇 가지의 그래프 작성 시스템이 있다. 함수 plot() 등이 속해 있는 base graphics도 그 중 하나인데, 이들 그래프 작성 시스템 중 가장 효과적이고 여러 면에서 우수한 시스템이 바로 ggplot2라고 할 수 있다. 그래프 작성에 일관된 규칙이 있어서 복잡한 상황에서도 쉽게 확장이 가능하다는 것이 큰 장점 중 하나이다. 패키지 ggplot2도 core tidyverse에 속해있기 때문에 library(tidyverse)를 먼저 실행해 주면 사용할 수 있다. 5.1 ggplot2 시작하기 패키지 ggplot2에 있는 데이터 프레임 mpg의 변수 displ과 hwy의 관계를 산점도로 나타내보자. 변수 displ은 리터 단위의 배기량이고, hwy는 고속도로 연비이다. library(tidyverse) ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) 그림 5.2: ggplot2의 산점도 패키지 ggplot2에서 그래프 작성은 함수 ggplot()으로 시작한다. 이 함수는 우선 그래프 작성에 사용되는 데이터를 입력 요소 data에서 지정하는데, 데이터는 반드시 데이터 프레임이어야 한다. 또한 이 함수는 그래프가 작성될 좌표계(coordinate system)를 작성하고, 이어서 작성될 그래프를 기다리는 역할을 한다. 따라서 함수 ggplot()만으로는 실질적인 그래프가 작성되지 않는다. 실질적인 그래프는 이어진 함수 geom_point()로 작성된다. 패키지 ggplot2에서는 하나 또는 여러 개의 레이어(layer)들이 겹쳐져서 그래프가 완성되는데, 그림 5.2에는 점으로 이루어진 하나의 레이어만이 사용되었다. 레이어를 추가하는 geom 함수에는 geom_point() 외에도 다양한 함수들이 있으며, 앞으로 계속 소개될 것이다. 또한 geom 함수에는 입력 요소 mapping이 있는데, 이것은 항상 함수 aes()와 함께 사용된다. 매핑(mapping)은 데이터와 그래프의 시각적 요소(aesthetic)를 서로 연결시키는 것으로, 함수 aes()의 입력 요소 x와 y는 X축과 Y축에 각각의 변수를 연결시키는 역할을 하고 있다. ggplot2에서 그래프 작성의 최소 요소 패키지 ggplot2에서 그래프를 작성하기 위해서는 반드시 따라야 할 법칙이 있다. Grammar of graphics라고 불리는 이 법칙은 모든 그래프 작성에서 일정하게 적용되기 때문에 익숙해지기만 한다면 복잡한 형태의 그래프도 쉽게 작성할 수 있게 된다. 패키지 ggplot2에서 그래프를 작성하기 위한 3가지 최소 요소는 &lt;Data&gt;, &lt;Geom_Function&gt;, 그리고 &lt;Mappings&gt;로써 다음과 같은 형식을 취해야 한다. ggplot(data = &lt;Data&gt;) + &lt;Geom_FUnction&gt;(mapping = aes(&lt;Mappings&gt;)) &lt;Data&gt;는 그래프 작성에 사용될 데이터 프레임을 지정하는 것이고, &lt;Geom_Function&gt;은 geom 함수 중 하나를 지정하는 것으로써 레이어를 작성한다. 여러 개의 레이어를 겹치기 위해서는 필요한 여러 개의 geom 함수를 덧셈 기호로 연결하면 된다. &lt;Mappings&gt;는 다양한 시각적 요소(크기, 모양, 색깔 등)와 데이터를 연결하는 것이다. 3가지의 필수 요소 외에도 다양한 그래프를 작성하기 위해서는 몇 가지 기본 요소가 더 필요하다. 앞으로 하나하나 살펴보도록 하겠다. 5.2 시각적 요소와의 연결: Mapping 그림 5.2와 같은 산점도를 작성하기 위해서는 점들의 위치와 더불어 점의 크기, 모양 및 색깔 등을 결정해야 하는데, 이러한 특성들은 우리가 그래프를 시각적으로 인식할 때 필요한 시각적 요소(aesthetic)라고 할 수 있다. 시각적 요소들은 데이터와 연동되어 결정되기도 하지만, 어떤 경우에는 데이터와 관계 없이 일정한 값을 가지기도 한다. 시각적 요소들을 데이터와 연동하여 결정하는 것을 매핑(mapping)이라고 하는데, 그림 5.2에서는 점의 위치만 매핑이 되었다. 점의 크기, 모양 또는 색깔과 같은 시각적 요소들을 변수와 연결하여 표현을 한다면, 기존의 그래프에 다른 변수의 정보를 추가할 수 있다. 예를 들어 데이터 프레임 mpg에 있는 변수 displ과 hwy의 산점도에 변수 class의 정보를 색깔로 추가해 보자. 색깔은 함수 aes()의 입력 요소 color에 의하여 변수와 연결된다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) 그림 5.3: 시각적 요소 color의 매핑 시각적 요소인 color를 데이터와 연결한 그림 5.3에는 변수 class의 값에 따라 다른 색이 사용되었고, 따라서 각 점이 어떤 class에 속하는지 바로 알 수 있게 되었다. 그러나 class의 범주 개수가 지나치게 많아서 정보 파악이 어려운 그래프가 작성되었다. 시각적 요소 color에 범주형 변수를 매핑할 때에는 범주의 개수가 많지 않아야 효과적인 그래프가 작성된다. 사용된 색깔에 대한 범례는 자동으로 추가된다. 이번에는 점의 모양을 변수 drv와 연결하여 표현해 보자. 점의 모양은 함수 aes()의 입력 요소 shape에 의하여 변수와 연결된다. 시각적 요소 shape와 매핑되는 변수는 drv와 같이 이산형이어야 한다. 그림 5.4에는 세 가지 모양의 점이 사용되었으나, 모양 차이가 쉽게 느껴지지 않고 있다. 이런 경우에는 다른 시각적 요소를 drv에 함께 매핑하여 작성한 그림 5.5가 좋은 대안이 될 수 있다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = drv)) 그림 5.4: 시각적 요소 shape의 매핑 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = drv, color = drv)) 그림 5.5: 시각적 요소 shape의 매핑 또 다른 시각적 요소인 점의 크기를 변수 cyl과 연결해 보자. 점의 크기는 함수 aes()의 입력 요소 size에 의하여 변수와 연결된다. 시각적 요소 size에는 연속형 변수를 매핑하는 것이 좋다. 변수 cyl의 값에 따라 점의 크기가 조절이 되는 것을 알 수 있지만, 범주의 개수가 너무 많아서 점의 크기를 구분하는 것이 거의 불가능한 그래프가 작성되었다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = cyl)) 그림 5.6: 시각적 요소 size의 매핑 여러 시각적 요소를 동시에 사용해야 하는 경우가 많이 있다. 이런 경우에, 여러 시각적 요소들을 모두 변수들과 매핑을 하게 되면 그래프에 너무 많은 정보를 표현하게 될 가능성 이 있으며, 오히려 그래프의 의미가 모호해질 수 있다는 점에 유의해야 할 것이다. 그림 5.7은 세 가지 시각적 요소를 모두 다른 변수와 연결하여 작성한 것이다. 좋지 않은 그래프의 작성 예가 된다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class, shape = drv, size = cyl)) 그림 5.7: 여러 시각적 요소를 동시에 매핑을 실시한 그래프 시각적 요소를 데이터와 연결하여 결정하지 않고 사용자가 값을 직접 지정하는 것도 가능하다. 변수 displ과 hwy의 산점도를 작성하되 점을 모두 빨간색으로 나타내 보자. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;red&quot;) 그림 5.8: 시각적 요소 color의 사용자 지정 시각적 요소의 값을 사용자가 지정하기 위해서는 color, shape, size 등을 함수 aes()의 밖으로 빼내서 geom 함수의 입력 요소로 사용해야 한다. 각 시각적 요소에 지정되는 값은 다음의 규칙에 따른다. color: 색 이름 문자열 지정. 657개의 색 이름은 함수 colors()를 실행하면 확인할 수 있다. size: 점 크기를 mm 단위로 지정 shape: 점의 형태를 나타내는 0~25 사이의 숫자. 각 숫자에 대응되는 점의 형태는 그림 5.9에서 볼 수 있다. 숫자 0~14로 지정되는 속이 비어 있는 도형의 선 색깔과 숫자 15~20으로 지정되는 도형의 색깔은 color로 지정하고, 숫자 21~25로 표현되는 도형의 테두리 선 색깔은 color로, 내부를 채우는 색깔은 fill로 각각 지정한다. 그림 5.9: 시각적 요소 shape의 지정에 사용 가능한 숫자와 대응되는 점 형태 여러 시각적 요소의 값을 사용자가 동시에 지정하여 사용해야 하는 경우도 많이 있다. 그림 5.10는 점의 크기와 모양, 색깔을 모두 사용자가 지정한 그래프이다. 입력 요소 stroke는 shape가 21~25의 값으로 표현되는 점들의 테두리 선 두께를 조절하는 요소이다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;, size = 2, shape = 21, fill = &quot;red&quot;, stroke = 1) 그림 5.10: 여러 시각적 요소를 동시에 지정한 그래프 지금까지 살펴본 바에 의하면 시각적 요소를 변수와 매핑을 하고자 한다면 함수 aes() 안에서 변수와 연결해야 하고, 사용자가 값을 직접 지정하고자 한다면 함수 aes() 밖에서 원하는 값을 지정해야 한다. 그런데 만일 함수 aes() 안에서 시각적 요소의 특정 값을 사용자가 직접 지정하면 어떤 결과가 나올 것인가? 그림 5.11은 함수 aes() 안에서 시각적 요소 color에 \"blue\"를 지정했을 때의 결과이다. 함수 aes() 안에 color가 입력되면 그것은 매핑으로 인식되는데, 매핑은 변수와 연결되는 것이므로 특정 하나의 값과는 매핑이 성립되지 않는다. 따라서 \"blue\"라는 하나의 값만을 갖고 있는 새로운 변수를 스스로 만들고, 그 변수와 color를 매핑하게 된다. 사용된 점 색깔은 하나의 값만이 있는 변수에 color를 매핑할 경우 디폴트로 사용되는 색깔이다. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;)) 그림 5.11: 함수 aes() 안에서 color를 사용자가 지정한 경우의 그래프 5.3 그룹별 그래프 작성: Facet 범주형 변수가 다른 변수에 미치는 영향력을 그래프로 확인하는 방법으로써 범주형 변수에 의해 구분되는 그룹별로 그래프를 작성하여 비교하는 것을 생각해 볼 수 있다. 만일 그룹별로 작성된 그래프에 큰 차이가 없다면 범주형 변수의 영향력은 미미한 것으로 볼 수 있을 것이다. 이와 같이 그룹별로 데이터를 구분하여 그래프를 작성하는 것을 faceting이라고 하는데, 패키지 lattice의 Trellis plot과 동일한 개념이 된다. 함수 facet_wrap()에 의한 faceting 함수 facet_wrap()은 데이터를 구분하려는 변수가 하나인 경우에 주로 사용되며, 사용법은 facet_wrap(facets, nrow, ncol, scales, dir)이다. 여기에서 facets에는 그룹을 구성하는 변수를 지정하는데, 함수 vars()에 나열하면 된다. nrow와 ncol에는 패널의 행과 열의 개수 지정하며, scales는 각 패널의 XY축 범위를 설정하는 방식을 지정한다. 디폴트 \"fixed\"는 모든 패널의 XY축 범위를 동일하게 설정하고, \"free_x\"는 X축의 범위를 각 패널에 따라 다르게 설정하며, \"free_y\"는 Y축의 범위를 다르게 설정하고, \"free\"는 XY축의 범위를 다르게 설정하는 것이다. dir은 그래프의 배치 순서를 지정하는 것인데 디폴트 \"h\"는 행 방향으로 배치하고, \"v\"는 열 방향으로 배치하게 된다. 예를 들어 데이터 프레임 mpg의 변수 displ과 hwy의 산점도를 변수 class의 범주별로 구분하여 작성해 보자. ggplot(data=mpg) + geom_point(mapping=aes(x=displ,y=hwy)) + facet_wrap(vars(class)) 그림 5.12: 함수 facet_wrap()으로 작성된 그래프 그림 5.12을 구성하는 7개의 패널 중 2seater라는 제목의 패널에는 적은 개수의 데이터만 해당되는 것을 알 수 있다. 변수 class가 ‘2seater’인 케이스를 제거한 후 패널을 2열로 배치하여 작성해 보자. mpg |&gt; filter(class != &quot;2seater&quot;) |&gt; ggplot() + geom_point(aes(x = displ, y = hwy)) + facet_wrap(vars(class), ncol = 2) 그림 5.13: ncol로 패널 배치 조절 dir의 값 변경해서 패널의 그래프 배치 순서를 다르게 해 보자. mpg |&gt; filter(class != &quot;2seater&quot;) |&gt; ggplot() + geom_point(aes(x = displ, y = hwy)) + facet_wrap(vars(class), ncol = 2, dir = &quot;v&quot;) 그림 5.14: ncol과 dir로 패널 배치 조절 함수 facet_grid()에 의한 faceting 함수 facet_grid()은 데이터를 구분하려는 변수가 두 개인 경우에 주로 사용되는 함수이지만, 구분하려는 변수가 하나인 경우에도 사용할 수 있다. 사용법은 facet_grid(rows, cols, scales)이며, rows와 cols에는 패널의 행과 열을 구성하는 변수를 함수 vars()을 이용하여 지정한다. 예를 들어 데이터 프레임 mpg에서 데이터를 변수 drv와 cyl로 구분하여 displ과 hwy의 산점도를 각각 작성해 보자. 단, 변수 drv가 \"r\"인 데이터와 cyl이 5인 데이터는 제외하자. 함수 ggplot()으로 작성된 그래프를 지금까지는 Plots 창에 바로 나타나게 했지만, 이것을 객체에 할당할 수도 있다. 할당된 ggplot2 객체는 이후에 저장 및 출력 목적으로 사용할 수 있다. 하지만 그래프를 객체에 할당하는 주된 이유는 동일한 내용의 프로그램을 반복해서 입력하지 않기 위함인데, 기본적인 형태의 그래프를 작성하고 그것을 객체에 할당하면 동일한 작업을 반복할 필요 없이 거기에 몇 가지 요소만을 따로 추가하면 수정된 그래프를 작성할 수 있다. my_plot &lt;- mpg |&gt; filter(cyl != 5, drv != &quot;r&quot;) |&gt; ggplot() + geom_point(aes(x = displ, y = hwy)) 객체 my_plot을 작성하는 과정에서 확인할 수 있는 것은 함수 ggplot()에 데이터 프레임을 첫 번째로 입력하면 요소 이름인 data =을 생략할 수 있으며, 함수 geom_point()에 함수 aes()를 첫 번째로 입력하면 요소 이름인 mapping =을 생략할 수 있다는 것이다. 이것은 함수의 변수를 지정하는 방식에 대한 것으로써 자세한 내용은 7장에서 확인할 수 있다. 객체 my_plot에는 변수 drv가 \"r\"인 데이터와 cyl이 5인 데이터가 제외한 상태에서 두 변수 displ과 hwy의 산점도가 작성되어 있다. 여기에 함수 facet_grid()를 추가하면 우리가 원하는 그래프를 작성할 수 있다. 우선 한 변수만을 사용하여 데이터를 구분하고 그래프를 작성해 보자. my_plot + facet_grid(rows = vars(drv)) 그림 5.15: 함수 facet_grid()에 의한 한 변수의 faceting my_plot + facet_grid(cols = vars(cyl)) 그림 5.16: 함수 facet_grid()에 의한 한 변수의 faceting 이제는 두 개 변수를 동시에 사용하여 데이터를 구분하고 그래프를 작성해 보자. my_plot + facet_grid(rows = vars(drv), cols = vars(cyl)) 그림 5.17: 함수 facet_grid()에 의한 두 변수의 faceting 변수 drv의 두 범주와 cyl의 세 범주의 조합으로 구성되는 6개 그룹으로 데이터를 구분하여 각각 작성된 산점도가 그림 5.17이다. 변수 drv가 행을 구성하고 있고, 변수 cyl이 열을 구성하고 있다. 예를 들어 왼쪽 위 패널은 변수 drv가 “4”이고, 변수 cyl이 4인 자동차들의 displ과 hwy의 산점도이다. 옵션 scales의 값을 변경해서 패널의 XY축 범위를 다르게 설정해 보자. my_plot + facet_grid(rows = vars(drv), cols = vars(cyl), scales = &quot;free&quot;) 그림 5.18: 함수 facet_grid()에 의한 두 변수의 faceting 두 변수에 의한 faceting은 함수 facet_wrap()으로도 작성할 수 있다. my_plot + facet_wrap(vars(drv, cyl), scales = &quot;free&quot;) 그림 5.19: 함수 facet_wrap()에 의한 두 변수의 faceting 두 변수에 의한 faceting을 함수 facet_wrap()으로 작성하면, 각 패널의 라벨에 범주 값 두 개가 표시되는데, 변수의 이름도 함께 표시하는 것이 변수 조합을 확인하는데 더 편할 것이다. 각 패널의 strip에 표시되는 라벨에 변수 이름도 함께 표시하기 위해서는 옵션 labeller에 label_both를 지정하면 된다. my_plot + facet_wrap(vars(drv, cyl), scales = &quot;free&quot;, labeller = &quot;label_both&quot;) 그림 5.20: 함수 facet_wrap()에 의한 두 변수의 faceting 연속형 변수에 의한 faceting 연속형 변수를 이용하여 faceting을 하기 위해서는 우선 연속형 변수를 범주형 변수로 변환시켜야 하는데, 아래의 함수를 이용하면 비교적 쉽게 변환을 할 수 있다. cut_interval(x, n, length): 벡터 x를 길이가 length인 n개의 구간으로 구분 cut_width(x, width, boundary): 벡터 x를 길이가 width인 구간으로 구분. 옵션 boundary는 구간의 시작점을 지정. cut_number(x, n): 벡터 x를 n개의 구간으로 구분하되 각 구간에 속한 데이터 개수가 비슷해지도록 구분 예를 들어 데이터 프레임 airquality에서 반응변수 Ozone과 설명변수 Solar.R과 Wind의 관계를 알아보자. 이와 같이 세 연속형 변수의 관계를 알아보는데 적합한 그래프 중 하나는 설명변수 중 하나를 범주형으로 변환하여 faceting하는 것이다. 변수 Wind를 4개의 구간으로 구분하되 각 구간에 속한 데이터의 개수가 비슷해지도록 구분하고, 각 그룹에서 나머지 두 변수의 산점도를 작성해 보자. air_1 &lt;- airquality |&gt; mutate(Wind_d = cut_number(Wind, n = 4)) air_1 |&gt; ggplot() + geom_point(aes(x = Solar.R, y = Ozone)) + facet_wrap(vars(Wind_d)) 그림 5.21: 연속형 변수의 faceting Faceting은 기존의 그래프에 다른 변수의 정보를 추가하고자 할 때 매우 유용하게 사용되는 기법인데, 이러한 기능은 색깔 또는 점의 크기 등을 변수와 연결하는 매핑도 갖고 있는 기능이다. 두 기법은 서로 약간 다른 장단점이 있는데, faceting은 점들이 많이 겹쳐지는 경우에 더 명확하게 다른 변수의 정보를 확인할 수 있지만, 각 패널마다 작성된 그래프에 미세한 차이가 있는 경우에는 확인이 어려울 수 있다는 문제가 있다. 그림 5.21을 작성한 상황에서 변수 Wind_d를 색깔과 점의 크기와 연결시켜 나머지 두 변수의 산점도를 작성해 보자. air_1 |&gt; ggplot() + geom_point(aes(x = Solar.R, y = Ozone, color = Wind_d, size = Wind_d)) 그림 5.22: 매핑과 faceting의 비교 그림 5.22은 너무 많은 점들이 서로 겹쳐 있어서 관계를 확인하는 데 약간의 어려움이 있으며, 따라서 좋지 않은 그래프라고 하겠다. 5.4 기하 객체: Geometric object 우리가 작성하고자 하는 그래프는 일반적으로 점이나 선 또는 문자와 같은 몇 가지 유형의 ’기하 객체’로 이루어져 있다. 함수 plot() 등이 속한 base graphics 시스템에서는 높은-수준의 그래프 함수로 좌표축을 포함한 주된 유형의 그래프를 먼저 작성하고, 이어서 낮은-수준의 그래프 함수를 연속 사용하여 다른 유형의 ’기하 객체’를 추가하는 방식으로 그래프를 작성한다. 패키지 ggplot2에서는 각 유형 별 그래프를 따로 작성하고, 그것을 겹쳐 놓는 방식으로 그래프를 작성한다. 각 유형의 ’기하 객체’를 사용한 그래프를 작성하기 위해서는 해당되는 geom 함수를 실행하면 된다. 각 geom 함수가 실행되면 해당 유형의 그래프가 작성된 레이어(layer)가 생성되는데, 첫 번째 geom 함수로 생성된 레이어가 가장 밑에 놓이고, 다음 geom 함수의 레이어가 그 위에 차례로 겹쳐짐으로써 최종적으로 원하는 그래프를 얻게 된다. 그림 5.23과 그림 5.24는 데이터 프레임 mpg의 변수 displ과 hwy를 대상으로 geom_point()와 geom_smooth()를 각각 적용한 결과를 보여주고 있다. 동일한 자료를 사용하더라도 다른 geom 함수를 사용하면 다른 그래프가 작성되는 것을 알 수 있다. ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) 그림 5.23: 함수 geom_point()에 의한 그래프 ggplot(mpg) + geom_smooth(aes(x = displ, y = hwy)) 그림 5.24: 함수 geom_smooth()에 의한 그래프 현재 ggplot2에는 대략 30개 이상의 geom 함수가 있다. 예를 들어 한 변수를 대상으로 하는 geom 함수로는 geom_bar(), geom_histogram(), geom_density(), geom_dotplot() 등이 있고, 두 변수를 대상으로 하는 함수로는 geom_point(), geom_smooth(), geom_text(), geom_line(), geom_boxplot() 등이 있으며, 세 변수에 대한 함수로는 geom_contour(), geom_tile() 등이 있다. 사용할 수 있는 geom 함수들의 리스트는 RStudio의 메뉴에서 Help &gt; Cheatsheets &gt; Data Visualization with ggplot2를 선택하면 볼 수 있다. 글로벌 매핑과 로컬 매핑 데이터 프레임 mpg에서 변수 displ과 hwy의 산점도에 두 변수의 비모수 회귀곡선을 겹쳐서 나타내 보자. 비모수 회귀곡선이란 일반적으로 두 변수의 관계를 가장 잘 설명해주는 매끄러운(smooth) 곡선(line)을 의미하는 것이며, 함수 geom_smooth()가 그래프로 표현하는 기능을 갖고 있다. 따라서 원하는 작업을 수행하기 위해서는 함수 geom_point()와 함수 geom_smooth()를 함께 사용해야 하는데, 이 경우에 두 geom 함수에 적용되는 매핑이 동일하기 때문에 같은 내용을 다음과 같이 중복해서 입력하게 된다. ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) + geom_smooth(aes(x = displ, y = hwy)) # 중복된 입력 이러한 중복 입력의 문제는 함수 ggplot()에 있는 매핑 기능을 다음과 같이 사용하면 해결된다. ggplot(mpg, aes(x = displ, y = hwy)) + # 글로벌 매핑 geom_point() + geom_smooth() 그림 5.25: 글로벌 매핑을 적용해서 작성한 그래프 함수 ggplot()에 있는 매핑 기능은 해당 그래프 작성에 참여한 모든 geom 함수에 공통적으로 적용되는 일종의 글로벌 매핑이다. 반면에 함수 geom에 있는 매핑은 해당 geom으로 작성되는 레이어에만 적용되는 일종의 로컬 매핑이다. 따라서 여러 geom 함수에서 동일한 매핑을 사용한다면 한 번의 글로벌 매핑을 사용하는 것이 중복을 피하는 방법이 된다. 글로벌 매핑이 모든 geom 함수에 공통적으로 적용되기는 하지만, 실질적으로 레이어를 작성하는 geom 함수에서 이루어지는 로컬 매핑이 글로벌 매핑보다 우선해서 적용된다. 따라서 각 레이어에서 글로벌 매핑과 다른 내용으로 매핑을 할 수 있는데, 이러한 특성으로 인하여 훨씬 다양한 형태의 그래프를 작성할 수 있다. 데이터 프레임 mpg의 변수 displ과 hwy의 비모수 회귀곡선을 작성하고, 그 위에 산점도를 추가하되 변수 drv의 값에 따라 점의 색을 다르게 표시해 보자. 이와 같이 두 개 이상의 geom 함수를 사용해야 하는 경우, 글로벌 매핑과 로컬 매핑을 명확하게 구분해서 지정해야 한다. 여기에서 사용되는 매핑은 변수 displ과 hwy를 x와 y에 연결하는 것과 변수 drv에 color를 연결하는 세 가지가 있다. 세 가지를 모두 글로벌 매핑으로 지정한 그래프가 그림 5.26에 있고, 색깔은 함수 geom_point()에서 로컬 매핑으로 지정한 그래프가 그림 5.27에 있다. ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + geom_point() + geom_smooth(se = FALSE) 그림 5.26: 글로벌 매핑만 작용한 그래프 ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv)) + geom_smooth(se = FALSE) 그림 5.27: color는 로컬 매핑을 적용한 그래프 세 가지 매핑이 모두 글로벌로 지정된 경우에는 비모수 회귀곡선의 추정도 변수 drv로 구분되는 그룹별로 각각 이루어졌다는 것을 알 수 있다. 함수 geom_smooth()에서 옵션 se=FALSE를 사용하면 그래프에 비모수 회귀곡선의 신뢰구간이 표시되지 않는다. 이번에는 데이터 프레임 mpg의 변수 displ과 hwy의 비모수 회귀곡선을 변수 drv에 의해 구분되는 그룹별로 각각 추정하여 선의 종류를 다르게 표시하고, 그 위에 변수 drv의 값에 따라 점의 색을 다르게 하여 산점도를 추가해 보자. 또한 산점도의 점 크기도 조금 크게 하자. 여기에서 사용될 선의 종류도 시각적 요소로써 변수와의 연결은 입력 요소 linetype으로 지정한다. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv), size=2) + geom_smooth(aes(linetype = drv), se = FALSE) 그림 5.28: 두 geom 함수에서 color와 linetype을 각각 로컬 매핑한 그래프 글로벌 데이터와 로컬 데이터 매핑에서와 같이 데이터도 함수 ggplot()에서 지정하는 글로벌 데이터와 개별 geom 함수에서 지정하는 로컬 데이터로 구분된다. 즉, 함수 ggplot()에 지정되는 data는 모든 geom 함수에 기본적으로 적용되고, 각 geom 함수에서 지정되는 data는 해당 레이어 작성에만 적용된다. 예를 들어 데이터 프레임 mpg의 변수 displ과 hwy의 산점도를 작성하되 변수 drv의 값에 따라 점의 색을 다르게 하고, 그 위에 두 변수의 비모수 회귀곡선을 추가하되 변수 drv의 값이 4인 데이터만을 대상으로 추정해 보자. 이 경우에는 함수 geom_smooth()에 데이터 프레임 mpg 중 변수 drv의 값이 4인 케이스만 선택한 로컬 데이터를 지정해야 한다. 각 geom 함수에서 로컬 데이터를 지정할 때 주의할 점이 하나 있는데, 그것은 로컬 데이터를 지정하는 요소 data=가 모든 geom함수에서는 두 번째 요소라는 것이다. 따라서 다음과 같이 geom 함수 내에서 첫 번째에 위치하게 된다면 반드시 data=이라는 이름과 함께 로컬 데이터를 지정해야 한다. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = drv), size = 2) + geom_smooth(data = filter(mpg, drv == &quot;4&quot;), se = FALSE, color = &quot;red&quot;) 그림 5.29: 로컬 데이터를 사용하여 작성한 레이어 함수 geom_text()는 그래프에 문자 라벨을 추가할 때 사용되는 geom 함수인데, 로컬 데이터를 사용해야 하는 중요한 경우가 된다. 예를 들어, 두 연속형 변수의 산점도에 다른 점들과 조금 다른 특성을 보이는 점이 있다면, 해당 자료의 부가 정보를 표시할 수 있는 라벨을 점 주변에 추가하는 것이 좋을 것이다. 데이터 프레임 mpg의 변수 displ과 cty의 산점도를 작성해 보자. p1 &lt;- ggplot(mpg, aes(x = displ, y = cty)) + geom_point() p1 그림 5.30: 변수 displ과 cty의 산점도 변수 displ이 증가하면 cty가 감소하는 관계를 보여주는 산점도가 작성되었는데, 변수 cty의 값이 유독 큰 두 점을 볼 수 있다. 두 점이 어떤 자동차에 해당되는 자료인지 확인해 보자. mpg %&gt;% slice_max(cty, n = 2) %&gt;% select(manufacturer, model, cty) ## # A tibble: 2 × 3 ## manufacturer model cty ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 volkswagen new beetle 35 ## 2 volkswagen jetta 33 그림 5.30의 산점도에 변수 cty의 값이 큰 두 점 주변에 라벨을 추가해 보자. 함수 geom_text()에서 라벨의 위치는 시각적 요소 x와 y에, 라벨 내용은 label에 매핑을 한다. 변수 manufacturer와 model의 값을 서로 붙여 라벨로 표시해 보자. p1 + geom_text(data = slice_max(mpg, cty, n = 2), aes(label = paste(manufacturer, model))) 그림 5.31: 변수 displ과 cty의 산점도에 라벨 추가 라벨 내용이 점과 겹쳐졌고, 왼쪽 부분이 잘려서 보이지 않게 되었다. 이런 경우에는 라벨의 위치를 조정할 필요가 있는데, 라벨의 위치 조정은 vjust, hjust와 nudge_x, nudge_y로 할 수 있다. p1 + geom_text(data = slice_max(mpg, cty, n = 2), aes(label = paste(manufacturer, model)), nudge_x = 0.3, nudge_y = 1) 그림 5.32: 변수 displ과 cty의 산점도에 추가된 라벨의 위치 조정 nudge_x에 양의 값을 지정하면 우측으로 이동하고, 음의 값을 지정하면 죄측으로 이동한다. 또한 nudge_y에는 양의 값을 지정하면 위로 이동하고, 음의 값을 지정하면 아래로 이동한다. 지정하는 값은 XY축의 scale에 맞추어 사용자가 결정해야 한다. p1 + geom_text(data = slice_max(mpg, cty, n = 2), aes(label = paste(manufacturer, model)), hjust = &quot;left&quot;, vjust = &quot;top&quot;) 그림 5.33: 변수 displ과 cty의 산점도에 추가된 라벨의 위치 조정 hjust에는 \"left\", \"middle\", \"right\" 중 하나를 지정하고, vjust에는 \"bottom\", \"center\", \"top\" 중 하나를 지정하면 된다. 그림 5.33의 경우에는 hjust = \"left\"와 vjust = \"top\"을 지정한 것인데, hjust = \"left\"로써 점이 라벨의 왼쪽에, vjust = \"top\"로써 점이 라벨의 위쪽에 있도록 조정한 것이다. 라벨을 추가하려는 점의 위치가 너무 가까우면 라벨이 서로 겹쳐져서 내용을 알 수 없게 될 수 있다. 이런 경우에는 서로 겹치는 라벨 중 자료의 순서에 따라 먼저 작성되는 것만 표시하는 것이 좋은 방법이 될 수 있다. 데이터 프레임 mpg에서 변수 displ과 hwy의 산점도를 작성해 보자. p2 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() p2 그림 5.34: 변수 displ과 hwy의 산점도 변수 hwy의 값이 40이 넘는 자동차의 manufacturer와 model의 값을 출력해 보자. mpg %&gt;% filter(hwy &gt; 40) %&gt;% select(manufacturer, model, hwy) ## # A tibble: 3 × 3 ## manufacturer model hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 volkswagen jetta 44 ## 2 volkswagen new beetle 44 ## 3 volkswagen new beetle 41 변수 hwy의 값이 40이 넘는 자료가 그림 5.34에는 2개로 표시되었지만, 사실은 3개의 자료가 있는 것을 알 수 있다. 이제 이 자료에 라벨을 추가하면, 당연히 두 개의 라벨이 겹쳐서 나타나게 된다. p2 + geom_text(data = slice_max(mpg, hwy, n = 3), aes(label = paste(manufacturer, model)), hjust = &quot;left&quot;, vjust = &quot;top&quot;) 그림 5.35: 변수 displ과 hwy의 산점도에 라벨 추가 이런 경우에는 함수 geom_text()에 옵션 check_overlap에 TRUE를 지정하면, 겹치는 라벨 중 자료의 순서에 따라 먼저 작성되는 것만 표시하게 된다. p2 + geom_text(data = slice_max(mpg, hwy, n = 3), aes(label = paste(manufacturer, model)), hjust = &quot;left&quot;, vjust = &quot;top&quot;, check_overlap = TRUE) 그림 5.36: 변수 displ과 hwy의 산점도에 겹치지 않는 라벨만 추가 그래프 범례(legend) 추가 여러 개의 geom 함수를 사용해서 그래프를 작성하다 보면, 다른 종류의 선이나 점들이 나타나게 된다. 이런 경우에 각각의 선이나 점들에 대한 범례를 추가하지 않으면 그래프의 정보를 정확하게 전달할 수 없게 된다. base graphics에서는 함수 legend()를 사용해서 그래프에 범례를 직접 추가할 수 있다. ggplot2에는 이런 기능을 갖고 있는 함수는 없지만, geom 함수에서 문자열을 매핑하면 자동적으로 범례가 생성되는 기능을 이용하면 필요한 범례를 적절하게 추가할 수 있다. 데이터 프레임 mpg의 변수 displ과 hwy의 산점도에 두 변수의 비모수 회귀곡선과 선형회귀직선을 함께 표시해 보자. 비모수 회귀곡선과 선형회귀직선은 모두 함수 geom_smooth()로 작성할 수 있는데, method에 \"lm\"을 지정하면 선형회귀직선이 작성된다. 디폴트는 \"loess\"로써 비모수 회귀곡선이 작성된다. 두 가지 선을 색으로 구분하고 범례를 추가하려면, 함수 aes()에서 color에 범례에 표시하고자 하는 문자열을 매핑하면 된다. labs()에서 color = NULL을 지정해서 범례의 제목을 제거했다. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth(aes(color = &quot;lm&quot;), method = &quot;lm&quot;, se = FALSE, linewidth = 1.2) + geom_smooth(aes(color = &quot;loess&quot;), method = &quot;loess&quot;, se = FALSE, linewidth = 1.2) + labs(x = &quot;Engine displacement&quot;, y = &quot;Highway MPG&quot;, color = NULL, title = &quot;Scatter plot with regression lines&quot;) + theme(legend.position = &quot;bottom&quot;) 그림 5.37: 그래프에 범례 추가 5.5 통계적 변환: Statistical transformation 그래프 작성 과정에서 함수 ggplot()에 입력된 데이터 프레임의 자료가 그대로 사용되는 경우도 있지만, 통계적 변환 과정을 거쳐 생성된 자료가 사용되는 경우도 많이 있다. 예를 들어 산점도는 입력된 자료를 그대로 사용해서 작성할 수 있는 그래프이지만, 비모수 회귀 곡선의 경우에는 적절한 추정 과정을 통해 새롭게 생성된 자료를 사용해야 작성할 수 있는 그래프이다. 통계적 변환(혹은 stat)이란 함수 ggplot()에 입력된 데이터 프레임 자료의 변환을 의미하는 것으로써 각 그래프 유형별로 대응되는 stat이 존재한다. 예를 들어 산점도와 같이 입력된 자료 그대로가 사용되는 경우에 대한 stat은 \"identity\"이며, 비모수 회귀곡선의 작성에 필요한 stat은 \"smooth\"가 된다. 그런데 우리는 지금까지 두 종류의 그래프를 작성할 때 geom 함수에 별도로 stat을 지정하지 않았다. 이것은 모든 geom 함수에는 미리 설정된 디폴트 stat이 존재하는 것을 의미한다. 예를 들어 geom_point()는 geom_point(stat=\"identity\")와 동일한 것이고, geom_smooth()는 geom_smooth(stat=\"smooth\")와 동일한 것이다. 그래프는 geom 함수를 사용하지 않고 stat 함수를 대신 사용해도 작성할 수 있다. 예를 들어 함수 stat_smooth()는 함수 geom_smooth()의 디폴트 stat인 \"smooth\"에 대응되는 함수인데, geom_smooth() 대신 사용해도 동일한 그래프를 작성할 수 있다. 이와 같이 모든 geom 함수는 그것을 대체할 수 있는 stat 함수가 존재한다. 또한 geom 함수의 경우처럼 모든 stat 함수에는 디폴트 geom이 설정되어 있다. 예를 들어 함수 stat_identity()는 stat_identity(geom=\"point\")를 의미한다. stat 함수를 활용해서 막대 그래프를 작성해 보자. 막대 그래프는 범주형 변수의 분포를 나타내는 데 적합한 그래프로써, 함수 geom_bar()로 작성한다. 이때 사용되는 디폴트 stat은 \"count\"이다. 따라서 geom_bar() 또는 stat_count()로 동일한 막대 그래프를 작성할 수 있다. 데이터 프레임 mpg의 변수 trans는 자동차의 변속기 종류를 나타내고 있다. 변수 trans의 막대 그래프를 geom_bar()와 stat_count()로 각각 작성해 보자. ggplot(mpg, aes(x = trans)) + geom_bar() ggplot(mpg, aes(x = trans)) + stat_count() 그림 5.38: 변수 trans의 막대 그래프 그래프를 geom 함수를 사용하여 작성할 것인지 혹은 stat 함수를 사용하여 작성할 것인지는 사용자가 더 편한 방법을 선택하면 된다고 본다. 그러나 일반적으로 그래프 유형을 쉽게 확인할 수 있는 geom 함수를 사용하는 것이 직관적으로 더 명확하다고 보여지기 때문에 특별한 상황이 아니라면 geom 함수를 사용하여 그래프를 작성하는 것이 더 좋을 듯하다. 함수 ggplot()으로 그래프를 작성하는 과정에서 stat 함수는 데이터 프레임을 입력 자료로 받고 변환과정을 거쳐 그래프 작성에 필요한 변수들로 이루어진 데이터 프레임을 내부적으로 생성한다. 이런 과정을 통해 stat 함수가 생성한 변수들은 사용자가 직접 지정하여 사용할 수 있다. 예를 들어 함수 geom_bar() 또는 stat_count()는 count와 prop라는 두 변수를 생성하는데, 변수 count는 각 범주의 도수로써 막대 그래프의 디폴트 막대 높이로 사용된다. 변수 prop는 그룹별 비율을 의미하는 것으로 막대 그래프의 막대 높이를 상대도수로 작성하고자 한다면 사용해야 할 변수가 된다. stat 함수에서 생성된 변수를 사용자가 직접 지정해서 사용할 때는 함수 after_stat()에 해당 변수를 입력하면 된다. 예를 들어 stat_count()에서 생성된 변수 prop를 사용자가 직접 사용하기 위해서는 after_stat(prop)라고 지정하면 된다. 이전에는 ..prop..나 stat(prop)가 사용되었으나, 이제는 함수 after_stat()의 사용이 권장되고 있다. 데이터 프레임 mpg의 변수 trans에 대한 막대 그래프를 상대도수를 이용하여 작성해 보자. 이 경우 변수 after_stat(prop)를 시각적 요소 y로 매핑하는 것이 필요한데, 문제는 y에 대한 매핑만으로는 원하는 형태의 그래프를 얻을 수 없다는 것이다. ggplot(mpg) + geom_bar(aes(x = trans, y = after_stat(prop))) 그림 5.39: 디폴트 group에 의해 잘못 작성된 막대 그래프 그 이유는 변수 after_stat(prop)가 그룹별 비율을 나타내고 있는데, 변수 trans의 각 범주가 개별 그룹으로 설정되는 것이 디폴트이기 때문이다. 따라서 각 그룹에는 한 범주의 도수만이 존재하게 되어 변수 after_stat(prop)는 항상 1이 된다. 이 문제는 개별 그룹으로 나눠져 있던 각 범주들을 하나의 그룹으로 묶어주면 해결이 된다. 자료들을 그룹으로 묶어주는 기능은 시각적 요소 group에 있는데, 모든 범주를 같은 그룹으로 묶어주는 것이므로 group에 하나의 값을 함수 aes() 안에서 지정해주면 된다. 프로그램에서는 group = 1으로 지정했지만, 어떤 값을 지정해도 상관없다. ggplot(mpg) + geom_bar(aes(x = trans, y = after_stat(prop), group = 1)) 그림 5.40: group에 하나의 값을 지정하여 제대로 작성된 막대 그래프 대부분의 경우, geom 함수에 어떤 stat을 지정해야 하는지 걱정할 필요 없이 디폴트 값을 그대로 사용하면 원하는 그래프를 작성할 수 있다. 하지만 몇몇 상황에서는 stat을 따로 지정해야 하는데, 막대 그래프의 경우에는 도수분포표를 자료로 입력하는 경우가 여기에 해당된다. 예를 들어 데이터 프레임 mpg의 변수 trans의 범주에서 auto(av)에서 auto(s6)까지를 auto로 통합하고 manual(m5)와 manual(m6)를 manual로 통합한 후, 두 범주에 속한 자료의 개수를 확인해 보자. 각 범주에 속한 자료의 개수를 세는 작업은 함수 count()로 할 수 있다. mpg_am &lt;- mpg |&gt; mutate(am = substr(trans, 1, nchar(trans)-4)) |&gt; count(am) mpg_am ## # A tibble: 2 × 2 ## am n ## &lt;chr&gt; &lt;int&gt; ## 1 auto 157 ## 2 manual 77 데이터 프레임 mpg_am은 변수 trans의 범주를 auto와 manual로 통합한 변수 am의 도수분포표가 입력되어 있다. 이러한 도수분포표가 함수 geom_bar()에 자료로 입력된 경우 입력된 자료 그대로를 막대 그래프의 높이로 사용해야 한다. 따라서 이 경우에는 stat이 \"count\"가 아닌 \"identity\"로 지정을 해야 한다. ggplot(mpg_am) + geom_bar(aes(x = am, y = n), stat = &quot;identity&quot;) 그림 5.41: 함수 geom_bar()에 stat=\"identity\"를 지정해야 하는 경우 5.6 위치 조정: Position adjustments 그래프를 작성하다 보면 그래프의 요소들이 서로 겹치는 경우가 있다. 이런 경우에 그래프 요소들의 위치를 약간 조정하여 서로 겹치지 않게 할 수 있다면 그래프의 완성도를 더 높일 수 있을 것이다. 예를 들어 데이터 프레임 mpg의 변수 cty와 hwy의 산점도를 작성해 보자. ggplot(mpg, aes(x = cty, y = hwy)) + geom_point() 그림 5.42: 점들이 서로 겹쳐진 산점도 그림 5.42에 나타난 점의 개수는 데이터의 전체 개수인 234개에 훨씬 못 미쳐 보인다. 이것은 시내 연비와 고속도로 연비인 두 변수의 값이 모두 반올림 처리가 되어 자연수로 입력되었기 때문에 값이 같은 자료가 많아져서 발생한 현상이다. 이와 같이 산점도의 점들이 서로 겹치게 되면 자료가 갖고 있는 정보를 정확하게 파악하기 어렵게 되는데, 이것은 사실 산점도가 갖고 있는 가장 큰 문제이기도 하다. 산점도의 점이 겹치는 문제의 해결 방안은 경우에 따라 달라질 수밖에 없는데, 변수 cty와 hwy의 산점도 경우에는 각 자료에 약간의 난수(random noise)를 더해주어 점의 위치를 수정해 주는 방법을 사용하면 문제를 해결할 수 있다. 이와 같이 산점도의 점에 약간의 난수를 더해 점의 위치를 조정하기 위해서는 함수 geom_point()에 position=\"jitter\"를 추가하면 되는데, 그 결과는 그림 5.43와 같다. ggplot(mpg, aes(x = cty, y = hwy)) + geom_point(position = &quot;jitter&quot;) 그림 5.43: 옵션 position='jitter'의 효과 함수 geom_jitter()는 함수 geom_point(position=\"jitter\")와 같은 기능을 갖고 있으며, 점의 위치를 조정하기 위해 사용되는 난수의 크기를 조절하는 옵션 width와 height를 간편하게 이용할 수 있다는 장점이 있다. ggplot(mpg, aes(x = cty, y = hwy))+ geom_jitter(width = 0.4, height = 0.05) 그림 5.44: 함수 geom_jitter()에 옵션 width와 height를 사용한 그래프 ggplot(mpg, aes(x = cty, y = hwy))+ geom_jitter(width = 0.05, height = 0.4) 그림 5.45: 함수 geom_jitter()에 옵션 width와 height를 사용한 그래프 연속형 변수의 특성상 원래의 자료가 서로 겹치는 경우는 거의 없다고 할 수 있다. 또한 대규모 자료들이 좁은 구역에 몰려서 하나의 큰 무리를 형성하는 경우, 점의 위치에 약간의 난수를 추가하는 위치 조정만으로는 문제 해결이 불가능할 것이다. 따라서 위치 조정은 연속형 자료를 위한 그래프보다는 이산형 자료를 위한 그래프, 특히 이변량 막대 그래프 작성에서 가장 유용하게 사용된다. 이변량 막대 그래프는 두 범주형 변수의 분포를 함께 나타내는 막대 그래프로서, 쌓아 올리는 형태 혹은 옆으로 붙여 놓은 형태를 취하게 된다. 데이터 프레임 mpg에서 변수 trans의 범주를 auto와 manual로 통합한 변수 am과 cyl의 이변량 막대 그래프를 작성해 보자. 이 때 변수 cyl이 5인 케이스는 제거한다. 먼저 자료를 준비해 보자. mpg_1 &lt;- mpg |&gt; mutate(am = substr(trans, 1, nchar(trans)-4)) |&gt; filter(cyl != 5) 이변량 막대 그래프의 작성은 함수 geom_bar()로 할 수 있는데, 시각적 요소 x와 fill에 변수를 하나씩 대응시킨다. p_1 &lt;- ggplot(mpg_1, aes(x = as.factor(cyl), fill = am)) + xlab(&quot;Number of Cylinders&quot;) 디폴트 형태는 시각적 요소 fill과 연결된 변수의 도수가 위로 쌓아 올려지는 position=\"stack\"이다. p_1 + geom_bar() 그림 5.46: 쌓아 올린 이변량 막대 그래프 옆으로 붙여 놓은 막대 그래프는 옵션 position에 \"dodge\" 또는 \"dodge2\"를 지정하면 작성된다. p_1 + geom_bar(position = &quot;dodge&quot;) 그림 5.47: 옆으로 붙여 놓은 이변량 막대 그래프 p_1 + geom_bar(position = &quot;dodge2&quot;) 그림 5.48: 옆으로 붙여 놓은 이변량 막대 그래프 옵션 position에 \"fill\"을 지정하면, 시각적 요소 x에 매핑된 변수를 조건으로 하는 조건부 확률에 의한 쌓아 올린 막대 그래프가 작성된다. 따라서 모든 막대의 높이는 1이 된다. p_1 + geom_bar(position = &quot;fill&quot;) 그림 5.49: 조건부 확률에 의한 쌓아 올린 이변량 막대 그래프 연속형 변수의 분포를 그룹별로 비교하고자 하는 경우 유용하게 사용되는 그래프가 ‘나란히 서 있는’ 상자그림이다. 상자그림을 작성하는 geom 함수는 geom_boxplot()인데, 그룹을 구성하는 변수를 x 변수로 지정하고 연속형 변수를 y 변수로 지정하면 수직 방향으로 나란히 서 있는 상자그림을 작성할 수 있다. 예를 들어 데이터 프레임 mpg에서 변수 trans의 범주를 auto와 manual로 통합한 변수 am을 생성하고, 변수 cyl이 5인 케이스를 제거한 데이터 프레임 mpg_1을 대상으로, 변수 cyl에 따른 변수 hwy의 상자그림을 작성해 보자. 그룹을 구성하는 변수는 요인이거나 문자형 변수가 되어야 하는데, 변수 cyl은 정수형 변수이기 때문에 함수 as.factor()로 유형을 요인으로 변경하고 x에 매핑을 하였다. ggplot(mpg_1, aes(x = as.factor(cyl), y = hwy)) + geom_boxplot() + xlab(&quot;Number of Cylinders&quot;) 그림 5.50: 그룹 변수가 하나인 나란히 서 있는 상자그림 일반적으로 볼 수 있는 나란히 서 있는 상자그림은 하나의 그룹 변수를 대상으로 작성되는데, 만일 그룹을 구성하는 변수가 두 개라면 상자그림을 어떻게 배치하는 것이 최적이겠는가? 예를 들어 두 변수 cyl과 am을 그룹 변수로 지정하여 hwy의 상자그림을 작성해보자. 변수 cyl을 x에, 변수 am을 fill에 각각 매핑을 해서 작성하면, 변수 cyl에 따라 작성된 변수 hwy의 상자그림을 다시 변수 am에 따라 분할한 것처럼 보인다. 이러한 배치는 옵션 position에 \"dodge\"가 디폴트로 적용되어 작성된 결과이다. ggplot(mpg_1, aes(x = as.factor(cyl), y = hwy)) + geom_boxplot(aes(fill = am)) + xlab(&quot;Number of Cylinders&quot;) 그림 5.51: 그룹 변수가 두 개인 나란히 서 있는 상자그림 다른 방법으로 faceting을 사용한 그래프를 작성할 수 있다. ggplot(mpg_1, aes(x = as.factor(cyl), y = hwy)) + geom_boxplot() + facet_wrap(vars(am)) + xlab(&quot;Number of Cylinders&quot;) 그림 5.52: 그룹 변수가 두 개인 나란히 서 있는 상자그림 5.7 좌표계: Coordinate system 좌표계는 시각적 위치 요소인 x와 y를 근거로 그래프 각 요소의 2차원 위치를 결정하는 체계이다. 디폴트 좌표계는 데카르트 좌표계인 coord_cartesian()이며, 그 외에 활용도가 높은 좌표계로 coord_flip()과 coord_polar()가 있다. coord_cartesian()의 활용: XY축 범위 조정 함수 coord_cartesian()은 xlim과 ylim으로 그래프의 XY축의 범위를 조정하는 기능이 있다. 원래 XY축의 조정은 ggplot2에서 실행되는 Grammar of graphics 성분 중 scale이 담당하는 영역이다. Scale이란 자료와 시각적 요소와의 매핑 및 XY축과 범례 등의 내용 조정을 의미한다. 대부분의 경우에는 디폴트 상태에서 그래프를 작성하지만, XY축의 범위나 XY축의 라벨 등을 변경해야 한다면, scale의 디폴트 값을 수정해야 한다. 예를 들어 데이터 프레임 mpg의 변수 displ과 hwy의 산점도에 비모수 회귀곡선을 추가한 그래프의 X축 범위를 (3,6)으로 축소시켜보자. Scale 함수는 scale_*1*_*2*()의 형태를 취하고 있는데, *1*은 수정하고자 하는 시각적 요소를 지정하는 것으로써 color, x, y, fill 등이 가능하고, *2*는 적용되는 scale을 지칭하는 것으로 discrete, continuous 등이 가능하다. 따라서 연속형 변수 displ과 연결된 시각적 요소 x의 범위를 (3,6)으로 수정하기 위해서는 함수 scale_x_continuous(limits = c(3, 6))을 추가해야 한다. p &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() p + scale_x_continuous(limits = c(3, 6)) ## Warning: Removed 105 rows containing non-finite values (`stat_smooth()`). ## Warning: Removed 105 rows containing missing values (`geom_point()`). 그림 5.53: ’scale’로 X축 범위 축소 이러한 XY축의 범위 조정은 상당히 흔한 작업이기 때문에 간편하게 scale의 디폴트 값을 수정할 수 있도록 함수 xlim()과 ylim()이 만들어졌다. 즉 위의 예제는 p + xlim(3,6)을 실행해도 동일한 그래프를 작성할 수 있다. Scale 함수를 사용하여 XY축 범위를 축소한 경우, 조심해야 할 점은 범위를 벗어난 자료들이 모두 NA로 바뀐다는 것이다. 따라서 그림 5.53는 범위를 벗어난 105개 자료가 삭제된 상태에서 작성된 그래프이다. 이에 반하여 XY축 범위를 함수 coord_cartesian()으로 축소하면, 전체 그래프 중 축소된 범위에 해당되는 부분만 확대해서 보여주는 것으로써 범위를 벗어난 자료를 삭제하지는 않는다. p + coord_cartesian(xlim=c(3,6)) + xlab(&quot;Engine Displacement&quot;) 그림 5.54: 함수 coord_cartesian()으로 X축 범위 축소 그림 5.54는 X축 라벨의 디폴트 값이 수정되었는데, 축의 라벨 수정도 상당히 흔한 작업이기 때문에 함수 scale_x_continuous(name = \"Engine Displacement\")을 실행시키는 대신 함수 xlab()으로 간편하게 수정할 수 있다. 또한 함수 labs()을 사용하면 X축, Y축 라벨 수정 및 그래프 제목, 범례의 제목 등도 수정할 수 있다. coord_flip()의 활용: XY축 좌표 90° 회전 ggplot2의 이전 버전에서는 대부분의 geom 함수가 주어진 x에 대한 y의 분포 등을 나타내는데 중점을 두고 있었다. 따라서 나란히 서 있는 상자그림은 그룹을 구성하는 x 변수의 개별 값에 대하여 연속형 y 변수의 상자그림이 수직방향으로 작성되는 것이 디폴트 형태가 되었고, 나란히 서 있는 상자그림을 수평방향으로 작성하고자 한다면, 수직방향으로 그래프를 작성하고, 작성된 그래프의 좌표를 함수 coord_flip()으로 90° 회전시켜야 했다. 그러나 최근 버전에는 y 변수를 조건 변수로 지정하는 것이 가능하게 되었고, 따라서 수평 방향의 상자그림을 작성하기 위해 굳이 함수 coord_flip()을 사용할 필요는 없어졌다. 데이터 프레임 mpg에서 변수 class의 그룹별로 hwy의 상자그림을 작성해 보자. 우선 조건 변수 class를 x 변수로 사용하는 경우이다. p1 &lt;- ggplot(mpg, aes(x = class, y = hwy)) + geom_boxplot() p1 그림 5.55: 수직방향의 나란히 서 있는 상자그림 p1 + coord_flip() 그림 5.56: 수평방향의 나란히 서 있는 상자그림 그림 5.56는 다음과 같이 조건 변수 class를 y 변수로 사용해서 작성할 수 있다. ggplot(mpg, aes(x = hwy, y = class)) + geom_boxplot() 또한 그림 5.55는 class를 y 변수로 지정하고 함수 coord_flip()을 다음과 같이 사용해서 작성할 수 있다. ggplot(mpg, aes(x = hwy, y = class)) + geom_boxplot() + coord_flip() 한 변수의 상자그림을 작성하는 경우에도 함수 geom_boxplot()에는 시각적 요소 x와 y 모두가 필요하다. 수직 방향으로 작성하는 경우에는 시각적 요소 y에 상자그림 작성 대상이 되는 연속형 변수를 연결하고, x에는 임의의 문자열을 매핑하면 된다. ggplot(mpg, aes(x = &quot;&quot;, y = hwy)) + geom_boxplot() + xlab(NULL) 그림 5.57: 수직방향 상자그림 수평방향 상자그림은 x에는 연속형 변수, y에는 임의의 문자열을 매핑하면 된다. ggplot(mpg, aes(x = hwy, y = &quot;&quot;)) + geom_boxplot() + ylab(NULL) 그림 5.58: 수평방향 상자그림 coord_polar()의 활용: 파이 그래프 작성 극좌표는 2차원 공간에 있는 어느 한 점의 위치를 원점에서의 거리와 각도로 나타내는 좌표계이다. 디폴트 좌표계인 데카르트 좌표를 극좌표로 전환하려면 함수 coord_polar()을 사용하면 되는데, 시각적 요소 x와 y 중 각도로 전환할 요소를 변수 theta에 지정해야 하며, 디폴트는 theta=\"x\"이다. 극좌표의 활용 예제로 Coxcomb 또는 Wind rose라고 불리는 그래프를 작성해 보자. 우선 데이터 프레임 mpg의 변수 class의 막대 그래프를 작성하되, 막대 사이의 간격을 없애고 범례를 제거해 보자. b1 &lt;- ggplot(mpg, aes(x = class, fill = class)) + geom_bar(show.legend = FALSE, width = 1) + labs(x = NULL, y = NULL) b1 그림 5.59: Coxcomb 그래프 작성을 위한 막대 그래프 함수 geom_bar()에 사용된 옵션 show.legend = FALSE는 범례를 제거하기 위한 것이며, width = 1은 막대 사이의 간격을 제거하기 위한 것이다. 변수 width는 막대 폭을 지정하는 것으로 구간의 90%를 차지하는 0.9가 디폴트 값이다. 이제 작성된 막대 그래프에 극좌표를 적용시켜 보자. b1 + coord_polar() 그림 5.60: 극좌표를 이용하여 막대 그래프를 Coxcomb 그래프로 변환 각도 theta에 디폴트인 x가 적용됐다. 따라서 동일한 막대 폭이 각도로 변환되어서 각 조각이 같은 크기의 각도를 유지하고 있고, 서로 다른 막대의 높이가 각 조각의 반지름으로 변환된 Coxcomb 그래프가 작성되었다. 극좌표 활용의 두 번째 예제로 파이 그래프와 Bullseye 그래프를 작성해 보자. 이 경우에도 막대 그래프를 작성하고 극좌표를 적용하는 것인데, 막대 그래프를 위로 쌓아 올리는 형태로 작성해야 한다. 한 변수에 대한 막대 그래프를 쌓아 올리기 위해서는 시각적 요소 x에 임의의 문자열을 매핑하고 범주형 변수를 시각적 요소 fill에 매핑해야 한다. 또한 X축 전체 구간을 막대로 가득 채우기 위해 width = 1을 추가해야 한다. b2 &lt;- ggplot(mpg, aes(x = &quot;&quot;, fill = class)) + geom_bar(width = 1) + labs(x = NULL, y = NULL) b2 그림 5.61: 파이 그래프 작성을 위한 막대 그래프 작성된 막대 그래프에 극좌표를 적용하면서 각도 theta에 디폴트인 \"x\"가 지정되면 전체 구간에 해당되는 360°가 모든 그룹에 적용되어 Bullseye 그래프가 작성된다. b2 + coord_polar() 그림 5.62: 극좌표를 이용하여 막대 그래프를 Bullseye 그래프로 변환 반면에 theta에 \"y\"를 지정하면 각 그룹의 상대도수에 비례하여 각도가 정해져서 파이 그래프가 작성된다. b2 + coord_polar(theta = &quot;y&quot;) 그림 5.63: 극좌표를 이용하여 막대 그래프를 파이 그래프로 변환 XY축을 제거하면 조금 더 깔끔한 파이 그래프를 작성할 수 있다. b2 + coord_polar(theta = &quot;y&quot;) + theme_void() 그림 5.64: 극좌표를 이용하여 막대 그래프를 파이 그래프로 변환 함수 coord_polar()를 활용하여 파이 그래프의 작성방법을 살펴보았으나, 사실 파이 그래프와 같이 면적의 차이로 그룹 간의 도수를 비교해야 하는 그래프는 가능한 사용하지 않는 것이 좋다. 그것은 사람들이 길이의 차이는 비교적 정확하게 분별할 수 있으나, 면적의 차이를 정확하게 구분하는 것이 쉽지 않기 때문이다. 좋은 그래프란 갖고 있는 정보를 신속하고도 정확하게 인지할 수 있는 그래프를 의미하는 것이고, 그런 의미에서 파이 그래프를 좋은 그래프라고 할 수는 없을 것이다. ggplot2의 기본 요소 지금까지 살펴본 ggplot2에서 그래프를 작성하는 기본 요소를 정리해 보면 다음과 같다. ggplot(data = &lt;Data&gt;) + &lt;Geom_Function&gt;(mapping = aes(&lt;Mappings&gt;), stat = &lt;Stat&gt;, position = &lt;Position&gt;) + &lt;Coord_Function&gt; + &lt;Facet_Function&gt; ggplot2는 base graphics보다 여러 면에서 개선된 그래프 작성 시스템이다. 특히 빅데이터 시대에 요청되는 다양한 그래픽스를 비교적 간편하게 작성할 수 있기 때문에 앞으로 한층 더 주목을 받게 될 것이다. 이 장에서는 ggplot2의 기본 개념에 대하여 살펴보았다. 일변량 혹은 이변량 자료 탐색 과정을 포함한 다양한 상황에서의 ggplot2의 활용 방안에 대해서는 9에서 자세하게 소개할 것이다. 5.8 연습문제 1. 데이터 프레임 airquality 는 New York city 의 오존 농도에 관한 데이터이다. 변수 Ozone과 Solar.R에는 많은 결측값이 있다. 두 변수 중 한 변수라도 결측값이 있는 날수를 월별로 나타내는 다음의 그래프를 작성해 보자. 월별로 변수 Ozone과 Solar.R의 산점도에 회귀직선을 추가한 다음의 그래프를 작성해 보자. 결측값이 지나치게 많은 6월 자료는 대상에서 제외한다. 2. 패키지 ggplot2에 있는 데이터 프레임 mpg에는 1999년과 2008년에 많이 판매됐던 38 종류 자동차에 대한 11개 변수가 입력되어 있다. 11개 변수 중 문자형 변수만 선택해서 다음과 같이 출력해 보자. ## # A tibble: 234 × 6 ## manufacturer model trans drv fl class ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 auto(l5) f p compact ## 2 audi a4 manual(m5) f p compact ## 3 audi a4 manual(m6) f p compact ## # ℹ 231 more rows 문자형 변수 중 manufacturer, model을 제외한 나머지 변수를 모두 요인으로 변경시켜서 다음과 같이 출력해 보자. ## # A tibble: 234 × 6 ## manufacturer model trans drv fl class ## &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 audi a4 auto(l5) f p compact ## 2 audi a4 manual(m5) f p compact ## 3 audi a4 manual(m6) f p compact ## # ℹ 231 more rows 요인으로 변경된 변수 trans의 범주별 빈도를 다음과 같이 출력해 보자. ## # A tibble: 10 × 2 ## trans n ## &lt;fct&gt; &lt;int&gt; ## 1 auto(av) 5 ## 2 auto(l3) 2 ## 3 auto(l4) 83 ## 4 auto(l5) 39 ## 5 auto(l6) 6 ## 6 auto(s4) 3 ## 7 auto(s5) 3 ## 8 auto(s6) 16 ## 9 manual(m5) 58 ## 10 manual(m6) 19 변수 trans의 범주 중 manual(m5)와 manual(m6)는 Manual로 통합하고, auto(l3), auto(l4), auto(l5), auto(l6)는 Auto-T1으로, 나머지 범주는 Auto-T2로 통합해서 각 범주의 빈도를 다음과 같이 막대 그래프로 나타내 보자. 3개 범주로 통합한 변수 trans와 변수 cyl의 관계를 알아보고자 한다. 변수 cyl에서 5의 값을 갖는 자동차 자료는 제외한다. 다음과 같은 3 종류의 막대 그래프를 작성하고, 두 변수의 관계를 설명해 보자. 세 번째 그래프는 상대도수에 의한 막대 그래프이다. 변수 cyl과 hwy의 관계를 알아보고자 한다. 다음의 그래프를 작성하고, 두 변수의 관계를 설명해 보자. 변수 cyl에서 5의 값을 갖는 자동차 자료는 제외한다. 변수 cyl, drv와 hwy의 관계를 알아보고자 한다. 다음의 두 가지 그래프를 작성하고, 세 변수의 관계를 설명해 보자. 변수 cyl에서 5의 값을 갖는 자동차 자료는 제외하며, 변수 drv에서 4는 4WD로 라벨을 변경하고, f와 r은 통합해서 F or R로 라벨을 변경한다. 변수 hwy와 cty의 차이가 가장 큰 자동차와 가장 작은 자동차의 manufacturer, model, cty, hwy의 값을 다음과 같이 각각 출력해 보자. 두 그룹에 속한 자동차들 사이에 두드러진 차이가 무엇인지 설명해 보자. ## # A tibble: 2 × 4 ## manufacturer model cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 honda civic 24 36 ## 2 volkswagen new beetle 29 41 ## # A tibble: 3 × 4 ## manufacturer model cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 nissan pathfinder 4wd 15 17 ## 2 toyota 4runner 4wd 15 17 ## 3 toyota toyota tacoma 4wd 15 17 변수 displ과 hwy의 산점도를 작성하되, 변수 hwy와 cty의 차이가 가장 큰 자동차에 해당하는 점에는 빨간 색으로 변수 manufacturer, model의 값을 라벨로 표시하고, 변수 hwy와 cty의 차이가 가장 작은 자동차에 해당하는 점에는 파란 색으로 변수 manufacturer, model의 값을 라벨로 표시해 보자. 라벨이 겹치는 경우에는 하나만 표시한다. 변수 hwy와 cty의 평균값을 새로운 변수 avg_mpg에 할당하고, 그 값이 가장 큰 자동차의 manufacturer, model, cty, hwy의 값을 다음과 같이 출력해 보자. ## # A tibble: 1 × 4 ## manufacturer model cty hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 volkswagen new beetle 35 44 변수 displ과 avg_mpg의 산점도를 작성하되, avg_mpg이 값이 가장 큰 세 대의 자동차에 해당하는 점에는 변수 manufacturer, model의 값을 라벨로 다음과 같이 표시해 보자. 변수 displ과 avg_mpg의 산점도에 비모수 회귀곡선과 선형회귀직선을 추가해 보자. 비모수 회귀곡선은 모든 자료를 사용해서 구하지만, 선형회귀직선은 앞 문제 산점도에 라벨이 표시된 3개의 점을 제외하고 추정한다. 범례도 함께 표시해서 다음과 같이 작성해 보자. 3. 패키지 MASS에 있는 데이터 프레임 Cars93는 1993년 미국에서 판매된 93 종류의 자동차에 대한 데이터로 27개 변수로 구성되어 있다. 모든 변수의 처음 3 케이스를 다음과 같이 출력해 보자. ## # A tibble: 93 × 27 ## Manufacturer Model Type Min.Price Price Max.Price MPG.city MPG.highway ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Acura Integra Small 12.9 15.9 18.8 25 31 ## 2 Acura Legend Midsize 29.2 33.9 38.7 18 25 ## 3 Audi 90 Compact 25.9 29.1 32.3 20 26 ## AirBags DriveTrain Cylinders EngineSize Horsepower RPM ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 None Front 4 1.8 140 6300 ## 2 Driver &amp; Passenger Front 6 3.2 200 5500 ## 3 Driver only Front 6 2.8 172 5500 ## Rev.per.mile Man.trans.avail Fuel.tank.capacity Passengers Length Wheelbase ## &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2890 Yes 13.2 5 177 102 ## 2 2335 Yes 18 5 195 115 ## 3 2280 Yes 16.9 5 180 102 ## Width Turn.circle Rear.seat.room Luggage.room Weight Origin Make ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 68 37 26.5 11 2705 non-USA Acura Integra ## 2 71 38 30 15 3560 non-USA Acura Legend ## 3 67 37 28 14 3375 non-USA Audi 90 ## # ℹ 90 more rows 변수 중 요인만 선택해서 다음과 같이 출력해 보자. ## # A tibble: 93 × 9 ## Manufacturer Model Type AirBags DriveTrain Cylinders ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Acura Integra Small None Front 4 ## 2 Acura Legend Midsize Driver &amp; Passenger Front 6 ## 3 Audi 90 Compact Driver only Front 6 ## Man.trans.avail Origin Make ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Yes non-USA Acura Integra ## 2 Yes non-USA Acura Legend ## 3 Yes non-USA Audi 90 ## # ℹ 90 more rows 변수 Manufacturer, Model 은 자동차 제조 회사의 이름과 자동차 모델 이름이 각각 입력되어 있다. 93대 자동차의 제조 회사 중 빈도가 가장 높은 상위 5개 회사를 구해보자. 현대 자동차의 경우에는 어떤 모델의 자동차가 판매되었는지 알아보자. 요인 중 변수 Manufacturer, Model, Make는 제외하고 나머지 요인들의 수준의 개수를 확인해서 다음과 같이 출력해 보자. ## Type AirBags DriveTrain Cylinders Man.trans.avail Origin ## 1 6 3 3 6 2 2 변수 Cylinders와 Origin의 범주별 빈도를 다음과 같이 각각 구해보자. ## Cylinders n ## 1 3 3 ## 2 4 49 ## 3 5 2 ## 4 6 31 ## 5 8 7 ## 6 rotary 1 ## Origin n ## 1 USA 48 ## 2 non-USA 45 변수 Cylinders의 6개 범주 중 빈도가 낮은 3개 범주는 제외하고 막대 그래프를 작성하되, 각 범주의 빈도를 다음과 같이 그래프에 함께 나타내보자. 범주형 변수 Cylinders와 Origin의 관계를 알아보고자 한다. 변수 Cylinders의 6개 범주 중 빈도가 낮은 3개 범주는 제외하고 다음 두 그래프를 작성한다. 또한 두 변수의 관계를 설명해 보자. 모든 숫자형 변수의 평균을 계산해서 다음과 같이 출력해 보자. ## Mean ## Min.Price 17.125806 ## Price 19.509677 ## Max.Price 21.898925 ## MPG.city 22.365591 ## MPG.highway 29.086022 ## EngineSize 2.667742 ## Horsepower 143.827957 ## RPM 5280.645161 ## Rev.per.mile 2332.204301 ## Fuel.tank.capacity 16.664516 ## Passengers 5.086022 ## Length 183.204301 ## Wheelbase 103.946237 ## Width 69.376344 ## Turn.circle 38.956989 ## Rear.seat.room NA ## Luggage.room NA ## Weight 3072.903226 결측값이 있는 변수만을 대상으로 자료에 포함된 결측값의 개수와 결측값을 제외한 평균값을 각각 계산해서 다음과 같이 출력해 보자. ## Warning: There was 1 warning in `summarise()`. ## ℹ In argument: `across(.fns = list(Mean = ~mean(.x, na.rm = TRUE), Num.NA = ## ~sum(is.na(.x))))`. ## Caused by warning: ## ! Using `across()` without supplying `.cols` was deprecated in dplyr 1.1.0. ## ℹ Please supply `.cols` instead. ## Rear.seat.room_Mean Rear.seat.room_Num.NA Luggage.room_Mean ## 1 27.82967 2 13.89024 ## Luggage.room_Num.NA ## 1 11 범주형 변수인 Cylinders와 숫자형 변수 Price의 관계를 알아보고자 한다. 변수 Cylinders의 6개 범주 중 빈도가 낮은 3개 범주는 제외하고 두 변수의 관계를 가장 잘 나타내는 그래프를 작성해 보자. 또한 두 변수의 관계를 설명해 보자. 차량의 가격에 대한 변수 중 Max.Price와 Min.Price가 있다. 두 변수의 차이와 변수 Price의 산점도를 작성해 보자. 산점도에 두 변수의 차이가 가장 큰 자동차의 Manufacturer, Model 값을 해당 점 주변에 다음과 같이 표시해 보자. 두 숫자형 변수인 Price와 MPG.city의 관계를 살펴보고자 한다. 두 변수의 산점도를 작성하되, Price의 값이 지나치게 높은 두 자동차와 MPG.city의 값이 상당히 큰 세 자동차의 Manufacturer, Model 값을 산점도에 다음과 같이 함께 표시해 보자. 변수 Price와 MPG.city의 산점도를 다시 작성하되, 12)번 문제에서 작성된 두 변수의 산점도에서 라벨이 부착된 5개 점을 제외한 나머지 자료를 대상으로 비모수 회귀곡선과 선형회귀직선을 각각 추정해서 다음과 같이 그래프에 범례와 함께 나타내보자. 4. 패키지 ggplot2의 데이터 프레임 mpg와 패키지 MASS의 데이터 프레임 Cars93는 자동차 연비와 관련된 자료가 입력되어 있다. Cars93에서 변수 Manufacturer, Man.trans.avail, MPG.highway, EngineSize, Cylinders을 선택해서 데이터 프레임 cars_93에 입력하라. mpg에서는 변수 manufacturer, trans, hwy, displ, cyl을 선택하되, 변수 year가 1999인 케이스만 선택해서 데이터 프레임 cars_99에 입력하라. 두 데이터 프레임의 첫 세 케이스의 출력 결과는 다음과 같다. cars_93 |&gt; print(n = 3) ## # A tibble: 93 × 5 ## Manufacturer Man.trans.avail MPG.highway EngineSize Cylinders ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Acura Yes 31 1.8 4 ## 2 Acura Yes 25 3.2 6 ## 3 Audi Yes 26 2.8 6 ## # ℹ 90 more rows cars_99 |&gt; print(n = 3) ## # A tibble: 117 × 5 ## manufacturer trans hwy displ cyl ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 audi auto(l5) 29 1.8 4 ## 2 audi manual(m5) 29 1.8 4 ## 3 audi auto(l5) 26 2.8 6 ## # ℹ 114 more rows cars_93과 cars_99의 변수들은 이름은 다르지만, 동일한 내용의 변수들이 순서대로 나열되어 있다. cars_93의 변수 이름을 cars_99의 변수 이름과 같아지도록 변경해 보자. 변경된 결과는 다음과 같다. cars_93 |&gt; print(n = 3) ## # A tibble: 93 × 5 ## manufacturer trans hwy displ cyl ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 Acura Yes 31 1.8 4 ## 2 Acura Yes 25 3.2 6 ## 3 Audi Yes 26 2.8 6 ## # ℹ 90 more rows cars_93의 변수 manufacturer와 trans의 자료를 변경해 보자. 우선 manufacturer의 자료 값을 모두 소문자로 변경하고, trans는 자료 값이 Yes이면 manual로, 아니면 auto로 변경하며, 요인 속성은 유지하도록 한다. 변경된 결과는 다음과 같다. cars_93 |&gt; print(n = 3) ## # A tibble: 93 × 5 ## manufacturer trans hwy displ cyl ## &lt;chr&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 acura manual 31 1.8 4 ## 2 acura manual 25 3.2 6 ## 3 audi manual 26 2.8 6 ## # ℹ 90 more rows cars_93에서 변수 trans와 cyl의 조합에 따른 빈도수를 구하고 다음과 같이 내림차순으로 출력해 보자. ## # A tibble: 9 × 3 ## trans cyl n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 manual 4 43 ## 2 auto 6 20 ## 3 manual 6 11 ## 4 auto 4 6 ## 5 auto 8 6 ## 6 manual 3 3 ## 7 manual 5 2 ## 8 manual 8 1 ## 9 manual rotary 1 앞 문제의 출력 결과를 보면 trans가 manual이고 cyl이 3, 5, 8, rotary인 경우에 해당하는 케이스는 제거하는 것이 좋을 것으로 보인다. cars_93에서 해당 케이스를 제거하라. cars_99의 변수들을 변경해 보자. 변수 trans는 자료 중 auto(l3), auto(l4), auto(l5)는 auto로 통합하고, manual(m5)와 manual(m6)는 manual로 통합한다. 또한 hwy와 displ을 제외한 다른 변수는 모두 요인으로 변경한다. 변경된 결과는 다음과 같다. cars_99 |&gt; print(n = 3) ## # A tibble: 117 × 5 ## manufacturer trans hwy displ cyl ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 audi auto 29 1.8 4 ## 2 audi manual 29 1.8 4 ## 3 audi auto 26 2.8 6 ## # ℹ 114 more rows cars_99의 manufacturer에는 몇 종류의 자동차 회사가 입력되어 있는가? cars_99의 manufacturer에 입력된 자동차 회사 중 상대도수가 0.1 이상인 회사를 찾아내서 다음과 같이 출력해 보자. 변수 prop에는 상대도수의 계산 결과가 입력되어 있다. ## # A tibble: 4 × 3 ## manufacturer n prop ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; ## 1 toyota 20 0.2 ## 2 dodge 16 0.16 ## 3 volkswagen 16 0.16 ## 4 ford 15 0.15 두 연속형 변수 displ과 hwy의 관계에서 범주형 변수 cyl이 미치는 영향을 확인하기 위한 그래프를 작성해 보자. 변수 hwy에는 반올림 처리가 된 값을 입력했기 때문에 산점도에서 점이 겹쳐지는 문제를 해결해야 한다. cars_93에 대해서는 cyl의 그룹별 두 연속형 변수의 산점도를 각각 작성한다. 그림 5.65: cars_93의 세 변수 관계 그래프 cars_99에 대해서는 두 연속형 변수의 산점도 점 모양과 색을 cyl의 값에 다르게 작성 그림 5.66: cars_99의 세 변수 관계 그래프 두 데이터 프레임 cars_93와 cars_99에 있는 변수 displ과 hwy의 관계를 하나의 그래프에 나타내 보자. 변수 displ과 hwy에 대한 회귀직선을 추가한 산점도를 작성하되 각 자료가 속한 데이터 프레임에 따라 점과 직선의 색을 구분하여 다음과 같이 작성해 보자. 그림 5.67: cars_93와 cars_99의 displ과 hwy의 관계 그래프 두 데이터 프레임 cars_93와 cars_99에 있는 변수 trans와 hwy의 관계를 나타내는 그래프를 작성해 보자. 변수 trans의 그룹별로 cars_93와 cars_99의 hwy에 대한 상자그림을 다음과 같이 작성해 보자. 그림 5.68: cars_93와 cars_99의 trans와 hwy의 관계 그래프 5. 다음은 Wikipedia에서 우리나라의 2012년 20개 주요 수출품목 자료가 있는 웹 페이지(https://en.wikipedia.org/wiki/List_of_exports_of_South_Korea) 에 있는 HTML 테이블의 일부분이다. 대한민국 주요 수출품목 HTML 테이블을 R로 불러와 다음과 같이 출력해 보자. 변수 value는 각 품목의 수출액이고, 변수 prop는 각 품목의 수출액이 20개 전체 품목의 총 수출액에서 차지하는 비율을 나타내고 있다. 단, 변환과정에서는 dplyr의 함수들을 사용한다. ## # A tibble: 20 × 4 ## rank item value prop ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Refined petroleum 51540 0.162 ## 2 2 Integrated circuits 49126 0.155 ## 3 3 Cars 42484 0.134 ## 4 4 Passenger and Cargo Ships 29010 0.0914 ## 5 5 LCDs 23978 0.0756 ## 6 6 Car parts 20496 0.0646 ## 7 7 Broadcasting Equipment 15443 0.0487 ## 8 8 Broadcasting Accessories 10532 0.0332 ## 9 9 Telephones 10417 0.0328 ## # ℹ 11 more rows 각 품목별 수출액을 다음과 같은 형태의 막대그래프로 표현해 보자. 단, 범주 OTHERS는 수출액 비율이 2% 미만인 품목, 즉 변수 prop의 값이 0.02 미만인 품목을 통합한 범주이다. export |&gt; mutate(item = if_else(prop &gt;= 0.02, item, &quot;OTHERS&quot;)) |&gt; ggplot(aes(y = reorder(item, value), x = value)) + geom_bar(stat = &quot;identity&quot;) + labs(y = NULL, x = NULL) + theme_bw() 그림 5.69: 대한민국 주요 수출품목 및 수출액 막대그래프 "],["ch6.html", "6 장 Tidyverse를 활용한 데이터 다루기 6.1 tidyr로 tidy 데이터 만들기 6.2 dplyr에 의한 데이터 결합 6.3 stringr에 의한 문자 다루기", " 6 장 Tidyverse를 활용한 데이터 다루기 R의 모습은 tidyverse 이전과 이후로 완전히 구분된다고 할 수 있다. 데이터 다루기와 그래프 성능이 비교할 수 없을 만큼 향상되었고, 복잡한 분석 과정이 대폭 단순화되어 매우 효율적인 분석이 가능해졌다. 이러한 발전으로 인하여 Data science를 위한 최적의 프로그램으로 자리매김을 확고하게 했다고 할 수 있다. 이 장에서는 core tidyverse에 속한 패키지 중 자료의 형태를 통계분석이 가능하도록 다듬는 작업에 사용되는 tidyr, 문자 다루기에 유용한 stringr, 그리고 자료 결합에 유용한 dplyr에 속한 몇몇 함수들의 사용법을 살펴보겠다. 6.1 tidyr로 tidy 데이터 만들기 Tidy 데이터 세트는 하나의 열이 한 변수의 자료로만 이루어져 있고, 하나의 행은 한 관찰값의 자료로만 이루어져 있는 데이터 세트를 의미한다. Tidy 자료의 예로서 패키지 tidyr에 있는 데이터 프레임 table1을 살펴보자. library(tidyverse) table1 ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 적절한 통계분석을 실시하기 위해 반드시 갖추어야 할 데이터 세트의 형태라고 할 수 있다. 하지만 실제 접하게 될 데이터 세트는 tidy 데이터가 아닌 경우가 상당히 많이 있으며, 이런 경우 데이터 세트를 통계분석이 가능한 형태로 변경하는데 많은 시간과 노력이 필요하게 된다. 패키지 tidyr은 통계분석이 불가능한 온갖 형태의 데이터 세트를 tidy 데이터 세트로 전환하는 작업을 수행하기 위한 패키지이다. 6.1.1 데이터 피벗: pivot_longer()와 pivot_wider() 통계분석이 불가능한 형태의 데이터 세트가 공통적으로 가지고 있는 주된 문제는 다음과 같다. 한 변수의 자료가 여러 개의 열에 입력되어 있다. 한 관찰값의 자료가 여러 개의 행에 입력되어 있다. 첫 번째 문제는 여러 열에 입력된 한 변수의 자료를 하나의 열로 모아야 해결된다. 따라서 원래 데이터 프레임보다 열의 개수가 줄어든 형태, 즉 더 길어진 형태의 데이터 프레임으로 변환시키는 작업이 되며, 함수 pivot_longer()로 하게 된다. 두 번째 문제는 하나의 열에 여러 변수의 자료가 입력된 형태가 되는 것이므로 열의 개수를 늘려서 각 변수를 따로따로 입력해야 한다. 따라서 원래 데이터 프레임보다 열의 개수가 늘어난 형태, 즉 더 넓어진 형태의 데이터 프레임으로 변환시키는 작업이 되며, 함수 pivot_wider()로 하게 된다. 1. 함수 pivot_longer() 패키지 tidyr에 있는 데이터 프레임 table4a를 살펴보자. 숫자로 이름이 시작된 두 번째와 세 번째 변수의 이름은 backtick 기호로 감싸져 있다. table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 데이터 프레임 table4a는 table1의 변수 cases가 두 개의 열에 흩어져 입력되어 있는 형태이다. 이것을 table1과 같은 tidy 데이터 형태로 변형하기 위해서는 열 이름인 1999와 2000이 변수 year의 자료가 되어야 하고, 두 열에 흩어진 자료는 변수 cases의 자료가 되어야 한다. 함수 pivot_longer()의 기본적인 사용법은 pivot_longer(data, cols, names_to = “name”, values_to = “value”)이다. data는 피벗 대상이 되는 데이터 프레임이고, cols에는 한 변수의 자료가 흩어져 입력된 열을 &lt;tidy-select&gt; 방식으로 선택하면 된다. 또한 names_to에는 선택된 열들의 이름이 자료로 입력될 새로운 열 이름을 지정하고, values_to에는 흩어진 자료들을 하나로 합쳐서 입력할 열 이름을 지정하는 것이다. table4a %&gt;% pivot_longer(-country, names_to = &quot;year&quot;, values_to = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 ## 2 Afghanistan 2000 2666 ## 3 Brazil 1999 37737 ## 4 Brazil 2000 80488 ## 5 China 1999 212258 ## 6 China 2000 213766 다른 예제로 데이터 프레임 df_1에 어떤 제품의 3년간 분기별 판매량이 입력되어 있다고 하자. df_1 &lt;- tibble(Year = 2015:2017, Q1 = c(15, 12, 22), Q2 = c(16, 13, 23), Q3 = c(19, 27, 24), Q4 = c(17, 23, 20)) df_1 ## # A tibble: 3 × 5 ## Year Q1 Q2 Q3 Q4 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 15 16 19 17 ## 2 2016 12 13 27 23 ## 3 2017 22 23 24 20 df_1은 시계열 자료를 표현할 때 일반적으로 사용되는 형태로 구성되어 있다. 그러나 판매량이라는 한 변수의 자료가 4개의 열에 흩어져 있어서 tidy 데이터의 형태는 아니며, 이것을 tidy 데이터로 변환하는 과정은 다음과 같다. df_1 %&gt;% pivot_longer(-Year, names_to = &quot;Qtr&quot;, values_to = &quot;Sales&quot;) ## # A tibble: 12 × 3 ## Year Qtr Sales ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2015 Q1 15 ## 2 2015 Q2 16 ## 3 2015 Q3 19 ## 4 2015 Q4 17 ## 5 2016 Q1 12 ## 6 2016 Q2 13 ## 7 2016 Q3 27 ## 8 2016 Q4 23 ## 9 2017 Q1 22 ## 10 2017 Q2 23 ## 11 2017 Q3 24 ## 12 2017 Q4 20 조금 더 복잡한 예를 살펴보자. 데이터 프레임 tidyr::billboard에는 2000년 Billboard Top 100에 오른 노래의 가수(artist)와 노래 제목(track), top 100 리스트에 들어간 날짜(date.entered), 그리고 리스트에 오른 이후의 매주 순위가 변수wk1부터 wk76까지 입력되어 있다. 해당 노래가 top 100 리스트에서 제외되면 NA가 입력되기 때문에, 변수 wk1부터 wk76에는 NA가 많이 입력되어 있다. 특히 wk66부터 wk76까지는 모든 자료가 NA로 입력되어서 변수 유형이 논리형으로 되어 있다. 우리가 원하는 첫 번째 분석은 매주 연속해서 top 100에 올라있던 노래만을 대상으로 리스트에 머물러 있던 최장 기간과 그 기간 중 최고 순위를 알아내는 것이다. billboard %&gt;% print(n = 5) ## # A tibble: 317 × 79 ## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby… 2000-02-26 87 82 72 77 87 94 99 NA ## 2 2Ge+her The … 2000-09-02 91 87 92 NA NA NA NA NA ## 3 3 Doors Do… Kryp… 2000-04-08 81 70 68 67 66 57 54 53 ## 4 3 Doors Do… Loser 2000-10-21 76 76 72 69 67 65 55 59 ## 5 504 Boyz Wobb… 2000-04-15 57 34 25 17 17 31 36 49 ## # ℹ 312 more rows ## # ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, ## # wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, ## # wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, ## # wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, ## # wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, ## # wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, … 이런 구조의 데이터는 매우 흔하게 볼 수 있는 것이며, tidy 데이터 구조로 오해하기도 한다. 그러나 변수 wk1부터 wk76은 모두 노래의 ’순위’이기 때문에 하나의 열에 입력이 되어야 적절한 통계분석이 가능하게 된다. 따라서 열 wk1부터 wk76까지에 입력된 자료는 rank라는 이름의 열로 모으고, 열의 이름은 week라는 이름의 열에 입력해 보자. 이 변환 작업은 cols에 wk1:wk76 또는 starts_with(\"wk\")를, names_to에 \"week\"를, 그리고 values_to에 \"rank\"를 각각 지정하면 된다. billboard %&gt;% pivot_longer( cols = wk1:wk76, names_to = &quot;week&quot;, values_to = &quot;rank&quot; ) %&gt;% print(n = 5) ## # A tibble: 24,092 × 5 ## artist track date.entered week rank ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 ## # ℹ 24,087 more rows 변수 week에는 문자형 자료가 입력되어 있는데, 정수형으로 전환되면 더 효과적인 분석이 가능할 것이다. 정수형으로 전환하기 위해서는 문자열 “wk”를 제거하고, 변수의 유형을 정수형으로 바꾸면 된다. 이 작업은 함수 mutate()와 gsub(), as.integer()를 이용해도 가능하지만, 함수 pivot_longer()에서 names_prefix와 names_transform를 사용해도 전환할 수 있다. names_prefix에는 names_to에 입력된 열 이름에서 제거하려는 문자열을 정규표현식으로 지정하면 되는데, 첫 문자부터 제거하는 경우에만 적용이 된다. 이 경우에는 그냥 \"wk\"를 지정하면 된다. names_transform은 열의 유형을 변경할 때 사용하는 것으로 열이름 = 유형 변환 함수가 입력된 리스트를 지정하면 된다. top_100 &lt;- billboard %&gt;% pivot_longer( cols = wk1:wk76, names_to = &quot;week&quot;, names_prefix = &quot;wk&quot;, names_transform = list(week = as.integer), values_to = &quot;rank&quot;, values_drop_na = TRUE ) top_100 %&gt;% print(n=5) ## # A tibble: 5,307 × 5 ## artist track date.entered week rank ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 1 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 2 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 3 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 4 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 5 87 ## # ℹ 5,302 more rows 옵션 values_drop_na에 TRUE를 지정하면 values_to로 지정된 열에 NA가 입력되는 행은 자동으로 제거된다. 자료의 특성으로 NA가 많을 수밖에 없는 경우에는 필요한 옵션이 된다. 이제 데이터 프레임 top_100을 대상으로 원하는 분석을 할 수 있게 되었다. 매주 연속해서 top 100에 올라있던 노래만을 대상으로 리스트에 머물러 있던 최장 기간과 그 기간 중 최고 순위는 다음과 같이 알아볼 수 있다. top_100 %&gt;% group_by(artist, track) %&gt;% filter(n() == max(week)) %&gt;% summarise(period = max(week), top_rank = min(rank)) %&gt;% ungroup() %&gt;% arrange(desc(period)) %&gt;% print(n=5) ## # A tibble: 302 × 4 ## artist track period top_rank ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 3 Doors Down Kryptonite 53 3 ## 2 Hill, Faith Breathe 53 2 ## 3 Creed With Arms Wide Open 47 1 ## 4 Joe I Wanna Know 44 4 ## 5 Vertical Horizon Everything You Want 41 1 ## # ℹ 297 more rows 두 번째 분석으로써 연속해서 1위를 유지했던 노래 중 가장 오랫동안 정상을 유지했던 2곡을 알아보자. top_100 %&gt;% filter(rank == 1) %&gt;% group_by(artist, track) %&gt;% filter((max(week) - min(week) + 1) == n()) %&gt;% count(sort = TRUE) %&gt;% print(n=2) ## # A tibble: 16 × 3 ## # Groups: artist, track [16] ## artist track n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Destiny&#39;s Child Independent Women Pa... 11 ## 2 Santana Maria, Maria 10 ## # ℹ 14 more rows 2. 함수 pivot_wider() 패키지 tidyr에 있는 데이터 프레임 table2를 살펴보자. table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table2는 개별 국가에 대한 연간 자료인데, 이것이 두 개의 행에 나뉘어 입력되어 있다. 따라서 하나의 열(type)에 두 변수(cases와 population)의 자료가 입력되어 있는 것이다. 이렇게 하나의 열에 입력된 여러 변수의 자료를 분산시키는 작업은 함수 pivot_wider()로 할 수 있다. 기본적인 사용법은 pivot_wider(data, names_from = name, values_from = value)이다. data는 피벗 대상이 되는 데이터 프레임이고, names_from과values_from에는 새롭게 추가되는 열들의 이름이 입력되어 있는 열과 자료가 입력되어 있는 열을 각각 지정하는 것이다. table2의 경우에는 type에 열들의 이름이 입력되어 있고, 자료는 count에 입력되어 있기 때문에, names_from에는 type을, values_from에는 count를 각각 지정하면 된다. table2 %&gt;% pivot_wider(names_from = type, values_from = count) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 다른 예제로 세 명의 신장과 체중을 입력한 데이터 프레임 df_2를 만들어 보자. df_2 &lt;- tibble(Name = rep(c(&quot;Kim&quot;,&quot;Park&quot;,&quot;Lee&quot;), each = 2), type = rep(c(&quot;Height&quot;,&quot;Weight&quot;), times = 3), measure = c(170, 75, 165, 63, 175, 85) ) df_2 ## # A tibble: 6 × 3 ## Name type measure ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Kim Height 170 ## 2 Kim Weight 75 ## 3 Park Height 165 ## 4 Park Weight 63 ## 5 Lee Height 175 ## 6 Lee Weight 85 df_2는 세 명의 신장과 체중에 대한 자료이다. 같은 행에 입력되어야 할 한 사람의 자료가 두 행에 나뉘어져 입력되어서, 한 열에 두 변수의 자료가 입력되었다. df_2를 tidy 데이터로 변환하는 과정은 다음과 같다. df_2 %&gt;% pivot_wider(names_from = type, values_from = measure) ## # A tibble: 3 × 3 ## Name Height Weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Kim 170 75 ## 2 Park 165 63 ## 3 Lee 175 85 다른 예제로 tidyr::fish_encounters를 살펴보자. 이 데이터 프레임은 태그를 부착한 19마리 물고기(fish)가 어떤 강을 따라 이동하는 동안 특정 지점(station)에서 움직임이 관측됐는지 여부(seen)를 기록한 자료이다. 움직임이 관측된 station만 자료에 나타나 있어서 변수 seen은 모든 행에서 1을 값으로 갖고 있다. fish_encounters %&gt;% print(n = 5) ## # A tibble: 114 × 3 ## fish station seen ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 4842 Release 1 ## 2 4842 I80_1 1 ## 3 4842 Lisbon 1 ## 4 4842 Rstr 1 ## 5 4842 Base_TD 1 ## # ℹ 109 more rows 물고기의 움직임이 관측되지 않은 지점에 대한 자료도 중요한 정보를 담고 있다고 할 수 있는데, 지금의 구조에서는 그 정보를 얻을 수 없게 되어 있다. 물고기마다 모든 지점에서의 움직임 관측 여부를 표현하기 위해서는 변수 station에 입력된 각 지점이 변수로 전환되어야 한다. fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen ) %&gt;% print(n = 5) ## # A tibble: 19 × 12 ## fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4842 1 1 1 1 1 1 1 1 1 1 1 ## 2 4843 1 1 1 1 1 1 1 1 1 1 1 ## 3 4844 1 1 1 1 1 1 1 1 1 1 1 ## 4 4845 1 1 1 1 1 NA NA NA NA NA NA ## 5 4847 1 1 1 NA NA NA NA NA NA NA NA ## # ℹ 14 more rows 움직임이 관측되지 않은 지점에 대해서는 입력된 자료가 없기 때문에 해당 위치에 NA가 표시되었다. 하지만 관측이 안된 것은 변수 seen의 값이 0이 되는 것이므로 NA를 0으로 바꾸는 것이 더 좋을 것이다. 이렇게 열을 확장하는 과정에서 발생할 수 있는 NA 대신 다른 값을 입력해야 할 때에는 옵션 values_fill에 대신 입력하려는 값을 지정하면 된다. fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen, values_fill = 0 ) %&gt;% print(n = 5) ## # A tibble: 19 × 12 ## fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4842 1 1 1 1 1 1 1 1 1 1 1 ## 2 4843 1 1 1 1 1 1 1 1 1 1 1 ## 3 4844 1 1 1 1 1 1 1 1 1 1 1 ## 4 4845 1 1 1 1 1 0 0 0 0 0 0 ## 5 4847 1 1 1 0 0 0 0 0 0 0 0 ## # ℹ 14 more rows 6.1.2 문자형 열의 결합과 분리: separate()와 unite() 하나의 문자형 열에 입력된 자료를 몇 개의 열로 분산시키거나, 또는 몇 개의 열에 입력되어 있는 자료를 하나의 열로 합치는 것은 빈번히 이루어지는 필수적인 작업은 아니지만, 나름의 의미가 있는 필요한 작업이다. 1. 함수 separate() 패키지 tidyr에 있는 데이터 프레임 table3를 살펴보자. table3 ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3는 table1의 변수 cases와 population의 자료가 rate 열에 함께 입력되어 있다. 함수 separate()로 자료를 분리하여 두 열에 나누어 입력하는 작업을 진행해 보자. 기본적인 사용법은 separate(data, col, into)이다. data는 형태를 변형할 데이터 프레임이고, 자료가 함께 입력되어 있는 열은 col에 지정하며, 자료를 분리하여 따로 입력할 열 이름을 into에 지정한다. table3의 경우에는 rate가 분리 대상이 되는 열이므로 col에 지정하고, 분리된 자료를 입력할 열의 이름인 cases와 population을 into에 지정하면 된다. table3 %&gt;% separate(col = rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 새롭게 생성된 두 변수 cases와 population의 자료 유형을 살펴보면 자료는 정수이지만, 유형은 문자라는 것을 알 수 있다. 이것은 분리 전 rate 열의 유형이 문자이기 때문인데, 분리 후 자료의 유형을 정수로 바꾸기 위해서는 convert=TRUE를 추가로 입력해야 한다. table3 %&gt;% separate(col = rate, into = c(&quot;cases&quot;,&quot;population&quot;), convert = TRUE) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 함수 separate()가 하나의 열에 함께 입력된 자료를 분리하는 디폴트 방식은 col에 지정된 열의 자료 중 숫자나 문자가 아닌 기호가 있으면 그것을 기준으로 분리하는 것이다. table3의 경우에는 rate 열의 두 자료를 빗금을 기준으로 구분하였다. 만일 특정 문자 또는 기호를 구분자로 사용하고자 한다면 sep에 지정하면 된다. 예제 자료로 다음의 df_3를 만들어 보자. df_3 &lt;- tribble(~Date, ~Sales, &quot;2015-Qtr.1&quot;, 15, &quot;2015-Qtr.2&quot;, 16, &quot;2015-Qtr.3&quot;, 19, &quot;2015-Qtr.4&quot;, 17) df_3 ## # A tibble: 4 × 2 ## Date Sales ## &lt;chr&gt; &lt;dbl&gt; ## 1 2015-Qtr.1 15 ## 2 2015-Qtr.2 16 ## 3 2015-Qtr.3 19 ## 4 2015-Qtr.4 17 Date 열에는 년도와 분기가 대시(-)로 구분되어 있으며, 분기 자료에 점(.)이 포함되어 있다. Date의 자료를 년도와 분기로 분리하기 위해서는 옵션 sep에 대시(-)를 지정해야 한다. 만일 sep를 따로 지정하지 않으면 대시와 점이 모두 분리 기준이 되어서 세 개의 열로 분리된다. df_3 %&gt;% separate(col = Date, into = c(&quot;year&quot;, &quot;Qtr&quot;), sep = &quot;-&quot;, convert = TRUE) ## # A tibble: 4 × 3 ## year Qtr Sales ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2015 Qtr.1 15 ## 2 2015 Qtr.2 16 ## 3 2015 Qtr.3 19 ## 4 2015 Qtr.4 17 자료 분리의 기준을 특정 기호가 아닌 위치로도 할 수 있다. 분리 위치는 정수로 나타내는데, 양의 정수는 자료의 왼쪽 끝을 기준으로 하는 위치로서 왼쪽 끝이 1이 된다. 음의 정수는 자료의 오른쪽 끝을 기준으로 하는 위치로서 오른쪽 끝이 -1이 된다. 예제 자료로 다음의 df_4를 만들어 보자. df_4 &lt;- tribble(~Date, ~Sales, &quot;2015Q1&quot;, 15, &quot;2015Q2&quot;, 16, &quot;2015Q3&quot;, 19, &quot;2015Q4&quot;, 17) df_4 ## # A tibble: 4 × 2 ## Date Sales ## &lt;chr&gt; &lt;dbl&gt; ## 1 2015Q1 15 ## 2 2015Q2 16 ## 3 2015Q3 19 ## 4 2015Q4 17 Date 열의 자료를 년도와 분기로 구분해 보자. 분리 기준 위치는 왼쪽 끝부터는 4번째 자리이고 오른쪽 끝부터는 2번째 자리가 된다. 따라서 sep에 4 또는 -2를 지정하면 된다. df_4 %&gt;% separate(col = Date, into = c(&quot;year&quot;,&quot;Qtr&quot;), sep = 4) ## # A tibble: 4 × 3 ## year Qtr Sales ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2015 Q1 15 ## 2 2015 Q2 16 ## 3 2015 Q3 19 ## 4 2015 Q4 17 df_4 %&gt;% separate(col = Date, into = c(&quot;year&quot;,&quot;Qtr&quot;), sep = -2) ## # A tibble: 4 × 3 ## year Qtr Sales ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2015 Q1 15 ## 2 2015 Q2 16 ## 3 2015 Q3 19 ## 4 2015 Q4 17 2. 함수 unite() 패키지 tidyr의 데이터 프레임 table5를 살펴보자. 년도가 century 열과 year 열로 분리되어 있는데, 이것을 하나로 합쳐보자. table5 ## # A tibble: 6 × 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 함수 unite()는 여러 열의 자료를 하나의 열로 합쳐야 할 때 사용되며, 기본적인 사용 법은 unite(data, col, ..., sep=\"_\")이다. col에는 합쳐서 새롭게 생성될 열의 이름을 지정하고, 이어서 합쳐질 열을 나열하면 된다. 열의 나열은 &lt;tidy-select&gt; 방식을 사용할 수 있다. table5 %&gt;% unite(col = year, century, year) ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19_99 745/19987071 ## 2 Afghanistan 20_00 2666/20595360 ## 3 Brazil 19_99 37737/172006362 ## 4 Brazil 20_00 80488/174504898 ## 5 China 19_99 212258/1272915272 ## 6 China 20_00 213766/1280428583 하나의 열에 합쳐진 여러 열의 자료는 밑줄로 구분되는 것이 디폴트인데, 이것을 제거하려면 sep = \"\"을 입력하면 된다. table5 %&gt;% unite(col = year, century, year, sep = &quot;&quot;) ## # A tibble: 6 × 3 ## country year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 변수 year에 입력된 자료가 정수이지만 유형은 문자이고, rate 열에는 두 변수의 자료가 함께 입력되어 있다. 변수 year의 유형을 정수로 변환하고, 이어서 rate 열의 자료를 분리하여 tidy 데이터로 변환시켜 보자. table5 %&gt;% unite(col = year, century, year, sep = &quot;&quot;) %&gt;% separate(col = rate, into = c(&quot;cases&quot;,&quot;population&quot;), convert = TRUE) %&gt;% mutate(year = as.integer(year)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 6.2 dplyr에 의한 데이터 결합 몇 개의 파일로 분산 정리되어 있는 데이터를 하나의 데이터 프레임으로 통합하는 것은 본격적인 통계분석을 실시하기 전에 반드시 마무리해야 되는 작업이다. 이러한 데이터 프레임의 통합 작업은 base R 함수인 merge()로도 할 수 있으나, 더 개선된 기능을 갖고 있는 함수가 패키지 dplyr에 있다. 1. Mutating joins 두 데이터 프레임을 대상으로 기준 열(key)을 이용한 수평적 결합으로 변수를 확대하는 방식의 결합 방법을 의미한다. 함수 mutate()에서와 같이 결합으로 새로 추가되는 변수는 결합되는 데이터 프레임의 마지막 변수가 된다. 기준 열을 이용한 두 데이터 프레임의 수평적 결합이란 key 변수의 값이 같은 행을 결합하는 것을 의미하는 것으로써, 원하는 결합 방식에 따라 다른 함수를 사용해야 한다. 예를 들어 데이터 프레임 df1과 df2를 결합한다고 할 때, 통합된 데이터 프레임이 어떤 행(관찰값)을 유지하게 할 것인가에 따라 다음 4가지 함수 중 하나를 사용하면 된다. 함수 inner_join(df1, df2): df1과 df2에 공통적으로 존재하는 행만 유지 함수 left_join(df1, df2): df1에 있는 모든 행 유지 함수 right_join(df1, df2): df2에 있는 모든 행 유지 함수 full_join(df1, df2): df1과 df2에 있는 모든 행 유지 패키지 dplyr에 있는 데이터 프레임 band_members와 band_instruments를 살펴보자. 두 데이터 프레임에는 Beatles와 Rolling Stones 그룹 멤버 중 몇 명의 이름과 그들이 그룹에서 연주하는 악기가 정리되어 있다. library(tidyverse) band_members ## # A tibble: 3 × 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments ## # A tibble: 3 × 2 ## name plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar Key 변수는 옵션 by에 지정하면 된다. 위의 예에서 두 데이터 프레임에 공통적으로 들어있는 변수 name을 key 변수로 지정하면 되는데, by = \"name\"과 같이 변수 이름을 인용 부호로 감싸고 지정하면 된다. 옵션 by가 생략되면 두 데이터 프레임에 공통적으로 있는 이름이 같은 변수가 key가 되며, 이름이 같은 변수가 없으면 통합이 이루어지지 않는다. 또한 결합 대상이 되는 두 데이터 프레임에서 사용할 key 변수가 서로 이름이 다른 경우에는 by = c(\"x\" = \"y\")와 같이 지정하면 된다. 첫 번째 데이터 프레임의 변수 x와 두 번째 데이터 프레임의 변수 y가 key 변수로 지정되어 결합이 이루어지며, 결합된 데이터 프레임의 key 변수 이름은 첫 번째 데이터 프레임의 key 변수인 x가 된다. 이제 함수 inner_join()에 의한 결과를 살펴보자. band_members %&gt;% inner_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 2 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass 통합 결과로 변수는 3개가 되었고, 관찰값은 두 데이터 프레임에 공통적으로 포함된 2개만 유지가 되었다. 이와 같이 공통적으로 포함된 관찰값만 유지하는 결합 방법은 너무 많은 데이터를 잃어버릴 수 있는 것이어서 매우 신중하게 사용해야 하는 방법이 된다. 다음은 함수 left_join()에 의한 결과를 살펴보자. band_members %&gt;% left_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 3 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass band_members에 있는 관찰값은 모두 유지가 된 상태에서 band_instruments에 있는 변수 plays가 새로운 변수로 추가되었다. 만일 첫 번째 데이터 프레임이 주로 분석에 사용되는 데이터 프레임이고, 두 번째 데이터 프레임에 있는 변수를 첫 번째 데이터 프레임에 추가하는 작업을 하고자 한다면 적절하게 사용될 수 있는 함수이다. 함수 right_join()은 두 번째 데이터 프레임이 주로 분석에 사용되는 데이터 프레임이고 첫 번째 데이터 프레임에 있는 변수를 추가하고자 할 때 사용할 수 있는 함수이다. band_members %&gt;% right_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 3 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles guitar ## 2 Paul Beatles bass ## 3 Keith &lt;NA&gt; guitar 두 번째 데이터 프레임인 band_instuments에 있는 관찰값은 모두 유지가 되었고, 첫번째 데이터 프레임인 band_members에 없는 마지막 관찰값의 경우에는 추가된 변수 band에 NA가 할당되었다. 이번에는 함수 full_join()에 의한 결과를 살펴보자. band_members %&gt;% full_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 4 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass ## 4 Keith &lt;NA&gt; guitar 두 데이터 프레임에 있는 모든 관찰값이 유지되었다. 만일 행(관찰값)과 열(변수)을 모두 확장하는 방향으로 두 데이터 프레임을 결합을 하고자 한다면 가장 적절하게 사용할 수 있는 함수이다. 이번에는 데이터 프레임 band_members와 band_instruments2를 결합해 보자. band_members ## # A tibble: 3 × 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones ## 2 John Beatles ## 3 Paul Beatles band_instruments2 ## # A tibble: 3 × 2 ## artist plays ## &lt;chr&gt; &lt;chr&gt; ## 1 John guitar ## 2 Paul bass ## 3 Keith guitar band_members의 name과 band_instruments2의 artist를 key 변수로 사용해야 하는 경우가 된다. 함수 left_join()의 결과만 살펴보자. band_members %&gt;% left_join(band_instruments2, by = c(&quot;name&quot; = &quot;artist&quot;)) ## # A tibble: 3 × 3 ## name band plays ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones &lt;NA&gt; ## 2 John Beatles guitar ## 3 Paul Beatles bass 2. Filtering joins 많은 경우 데이터 프레임의 결합은 행 또는 열을 확대하는 방향으로 이루어진다. 하지만 어떤 경우에는 다른 데이터 프레임과 공통적으로 갖고 있는 행(관찰값)만을 유지하거나 공통적으로 갖고 있는 행을 삭제해야 할 때가 있다. 이러한 결합을 위해 사용할 수 있는 함수가 다음과 같다. 함수 semi_join(df1, df2): df1의 행 중에 df2에 있는 모든 행 유지 함수 anti_join(df1, df2): df1의 행 중에 df2에 있는 모든 행 삭제 예를 들어 band_members와 band_instruments를 대상으로 두 함수를 적용한 결과는 다음과 같다. band_members %&gt;% semi_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 2 × 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 John Beatles ## 2 Paul Beatles band_members %&gt;% anti_join(band_instruments, by = &quot;name&quot;) ## # A tibble: 1 × 2 ## name band ## &lt;chr&gt; &lt;chr&gt; ## 1 Mick Stones 함수 semi_join()에 의한 결합은 band_members의 행 중에 band_instruments에도 있는 두 행만을 유지한 결과를 보여주고 있으며, 함수 anti_join()은 band_instruments에 없는 하나의 행만을 선택했음을 보여주고 있다. 3. 단순 수평 결합 및 수직 결합 결합되는 데이터 프레임들이 행의 개수가 같고 각 행의 자료가 동일한 대상인 경우에는 데이터 프레임을 옆으로 붙여서 변수를 확대할 수 있다. 이 경우에 사용할 수 있는 함수가 bind_cols()이다. 대응되는 base R 함수는 cbind()이다. df_x &lt;- tibble(x1 = letters[1:3], x2 = 1:3) df_y &lt;- tibble(y1 = LETTERS[4:6], y2 = 4:6) df_z &lt;- tibble(x1 = LETTERS[4:6], x2 = 4:6) df_x ## # A tibble: 3 × 2 ## x1 x2 ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 df_y ## # A tibble: 3 × 2 ## y1 y2 ## &lt;chr&gt; &lt;int&gt; ## 1 D 4 ## 2 E 5 ## 3 F 6 bind_cols(df_x, df_y) ## # A tibble: 3 × 4 ## x1 x2 y1 y2 ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 a 1 D 4 ## 2 b 2 E 5 ## 3 c 3 F 6 결합되는 데이터 프레임들의 열의 개수 및 이름이 같은 경우에는 위아래로 붙여서 케이스를 확대하는 방향으로 결합할 수 있다. 이런 경우에 사용할 수 있는 함수가 bind_rows()이다. 옵션 .id에 열 이름을 지정하면 각 행이 어떤 데이터 프레임에서 온 것인지를 구분해 주는 열이 첫 번째 열로 추가된다. df_x ## # A tibble: 3 × 2 ## x1 x2 ## &lt;chr&gt; &lt;int&gt; ## 1 a 1 ## 2 b 2 ## 3 c 3 df_z ## # A tibble: 3 × 2 ## x1 x2 ## &lt;chr&gt; &lt;int&gt; ## 1 D 4 ## 2 E 5 ## 3 F 6 bind_rows(df_x, df_z, .id = &quot;df&quot;) ## # A tibble: 6 × 3 ## df x1 x2 ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 a 1 ## 2 1 b 2 ## 3 1 c 3 ## 4 2 D 4 ## 5 2 E 5 ## 6 2 F 6 6.3 stringr에 의한 문자 다루기 Base R에도 함수 nchar()나 paste() 등과 같이 문자열을 다루는 함수들이 있다. 유용하게 사용되는 함수들이지만 함수 이름에 일관성이 없어서 기억하기 쉽지 않다는 문제가 있다. 이에 반하여 패키지 stringr의 함수들은 모두 str_로 시작되며, 비교적 어렵지 않게 의미를 파악할 수 있는 이름을 갖고 있어서, 주어진 상황에 필요한 함수가 무엇인지 상대적으로 기억하기 쉽다는 장점이 있다. 6.3.1 stringr의 함수 \\(\\bullet\\) str_length() : 문자열의 문자 개수 세기 문자열을 구성하는 문자의 개수를 세는 함수이며, base R에서 대응되는 함수는 nchar()이다. library(tidyverse) str_length(c(&quot;Park&quot;,&quot;Lee&quot;,&quot;Oh&quot;, NA)) ## [1] 4 3 2 NA str_length(&quot;응용통계학과&quot;) ## [1] 6 \\(\\bullet\\) str_c(): 문자열의 결합 문자열 및 문자형 벡터의 결합에 사용되는 함수이며, base R에서 대응되는 함수는 paste0()이다. str_c(&quot;Stat&quot;, 1:3) ## [1] &quot;Stat1&quot; &quot;Stat2&quot; &quot;Stat3&quot; str_c(&quot;Stat&quot;, 1:3, sep = &quot;-&quot;) ## [1] &quot;Stat-1&quot; &quot;Stat-2&quot; &quot;Stat-3&quot; 옵션 collapse를 사용하면 문자형 벡터를 구성하는 문자열을 하나로 묶는 작업을 할 수 있다. str_c(letters, collapse = &quot;&quot;) ## [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; str_c(letters[1:5], LETTERS[1:5], collapse = &quot;,&quot;) ## [1] &quot;aA,bB,cC,dD,eE&quot; 문자형 벡터에 NA가 있는 경우에는 다른 문자형 벡터와의 결합 결과도 당연히 NA가 된다. x &lt;- c(&quot;Stat&quot;, &quot;Math&quot;, NA) str_c(x, 1:3, sep = &quot;/&quot;) ## [1] &quot;Stat/1&quot; &quot;Math/2&quot; NA 만일 결측값 NA를 문자열 \"NA\"로 표시하고자 한다면 함수 str_replace_na()를 사용하면 된다. (y &lt;- str_replace_na(x)) ## [1] &quot;Stat&quot; &quot;Math&quot; &quot;NA&quot; str_c(y, 1:3, sep = &quot;/&quot;) ## [1] &quot;Stat/1&quot; &quot;Math/2&quot; &quot;NA/3&quot; \\(\\bullet\\) str_dup(): 문자열의 반복 주어진 문자열을 반복시켜서 새로운 문자열을 만들 때 편리하게 사용할 수 있는 함수이다. 반복 대상이 되는 문자열 혹은 문자형 벡터를 입력하고 반복시킬 횟수를 times에 지정하면 된다. str_dup(&quot;a&quot;, times = 3) ## [1] &quot;aaa&quot; str_dup(&quot;a&quot;, times = 1:4) ## [1] &quot;a&quot; &quot;aa&quot; &quot;aaa&quot; &quot;aaaa&quot; 반복 대상이 벡터인 경우에는 times에 스칼라 혹은 반복 대상이 되는 벡터와 같은 길이의 숫자형 벡터를 지정해야 한다. str_dup(c(&quot;a&quot;, &quot;b&quot;), times = 3) ## [1] &quot;aaa&quot; &quot;bbb&quot; str_dup(c(&quot;a&quot;, &quot;b&quot;), times = c(2, 3)) ## [1] &quot;aa&quot; &quot;bbb&quot; \\(\\bullet\\) str_sub(): 문자열에서 일부분 선택 주어진 문자열에서 일부분을 추출하거나 혹은 선택한 일부분을 교체하는 작업을 하는 함수이며, 대응되는 R base 함수는 substr()이다. 추출 대상이 되는 문자열을 입력하고 start와 end에 시작점과 끝점의 위치를 나타내는 정수를 지정하면 된다. 양의 정수는 문자열의 왼쪽 끝에서부터의 위치를 나타내고, 음의 정수는 문자열의 오른쪽 끝에서부터의 위치를 나타낸다. 디폴트 값은 start=1L, end=-1L로써, 입력된 문자열 전체가 그대로 출력된다. x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, start = 1, end = 2) ## [1] &quot;Ap&quot; &quot;Ba&quot; &quot;Pe&quot; str_sub(x, start = -2, end = -1) ## [1] &quot;le&quot; &quot;na&quot; &quot;ar&quot; 문자열에서 선택한 일부분을 교체하는 작업은 str_sub() &lt;-의 형식으로 이루어진다. 예를 들어 문자형 벡터 y의 첫 글자를 모두 대문자로 교체해 보자. 영문자를 소문자로 교체하는 작업은 함수 str_to_lower()로 할 수 있고, 대문자로 교체하는 작업은 함수 str_to_upper()로 할 수 있다. y &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_sub(y, 1, 1) &lt;- str_to_upper(str_sub(y, 1, 1)) y ## [1] &quot;Apple&quot; &quot;Banana&quot; &quot;Pear&quot; 이번에는 다음에 주어진 벡터 w의 첫 글자를 제외한 나머지 모든 글자를 소문자로 교체해 보자. w &lt;- c(&quot;APPLE&quot;, &quot;BANANA&quot;, &quot;PEAR&quot;) str_sub(w, 2, -1) &lt;- str_to_lower(str_sub(w, 2, -1)) w ## [1] &quot;Apple&quot; &quot;Banana&quot; &quot;Pear&quot; \\(\\bullet\\) str_split(): 문자열의 분할 하나의 문자열을 여러 개로 분할하는 작업을 하는 함수이며, 대응되는 base R 함수는 strsplit()이다. 분할 대상이 되는 문자열을 입력하고 이어서 분할 기준이 되는 패턴을 입력하면 된다. 옵션 simplify에 TRUE를 지정하면 결과가 행렬로 출력되며, 디폴트인 FALSE가 지정되면 리스트로 출력된다. 다음의 벡터 x의 문자열을 콤마를 기준으로 분리해 보자. x &lt;- c(&quot;New York, NY&quot;, &quot;Ann Arbor, MI&quot;, &quot;Chicago, IL&quot;) str_split(x, &quot;,&quot;) ## [[1]] ## [1] &quot;New York&quot; &quot; NY&quot; ## ## [[2]] ## [1] &quot;Ann Arbor&quot; &quot; MI&quot; ## ## [[3]] ## [1] &quot;Chicago&quot; &quot; IL&quot; str_split(x, &quot;,&quot;, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;New York&quot; &quot; NY&quot; ## [2,] &quot;Ann Arbor&quot; &quot; MI&quot; ## [3,] &quot;Chicago&quot; &quot; IL&quot; 빈칸을 기준으로 문자열을 분리하는 것도 가능하다. 다음의 벡터 y의 문자열을 빈칸을 기준으로 분리해 보자. y &lt;- c(&quot;red apple&quot;, &quot;yellow banana&quot;) str_split(y, &quot; &quot;, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;red&quot; &quot;apple&quot; ## [2,] &quot;yellow&quot; &quot;banana&quot; 벡터 ’y’의 두 문자열은 하나의 빈칸으로 구분되어 있기 때문에 함수 str_split()에 입력되는 패턴은 정확히 하나의 빈칸이 인용 부호로 감싸져 있어야 한다. 만일 두 칸 이상의 빈칸을 패턴으로 입력하면 문자열의 분리는 이루어지지 않는다. str_split(y, &quot; &quot;, simplify = TRUE) ## [,1] ## [1,] &quot;red apple&quot; ## [2,] &quot;yellow banana&quot; 주어진 문자열을 개별 문자로 분리하고자 한다면 인용 부호 사이에 빈칸을 없애고 입력하면 된다. str_split(y, &quot;&quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] ## [1,] &quot;r&quot; &quot;e&quot; &quot;d&quot; &quot; &quot; &quot;a&quot; &quot;p&quot; &quot;p&quot; &quot;l&quot; &quot;e&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;y&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot; &quot;w&quot; &quot; &quot; &quot;b&quot; &quot;a&quot; &quot;n&quot; &quot;a&quot; &quot;n&quot; &quot;a&quot; \\(\\bullet\\) str_replace()와 str_replace_all(): 문자열의 치환 문자열의 일부분을 치환하는 작업을 하는 함수이며, 대응되는 base R 함수로는 sub()와 gsub()이다. 두 함수의 기본적인 사용법은 동일하다. 먼저 문자열 혹은 문자형 벡터를 입력하고 이어서 치환 대상이 되는 패턴을 입력한 후 새롭게 바꾸려는 문자열을 그 다음에 입력하면 된다. 두 함수의 차이는 str_replace()가 지정된 패턴과 첫 번째 매치가 되는 문자열만을 치환하는 데 반하여 str_replace_all()은 패턴과 매치가 되는 모든 문자열을 치환한다는 점이다. 다음의 벡터 x에서 소문자 a를 찾아서 대문자 A로 바꾸는 작업을 두 함수로 각각 시행해 보자. x &lt;- str_c(&quot;banana&quot;, 1:3) str_replace(x, &quot;a&quot;, &quot;A&quot;) ## [1] &quot;bAnana1&quot; &quot;bAnana2&quot; &quot;bAnana3&quot; str_replace_all(x, &quot;a&quot;, &quot;A&quot;) ## [1] &quot;bAnAnA1&quot; &quot;bAnAnA2&quot; &quot;bAnAnA3&quot; 함수 str_replace_all()의 경우에는 문자형 벡터의 각 문자열마다 각기 다른 내용의 치환을 실시할 수 있다. 이 경우에는 치환 대상이 되는 패턴과 새롭게 바꾸려는 문자열을 각각 등호로 연결을 해야 한다. (x &lt;- str_c(&quot;banana&quot;, 1:3)) ## [1] &quot;banana1&quot; &quot;banana2&quot; &quot;banana3&quot; str_replace_all(x, c(&quot;1&quot; = &quot; one&quot;, &quot;2&quot; = &quot; two&quot;, &quot;3&quot; = &quot; three&quot;)) ## [1] &quot;banana one&quot; &quot;banana two&quot; &quot;banana three&quot; \\(\\bullet\\) str_detect( ), str_count(): 매치되는 패턴의 존재 여부 확인 및 개수 계산 주어진 문자열에서 매치되는 패턴의 존재 여부를 확인하는 작업과 매치되는 패턴의 개수를 세는 작업은 주어진 문자열의 특성을 파악하는데 큰 도움이 될 수 있다. 예를 들어 주어진 문장에 특정 단어의 포함 여부 및 포함 횟수를 파악함으로써 그 문장의 대략적인 의미를 미루어 짐작할 수 있을 것이다. 함수 str_count()의 사용법은 문자열을 먼저 입력하고 이어서 패턴을 입력하면 된다. 벡터 x를 구성하고 있는 각 문자열에 소문자 \"p\"의 존재 여부 확인 및 매치되는 패턴의 개수는 다음과 같이 확인할 수 있다. x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;p&quot;) ## [1] TRUE FALSE TRUE str_count(x, &quot;p&quot;) ## [1] 2 0 1 패키지 stringr에 있는 words는 980개의 단어로 구성된 문자형 벡터로, 처음 5개 단어는 다음과 같다. length(words) ## [1] 980 words[1:5] ## [1] &quot;a&quot; &quot;able&quot; &quot;about&quot; &quot;absolute&quot; &quot;accept&quot; 벡터 words의 980개 단어에 사용된 모음 중 가장 빈번하게 사용된 모음이 어떤 것인지 함수 str_count()로 다음과 같이 확인할 수 있다. 모음 \"e\"가 686번 사용되어 가장 빈번하게 사용되었음을 알 수 있다. sum(str_count(words, &quot;a&quot;)) ## [1] 385 sum(str_count(words, &quot;e&quot;)) ## [1] 686 sum(str_count(words, &quot;i&quot;)) ## [1] 319 sum(str_count(words, &quot;o&quot;)) ## [1] 373 sum(str_count(words, &quot;u&quot;)) ## [1] 189 모음 \"e\"가 포함된 단어의 개수는 다음과 같이 확인할 수 있다. sum(str_detect(words, &quot;e&quot;)) ## [1] 536 \\(\\bullet\\) str_subset(): 매치되는 패턴이 포함된 문자열 추출 매치되는 패턴의 개수를 세는 것도 중요한 작업이지만 패턴이 포함된 문자열 자체를 추출하는 것 또한 매우 의미 있는 작업이다. 함수 str_subset()은 주어진 문자열 중에 지정한 패턴이 포함되어 있는 문자열 자체를 추출할 수 있는데, 예를 들어 문자형 벡터 words에서 소문자 \"x\"가 포함된 단어는 다음과 같이 찾을 수 있다. str_subset(words, &quot;x&quot;) ## [1] &quot;box&quot; &quot;exact&quot; &quot;example&quot; &quot;except&quot; &quot;excuse&quot; ## [6] &quot;exercise&quot; &quot;exist&quot; &quot;expect&quot; &quot;expense&quot; &quot;experience&quot; ## [11] &quot;explain&quot; &quot;express&quot; &quot;extra&quot; &quot;next&quot; &quot;sex&quot; ## [16] &quot;six&quot; &quot;tax&quot; \\(\\bullet\\) str_extract()와 str_extract_all(): 매치되는 패턴 추출 매치되는 패턴이 포함된 문자열 전체를 추출해내는 것도 의미가 있지만, 각 문자열에서 매치되는 패턴만을 추출하는 것도 상당히 의미가 있다. 함수 str_extract()는 각 문자열에서 첫 번째로 매치되는 패턴을 추출하여 벡터로 출력한다. 반면에 함수 str_extract_all()은 매치되는 모든 패턴을 추출하여 리스트로 출력하며, 만일 옵션 simplify=TRUE를 추가하면 결과를 문자형 행렬로 출력한다. x &lt;- c(&quot;ab&quot;, &quot;acb&quot;, &quot;acab&quot;, &quot;abcab&quot;) str_extract(x, &quot;ab&quot;) ## [1] &quot;ab&quot; NA &quot;ab&quot; &quot;ab&quot; str_extract_all(x, &quot;ab&quot;) ## [[1]] ## [1] &quot;ab&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## [1] &quot;ab&quot; ## ## [[4]] ## [1] &quot;ab&quot; &quot;ab&quot; str_extract_all(x, &quot;ab&quot;, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;ab&quot; &quot;&quot; ## [2,] &quot;&quot; &quot;&quot; ## [3,] &quot;ab&quot; &quot;&quot; ## [4,] &quot;ab&quot; &quot;ab&quot; 6.3.2 정규 표현식과 stringr의 함수 정규 표현식(regular expression)은 문자열에 있는 패턴을 표현하는 방식을 의미하는 것으로써, R에서만 다뤄지는 것이 아니라 문자열을 다루는 모든 프로그램에서 공통적으로 사용되는 매우 강력하고 유용한 기법이다. 이 절에서는 정규 표현식의 기초적인 내용을 살펴보고, 패키지 stringr의 함수와 함께 사용해보고자 한다. 문자열의 패턴 중 가장 단순한 형태는 문자열 자체이다. 예를 들어 문자형 벡터 words에서 소문자 \"x\"가 포함된 단어를 찾는 경우, 함수 str_subset()에서 사용되는 패턴은 소문자 \"x\"가 된다. 앞 절에서 살펴본 패키지 stringr의 함수들에 대한 예제에서 사용된 패턴은 모두 문자열 자체였다. 조금 복잡해진 문자열 패턴의 예로서 문자형 벡터 words에서 소문자 \"x\"로 끝나는 단어를 찾는 경우를 생각해 볼 수 있다. 이 경우에는 정규 표현식의 메타 문자 $을 사용하면 다음과 같이 간단하게 해당 단어를 찾을 수 있다. str_subset(words, &quot;x$&quot;) ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; 이와 같이 정규 표현식을 패키지 stringr의 함수들과 함께 사용하면 한층 업그레이드된 강력한 분석 능력을 가질 수 있게 된다. \\(\\bullet\\) 메타 문자(Meta character) 정규 표현식에서 메타 문자란 특별한 의미를 갖고 있는 문자를 지칭하는 것으로써 다음의 문자들이 메타 문자에 해당한다. . \\ | ( ) [ ] { } ^ $ * + ? 이제 각 메타 문자의 의미를 살펴보자. 점(.) : 모든 문자와 매치 점(.)은 모든 문자와 매치가 된다. 문자형 벡터 x의 문자열 중에 소문자 \"a\"에 이어서 임의의 문자가 오는 패턴이 있는 문자열을 추출해 보자. x &lt;- c(&quot;abac&quot;, &quot;adc&quot;, &quot;cba&quot;) str_subset(x, &quot;a.&quot;) ## [1] &quot;abac&quot; &quot;adc&quot; 벡터 x을 구성하는 각 문자열에서 소문자 \"a\"에 이어서 임의의 문자가 오는 패턴을 추출해 보자. x &lt;- c(&quot;abac&quot;, &quot;adc&quot;, &quot;cba&quot;) str_extract(x, &quot;a.&quot;) ## [1] &quot;ab&quot; &quot;ad&quot; NA str_extract_all(x, &quot;a.&quot;, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;ab&quot; &quot;ac&quot; ## [2,] &quot;ad&quot; &quot;&quot; ## [3,] &quot;&quot; &quot;&quot; 역슬래시(\\): 탈출 문자(Escape character) 점(.)은 메타 문자로서 모든 문자와 매치된다. 그렇다면 문자 자체로서의 \".\"은 어떻게 매치해야 하는가? 예를 들어 다음의 벡터 x에서 문자열 중에 있는 점(.)을 함수 str_extract()로 추출해 보자. x &lt;- c(&quot;a.c&quot;, &quot;abc&quot;) str_extract(x, &quot;.&quot;) ## [1] &quot;a&quot; &quot;a&quot; 추출 결과는 점이 아니라 각 문자열의 첫 문자인 \"a\"가 출력되었다. 이러한 경우에는 메타 문자의 기능을 없애고 문자 자체의 의미만을 남겨두는 것이 필요한데, 이때 사용되는 것이 메타 문자의 기능에서 탈출시킨다는 의미를 갖고 있어서 탈출 문자라고 불리는 역슬래시(\\)이다. 여기에서 한 가지 문제는 정규 표현식에서 탈출 문자로 사용되는 역슬래시가 문자열 자체에서도 탈출 문자로 사용된다는 점이다. 예를 들어, \"\\n\"은 줄을 바꾸는 기호이고, \"\\t\"은 탭 기호를 의미한다. 따라서 문자 자체로써의 역슬래시 하나를 문자열에 포함시키기 위해서는 \"\\\\\"와 같이 두 개를 연속해서 사용해야 하며, 이러한 이유로 해서 정규 표현식 \\.을 작성하기 위한 문자열은 \"\\\\.\"이 되어야 한다. x &lt;- c(&quot;a.c&quot;, &quot;abc&quot;) str_extract(x, &quot;\\\\.&quot;) ## [1] &quot;.&quot; NA 또한 탈출 문자로 사용되는 역슬래시를 문자 자체로써 매치하려는 정규 표현식은 \\\\이 되며, 이것을 작성하기 위한 문자열은 \"\\\\\\\\\"이 된다. 다음의 벡터 x를 구성하는 문자열 중에 있는 역슬래시를 추출해 보자. x &lt;- c(&quot;a\\\\b&quot;, &quot;a\\\\.b&quot;, &quot;aeb&quot;) str_extract(x, &quot;\\\\\\\\&quot;) ## [1] &quot;\\\\&quot; &quot;\\\\&quot; NA 문자열을 그냥 출력하면 탈출 문자가 포함된 상태에서의 결과를 보여준다. 탈출 문자를 제거한 문자열 실제 모습을 보기 위해서는 함수 writeLines()를 사용해야 한다. x ## [1] &quot;a\\\\b&quot; &quot;a\\\\.b&quot; &quot;aeb&quot; writeLines(x) ## a\\b ## a\\.b ## aeb writeLines(str_extract(x, &quot;\\\\\\\\&quot;)) ## \\ ## \\ ## NA ^과 $: 위치 지정 정규 표현식은 문자열의 위치에 관계 없이 매치되는 것이 일반적이다. 하지만 어떤 경우에는 위치를 지정해서 문자열의 시작 부분 혹은 끝 부분과 매치가 되도록 하는 것이 매우 효과적일 수 있다. 메타 문자 ^은 문자열의 시작 부분을, $는 문자열의 끝 부분을 각각 지정하는 데에 사용된다. 다음의 벡터 x에서 \"a\"로 시작하는 문자열과 \"a\"로 끝나는 문자열에서 문자 \"a\"를 각각 추출해 보자. x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_extract(x, &quot;^a&quot;) ## [1] &quot;a&quot; NA NA str_extract(x, &quot;a$&quot;) ## [1] NA &quot;a&quot; NA 지정된 문자열만이 매치되도록 하기 위해서는 ^와 $을 함께 사용하면 된다. x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_extract(x,&quot;apple&quot;) ## [1] &quot;apple&quot; &quot;apple&quot; &quot;apple&quot; str_extract(x,&quot;^apple$&quot;) ## [1] NA &quot;apple&quot; NA 벡터 words에 있는 단어 중 문자 \"y\"로 시작하는 단어와 \"x\"로 끝나는 단어, 그리고 두 문자로 이루어진 단어를 각각 추출해 보자. str_subset(words, &quot;^y&quot;) ## [1] &quot;year&quot; &quot;yes&quot; &quot;yesterday&quot; &quot;yet&quot; &quot;you&quot; &quot;young&quot; str_subset(words, &quot;x$&quot;) ## [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot; str_subset(words, &quot;^..$&quot;) ## [1] &quot;as&quot; &quot;at&quot; &quot;be&quot; &quot;by&quot; &quot;do&quot; &quot;go&quot; &quot;he&quot; &quot;if&quot; &quot;in&quot; &quot;it&quot; &quot;no&quot; &quot;of&quot; &quot;on&quot; &quot;or&quot; &quot;so&quot; ## [16] &quot;to&quot; &quot;up&quot; &quot;we&quot; 벡터 words에 있는 단어 중 세 문자로 이루어진 단어의 개수를 알아보자. words %&gt;% str_count(&quot;^...$&quot;) %&gt;% sum() ## [1] 110 [ ]: 문자 클래스 문자 클래스는 대괄호 안에 나열된 문자를 의미하는 것인데, 나열된 문자 중 한 문자와 매치가 된다. 다음의 벡터 x에서 \"e\" 또는 \"o\"가 있는 문자열을 추출해 보자. x &lt;- c(&quot;adapt&quot;, &quot;adept&quot;, &quot;adopt&quot;) str_subset(x, &quot;[eo]&quot;) ## [1] &quot;adept&quot; &quot;adopt&quot; 패키지 stringr의 fruit은 80가지의 과일 이름으로 구성되어 있는 문자형 벡터이다. 이름이 모음으로 시작하는 과일을 fruit에서 찾아보자. str_subset(fruit, &quot;^[aeiou]&quot;) ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; &quot;eggplant&quot; &quot;elderberry&quot; ## [6] &quot;olive&quot; &quot;orange&quot; &quot;ugli fruit&quot; 문자 클래스에는 어떤 문자도 올 수 있지만 첫 문자가 ^이면 정반대 의미의 매치가 이루어진다. 예를 들어 [abc]는 셋 중 어느 하나와 매치가 되지만 [^abc]는 세 문자를 제외한 다른 문자와 매치가 된다. 다음의 벡터 x에서 첫 문자가 \"a\" 또는 \"b\"가 아닌 문자열을 추출해 보자. x &lt;- c(&quot;abc&quot;, &quot;bcd&quot;, &quot;cde&quot;) str_subset(x, &quot;^[^ab]&quot;) ## [1] &quot;cde&quot; 소문자 \"a\" 부터 \"z\"까지 중 어느 한 문자와의 매치를 [abcdefghijklmnopqrstuvwxyz]와 같이 구성할 수 있지만, 효율적인 방식은 아니라고 하겠고, 대신 하이픈을 이용해서 [a-z]로 할 수 있다. 따라서 소문자와 대문자를 포함한 모든 영문자 중 어느한 문자와의 매치는 [A-Za-z]로 작성할 수 있고, 숫자까지 포함시키고자 한다면, [0-9A-Za-z]로 작성할 수 있다. 하지만 더 효율적인 방식은 다음과 같이 미리 설정된 문자 클래스를 사용하는 것이다. [:punct:] : 마침표, 쉼표 등의 구두점과 매치 [:alpha:] : 글자와 매치 [:digit:] : 숫자와 매치 [:alnum:] : 숫자 및 글자와 매치 [:space:] : 빈칸과 매치 x &lt;- c(&quot;I have $20.&quot;, &quot;내 키는 175cm 이다.&quot;) str_extract_all(x, &quot;[:punct:]&quot;) ## [[1]] ## [1] &quot;.&quot; ## ## [[2]] ## [1] &quot;.&quot; str_extract_all(x, &quot;[:alpha:]&quot;) ## [[1]] ## [1] &quot;I&quot; &quot;h&quot; &quot;a&quot; &quot;v&quot; &quot;e&quot; ## ## [[2]] ## [1] &quot;내&quot; &quot;키&quot; &quot;는&quot; &quot;c&quot; &quot;m&quot; &quot;이&quot; &quot;다&quot; str_extract_all(x, &quot;[:digit:]&quot;) ## [[1]] ## [1] &quot;2&quot; &quot;0&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;7&quot; &quot;5&quot; str_extract_all(x, &quot;[:alnum:]&quot;) ## [[1]] ## [1] &quot;I&quot; &quot;h&quot; &quot;a&quot; &quot;v&quot; &quot;e&quot; &quot;2&quot; &quot;0&quot; ## ## [[2]] ## [1] &quot;내&quot; &quot;키&quot; &quot;는&quot; &quot;1&quot; &quot;7&quot; &quot;5&quot; &quot;c&quot; &quot;m&quot; &quot;이&quot; &quot;다&quot; str_split(x, &quot;[:space:]&quot;) ## [[1]] ## [1] &quot;I&quot; &quot;have&quot; &quot;$20.&quot; ## ## [[2]] ## [1] &quot;내&quot; &quot;키는&quot; &quot;175cm&quot; &quot;이다.&quot; 탈출 문자를 사용한 다음과 같은 방식도 사용할 수 있다. \\d : 숫자와 매치 \\D : 숫자가 아닌 것과 매치 \\w : 숫자 및 글자와 매치 \\W : 숫자 및 글자가 아닌 것과 매치 \\s : 빈칸과 매치 x &lt;- c(&quot;Don&#39;t eat!&quot;, &quot;1+2=3&quot;) str_extract_all(x, &quot;\\\\d&quot;) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; str_extract_all(x, &quot;\\\\D&quot;) ## [[1]] ## [1] &quot;D&quot; &quot;o&quot; &quot;n&quot; &quot;&#39;&quot; &quot;t&quot; &quot; &quot; &quot;e&quot; &quot;a&quot; &quot;t&quot; &quot;!&quot; ## ## [[2]] ## [1] &quot;+&quot; &quot;=&quot; str_extract_all(x, &quot;\\\\w&quot;) ## [[1]] ## [1] &quot;D&quot; &quot;o&quot; &quot;n&quot; &quot;t&quot; &quot;e&quot; &quot;a&quot; &quot;t&quot; ## ## [[2]] ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; str_extract_all(x, &quot;\\\\W&quot;) ## [[1]] ## [1] &quot;&#39;&quot; &quot; &quot; &quot;!&quot; ## ## [[2]] ## [1] &quot;+&quot; &quot;=&quot; str_split(x, &quot;\\\\s&quot;) ## [[1]] ## [1] &quot;Don&#39;t&quot; &quot;eat!&quot; ## ## [[2]] ## [1] &quot;1+2=3&quot; | : 대안 제시 메타 문자 |은 OR의 의미를 갖고 있다. 한 개 이상의 패턴을 문자 |으로 연결해 놓으면, 그 중 어느 하나와 매치가 된다. 예를 들어 \"abc|def\"는 \"abc\" 혹은 \"def\"와 매치가 된다. x &lt;- c(&quot;abc&quot;, &quot;def&quot; , &quot;ghi&quot;) str_detect(x, &quot;a|d&quot;) ## [1] TRUE TRUE FALSE str_detect(x, &quot;a|d|g&quot;) ## [1] TRUE TRUE TRUE 문자 |은 우선 순위가 낮은 연산자이다. 이것 때문에 제시되는 패턴의 범위가 명확하지 않은 경우에는 괄호를 사용하여 범위를 명확하게 할 수 있다. 예를 들어 \"ab(c|d)ef\"는 \"abcef\" 또는 \"abdef\"와 매치가 된다. x &lt;- c(&quot;abd&quot;, &quot;acd&quot;, &quot;abc&quot;) str_detect(x, &quot;ab|cd&quot;) ## [1] TRUE TRUE TRUE str_detect(x, &quot;a(b|c)d&quot;) ## [1] TRUE TRUE FALSE ?, +, * : 반복 연산자 반복 연산자를 이용하면 제시되는 패턴의 매치 횟수를 조절할 수 있다. 반복 연산자로 사용되는 각 메타 문자의 의미는 다음과 같다. ? : 한 번 이하의 반복 (가능한 반복 횟수 = 0, 1) + : 한 번 이상의 반복 (가능한 반복 횟수 ≥ 1) * : 0번 이상의 반복 (가능한 반복 횟수 ≥ 0) 반복 연산자는 반복 대상이 되는 패턴 바로 뒤에 붙이면 된다. 예를 들어 colou?r은 u의 1회 반복으로 colour과 매치가 되기도 하고, 0회 반복, 즉 제거되어 color와도 매치가 된다. x &lt;- c(&quot;color&quot;, &quot;colour&quot;) str_extract(x, &quot;colou?r&quot;) ## [1] &quot;color&quot; &quot;colour&quot; 반복 대상이 되는 패턴이 두 개 이상의 문자인 경우에는 반드시 괄호로 감싸야 한다. x &lt;- c(&quot;ba&quot;, &quot;bana&quot;, &quot;banana&quot;, &quot;bananana&quot;) str_extract(x, &quot;bana(na)?&quot;) ## [1] NA &quot;bana&quot; &quot;banana&quot; &quot;banana&quot; str_extract(x, &quot;bana(na)+&quot;) ## [1] NA NA &quot;banana&quot; &quot;bananana&quot; str_extract(x, &quot;bana(na)*&quot;) ## [1] NA &quot;bana&quot; &quot;banana&quot; &quot;bananana&quot; 정확한 반복 횟수를 지정하려면 중괄호 { }를 사용하면 된다. {n} : 정확히 n번 반복 {n, m} : n번에서 m번 사이 반복 {n,} : n번 이상 반복 {,m} : m번 이하 반복 벡터 words에서 세 개의 자음으로 시작하는 단어는 다음과 같이 찾을 수 있다. str_subset(words, &quot;^[^aeiou]{3}&quot;) ## [1] &quot;Christ&quot; &quot;Christmas&quot; &quot;dry&quot; &quot;fly&quot; &quot;mrs&quot; &quot;scheme&quot; ## [7] &quot;school&quot; &quot;straight&quot; &quot;strategy&quot; &quot;street&quot; &quot;strike&quot; &quot;strong&quot; ## [13] &quot;structure&quot; &quot;system&quot; &quot;three&quot; &quot;through&quot; &quot;throw&quot; &quot;try&quot; ## [19] &quot;type&quot; &quot;why&quot; 세 개 이상의 모음이 연속으로 있는 단어는 다음과 같이 찾을 수 있다. str_subset(words, &quot;[aeiou]{3,}&quot;) ## [1] &quot;beauty&quot; &quot;obvious&quot; &quot;previous&quot; &quot;quiet&quot; &quot;serious&quot; &quot;various&quot; 모음-자음의 쌍이 세 번 이상 연속으로 나타나는 단어는 다음과 같이 찾을 수 있다 str_subset(words, &quot;([aeiou][^aeiou]){3,}&quot;) ## [1] &quot;america&quot; &quot;benefit&quot; &quot;business&quot; &quot;definite&quot; &quot;develop&quot; ## [6] &quot;document&quot; &quot;economy&quot; &quot;educate&quot; &quot;eleven&quot; &quot;evening&quot; ## [11] &quot;evidence&quot; &quot;general&quot; &quot;holiday&quot; &quot;however&quot; &quot;imagine&quot; ## [16] &quot;operate&quot; &quot;original&quot; &quot;particular&quot; &quot;politic&quot; &quot;positive&quot; ## [21] &quot;separate&quot; &quot;similar&quot; &quot;specific&quot; &quot;television&quot; &quot;therefore&quot; ## [26] &quot;university&quot; ( ): 그룹 지정 및 재참조(backreference) 괄호는 문자 |와 패턴의 우선 순위를 조절하기 위하여 패턴의 그룹을 구성할 때 사용됐고, 문자 + 또는 * 등의 반복 연산자의 경우에도 반복 대상이 되는 패턴을 그룹으로 구성할 때 사용됐다. 이와 같이 그룹을 구성하는 것은 나름의 목적이 있는 것이지만, 또 다른 이점은 그룹으로 구성된 패턴을 재참조할 수 있다는 점이다. 재참조는 매치된 패턴을 반복할 때 매우 유용하게 사용되는 것으로써, 재참조의 표현식은 \\1, \\2 등으로 나타낼 수 있다. 여기서 \\1은 첫 번째 매치된 패턴의 그룹을, 그리고 \\2은 두 번째 매치된 패턴의 그룹을 각각 의미한다. 예를 들어 벡터 fruit에서 한 개의 문자가 두 번 반복해서 나타나는 과일 이름은 다음과 같이 찾을 수 있다. \"(.)\"으로 매치된 한 문자를 \"\\\\1\"로 재참조, 즉 동일한 문자를 다시 매치하는 패턴을 구성하여, 한 개의 문자가 두 번 반복해서 나타나는 문자열을 찾아낸 것이다. str_subset(fruit, &quot;(.)\\\\1&quot;) ## [1] &quot;apple&quot; &quot;bell pepper&quot; &quot;bilberry&quot; ## [4] &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; ## [7] &quot;blueberry&quot; &quot;boysenberry&quot; &quot;cherry&quot; ## [10] &quot;chili pepper&quot; &quot;cloudberry&quot; &quot;cranberry&quot; ## [13] &quot;currant&quot; &quot;eggplant&quot; &quot;elderberry&quot; ## [16] &quot;goji berry&quot; &quot;gooseberry&quot; &quot;huckleberry&quot; ## [19] &quot;lychee&quot; &quot;mulberry&quot; &quot;passionfruit&quot; ## [22] &quot;persimmon&quot; &quot;pineapple&quot; &quot;purple mangosteen&quot; ## [25] &quot;raspberry&quot; &quot;redcurrant&quot; &quot;salal berry&quot; ## [28] &quot;strawberry&quot; &quot;tamarillo&quot; 두 개의 문자가 두 번 반복해서 나타나는 과일 이름은 다음과 같이 찾을 수 있다. str_subset(fruit, &quot;(..)\\\\1&quot;) ## [1] &quot;banana&quot; &quot;coconut&quot; &quot;cucumber&quot; &quot;jujube&quot; &quot;papaya&quot; ## [6] &quot;salal berry&quot; 벡터 words에서 첫 글자와 마지막 글자가 같은 글자인 단어는 다음과 같이 찾을 수 있다. str_subset(words, &quot;^(.).*\\\\1$&quot;) ## [1] &quot;america&quot; &quot;area&quot; &quot;dad&quot; &quot;dead&quot; &quot;depend&quot; ## [6] &quot;educate&quot; &quot;else&quot; &quot;encourage&quot; &quot;engine&quot; &quot;europe&quot; ## [11] &quot;evidence&quot; &quot;example&quot; &quot;excuse&quot; &quot;exercise&quot; &quot;expense&quot; ## [16] &quot;experience&quot; &quot;eye&quot; &quot;health&quot; &quot;high&quot; &quot;knock&quot; ## [21] &quot;level&quot; &quot;local&quot; &quot;nation&quot; &quot;non&quot; &quot;rather&quot; ## [26] &quot;refer&quot; &quot;remember&quot; &quot;serious&quot; &quot;stairs&quot; &quot;test&quot; ## [31] &quot;tonight&quot; &quot;transport&quot; &quot;treat&quot; &quot;trust&quot; &quot;window&quot; ## [36] &quot;yesterday&quot; 또한words에서 한 문자가 세 번 이상 사용된 단어는 다음과 같이 찾을 수 있다. str_subset(words, &quot;(.).*\\\\1.*\\\\1&quot;) ## [1] &quot;appropriate&quot; &quot;available&quot; &quot;believe&quot; &quot;between&quot; &quot;business&quot; ## [6] &quot;degree&quot; &quot;difference&quot; &quot;discuss&quot; &quot;eleven&quot; &quot;environment&quot; ## [11] &quot;evidence&quot; &quot;exercise&quot; &quot;expense&quot; &quot;experience&quot; &quot;individual&quot; ## [16] &quot;paragraph&quot; &quot;receive&quot; &quot;remember&quot; &quot;represent&quot; &quot;telephone&quot; ## [21] &quot;therefore&quot; &quot;tomorrow&quot; "],["chapter-programming.html", "7 장 R에서의 프로그래밍 7.1 사용자 정의 함수 7.2 조건 연산 7.3 루프 연산 7.4 함수형 프로그래밍 7.5 함수형 프로그래밍으로 행렬과 데이터 프레임 다루기 7.6 purrr에 의한 프로그래밍 7.7 연습문제", " 7 장 R에서의 프로그래밍 R 언어는 S 언어에 기반을 두고 있다. S 언어의 개발에 주도적인 역할을 했던 Richard Becker, John Chambers와 Allan Wilks는 Becker and Wilks (1988) 에서 S는 데이터 분석 및 그래픽스를 위한 언어이자 대화형 프로그래밍 환경이며, S 환경의 주된 목적은 훌륭한 데이터 분석을 가능하게 하는 것이라 하였다. S 언어는 프로그래밍 언어로서 필요한 모든 특징을 갖고 있어서 어떤 형태의 데이터 분석이나 그래프 분석도 사용자가 작성한 프로그램으로 수행이 가능하다. 비록 S 개발자들에게 ’데이터 분석’이란 통계적 데이터 분석만을 의미한 것은 아니었으나, 가장 활발하게 S를 사용한 집단은 바로 통계학자들이라 할 수 있다. S 언어의 특징을 고스란히 갖고 있는 R 언어 또한 매우 뛰어난 프로그래밍 언어이다. 최근 들어 R이 통계학 이외의 분야에서도 ’데이터를 기반으로 하는 다양한 프로그래밍’의 목적으로 활발하게 사용되고 있는데, Wickham (2019) 와 Venables and Ripley (2000) 이 R을 본격적인 프로그래밍 도구로 사용하고 있는 프로그래머들에게는 큰 도움이 될 것이다. 이 장에서는 R의 기본적인 프로그래밍 기법 중 통계분석 과정에서 자주 사용되는 기법들을 주로 살펴보고자 한다. R 언어를 이용하여 효과적인 프로그램을 작성하기 위해서는 반드시 R 언어의 문법에 익숙해져야 하는데, 이미 우리는 데이터 준비하기와 데이터 다루기의 관점에서 R 언어 문법의 많은 부분을 다루었다. 프로그래밍의 관점에서 본다면 약간 산만한 방식으로 소개된 것이지만 통계분석의 관점에서는 체계적인 방식이라고 본다. 이제 R 언어의 가장 기본적인 개념으로서 다음 용어의 의미를 간단하게 살펴보자. 표현식(Expression) 객체(Object) 함수(Function) R 프로그램은 일련의 표현식으로 이루어져 있다. 특정 객체에 데이터를 할당하는 문장, 조건을 비교하는 문장, 산술 표현식 등 지금까지 우리가 사용한 R 명령문이 모두 표현식이 된다. 이러한 표현식은 모두 객체와 함수로 이루어져 있으며, 새로운 줄 또는 세미콜론으로 분리가 된다. R 프로그램은 객체를 기본 요소로 하고 있다. 지금까지 우리가 알고 있는 객체는 벡터, 행렬, 데이터 프레임, 리스트 등 모두 데이터를 담고 있는 객체들이다. 그러나 R에서는 모든 것이 객체라 할 수 있다. 함수와 표현식도 객체이다. 함수란 인수 혹은 변수라고 불리는 객체를 입력시키면 결과물 객체를 생성시키는 또 다른 R의 객체이다. R에서 수행되는 거의 모든 작업은 함수를 통해서 이루어진다. 지금까지 우리가 살펴본 R 프로그램의 수행 방식은 첫 줄부터 시작하여 한 줄씩 내려가며 모든 표현식을 차례로 실행하는 것이었다. 그러나 경우에 따라서는 이러한 수행 방식으로는 해결하기에 매우 불편한 문제들도 있을 수 있다. 예를 들어 어떤 조건이 만족되어야만 실행을 시켜야 하는 표현식이 있을 수 있고, 몇 번을 반복하여 실행시켜야 하는 표현식도 있을 수 있다. 이와 같이 프로세스의 흐름을 조절해야 하는 경우 사용할 수 있는 기법에 대해서 살펴보도록 하자. 또한 R의 큰 장점 중 하나는 바로 사용자 스스로 함수를 정의하여 사용할 수 있다는 것이다. 함수의 정의 과정 및 사용 방법에 대해서도 알아보도록 하자. 7.1 사용자 정의 함수 R의 큰 장점 중 하나가 바로 사용자가 함수를 정의해서 사용할 수 있다는 것이다. 사용자가 필요한 함수를 스스로 만들어 사용할 수 있기 때문에 전체적으로 프로그램이 상당히 간결하게 작성될 수 있으며, 분석 절차가 훨씬 더 효율적이 될 수 있다. 7.1.1 함수의 정의 함수를 정의하는 일반적인 방법은 다음과 같다. my_func &lt;- function(arg1, arg2, ...) { 표현식 } my_func는 사용자가 정의한 함수의 이름이고, arg1, arg2 등은 함수의 변수 이름을 나타내는 것이다. 중괄호에 포함되어 있는 표현식은 함수에 입력된 변수들을 사용하여 사용자가 원하는 연산을 수행하도록 작성된 R 표현식이다. 표현식은 일반적으로 중괄호에 싸여 있는데 표현식이 단 한 줄인 경우에는 굳이 중괄호를 사용하지 않아도 된다. 예를 들어 다음에 정의된 함수 f1()과 f2()는 동일한 것으로, 입력된 두 변수의 합을 계산한다. f1 &lt;- function(x, y) x + y f2 &lt;- function(x,y){ x + y } f1(5, 10) ## [1] 15 f2(5, 10) ## [1] 15 7.1.2 변수 함수에 입력되는 변수는 크게 두 가지 종류로 구분된다. 하나는 연산 대상이 되는 데이터이고, 다른 하나는 연산과 관련된 세부 옵션이다. 일반적으로 함수의 첫 번째 변수는 데이터가 되며, 이어서 필요한 세부 옵션들이 그 이후의 변수로 입력된다. 예를 들어 표본 자료를 사용하여 모평균에 대한 신뢰구간을 계산하는 함수를 정의해 보자. 모집단의 표준편차를 추정해야 되며, 정규분포를 이용할 수 있는 상황이라고 가정하자. 이 경우 표본 자료가 첫 번째 변수가 되고, 신뢰구간의 신뢰수준이 두 번째 변수로 입력되어야 한다. 세부 옵션과 관련된 변수의 경우에는 디폴트 값이 주어지는 것이 일반적인 상황인데, 신뢰구간의 경우에도 신뢰수준의 디폴트 값은 0.95로 잡을 수 있다. CI_mean &lt;- function(x, conf = 0.95){ m &lt;- mean(x) se &lt;- sd(x)/sqrt(length(x)) alpha &lt;- 1 - conf c(m - qnorm(1 - alpha/2) * se, m + qnorm(1 - alpha/2) * se) } 함수 qnorm()은 정규분포에서 분위수를 계산하는 함수이다. p에 원하는 확률 값을 입력하면 그 값에 해당하는 분위수를 출력하며, 평균과 표준편차는 변수 mean과 sd로 지정할 수 있는데, 디폴트는 mean = 0, sd = 1인 표준정규분포이다. 함수에서 디폴트 값이 부여된 변수는 함수를 실행할 때 생략해도 된다. set.seed(1234579) x &lt;- rnorm(n = 100) CI_mean(x) ## [1] -0.2778891 0.1660690 함수 rnorm()은 정규분포에서 난수를 발생시키는 함수이다. 난수의 개수는 n에 지정을 하며, 평균과 표준편차는 변수 mean과 sd로 지정할 수 있는데, 디폴트는 mean = 0, sd = 1인 표준정규분포이다. 함수 set.seed()는 난수 발생의 seed를 지정하는 것으로 위와 동일한 결과를 볼 수 있도록 사용하였다. 벡터 x에는 정규분포에서 임의로 추출한 100개의 표본 자료가 입력되어 있으며, 이것을 우리가 정의한 함수 CI_mean()에 입력한 결과, 디폴트인 95% 신뢰구간이 계산되었다. 만일 디폴트로 입력된 옵션 값을 수정하고자 한다면, 해당 변수에 직접 값을 지정하면 된다. 동일한 자료에 대하여 90% 신뢰구간을 구해 보자. 두 번째 변수 conf에 0.9를 입력하면 된다. CI_mean(x, conf = 0.9) ## [1] -0.2422007 0.1303807 함수의 변수를 지정할 때 마지막 변수 다음에 생략 부호(...)를 추가하는 경우가 있는데, 이 생략 부호는 사실 특별한 기능을 갖고 있는 또 다른 변수이다. 기존의 다른 함수를 이용하여 사용자가 자신의 함수를 정의하는 경우가 많이 있는데, 생략 부호를 변수의 리스트에 추가하면 기존의 다른 함수에 적용되는 부가적인 변수들을 마치 자신이 정의한 함수의 변수처럼 사용할 수 있다. 함수 CI_mean() 안에는 함수 mean()과 sd()가 있는데, 이 함수들은 데이터에 NA가 포함되어 있으면, 그 결과도 NA로 출력된다. 이 경우 옵션 na.rm = TRUE를 포함하면 NA를 제외한 나머지 데이터를 대상으로 계산이 진행된다. 함수 CI_mean()에 벡터 x에 NA를 하나 추가한 벡터 y를 입력하고, 그 실행결과를 살펴보자. y &lt;- c(x, NA) CI_mean(y) ## [1] NA NA 함수 CI_mean()에는 변수 na.rm이 선언되지 않은 변수이기 때문에 사용할 수 없음을 알 수 있다. CI_mean(y, na.rm = TRUE) ## Error in CI_mean(y, na.rm = TRUE): unused argument (na.rm = TRUE) 이러한 문제를 해결하기 위하여 함수 CI_mean()에 생략부호인 변수 ...을 추가하고, 함수 안에 있는 또 다른 함수인 mean()과 sd()에도 변수 ...을 추가한 함수 CI_mean_dot()를 정의해 보자. 이 경우 함수 CI_mean_dot()에 추가한 옵션은 바로 함수 mean()과 sd()로 전달되어 실행된다. CI_mean_dot &lt;- function(x, conf = 0.95, ...){ m &lt;- mean(x, ...) se &lt;- sd(x, ...)/sqrt(sum(!is.na(x))) alpha &lt;- 1 - conf c(m - qnorm(1 - alpha/2) * se, m + qnorm(1 - alpha/2) * se) } 함수 안에서 정의되는 객체 se의 분모에 표본의 개수에서 NA의 개수를 제외하기 위해 sum(!is.na(x))을 사용하였다. 벡터 y와 옵션 na.rm = TRUE를 함수 CI_mean_dot()에 입력한 결과는 벡터 y에서 NA를 제외한 벡터 x의 신뢰구간인 CI_mean(x)와 동일하게 나왔다. CI_mean_dot(y, na.rm = TRUE) ## [1] -0.2778891 0.1660690 생략 부호 변수 ...에 대한 다른 예제를 살펴보자. 아래에 정의된 함수 my_plot()은 두 벡터를 받아들여 함수 mean()과 sd()로 표준화를 실시한 후 함수 geom_point()로 산점도를 작성하고 있다. 함수 my_plot()에는 명시적으로 선언된 변수가 x와 y 두 개뿐이지만, 생략 부호가 추가되어 있어서, 함수 geom_point()에 color 혹은 shape 등의 시각적 요소들을 함수 my_plot()의 변수처럼 사용할 수 있다. my_plot &lt;- function(x, y, ...){ z_x &lt;- (x - mean(x))/sd(x) z_y &lt;- (y - mean(y))/sd(y) ggplot(tibble(x = z_x, y = z_y)) + geom_point(aes(x, y), ...) } 예제로 함수 my_plot()을 사용하여 데이터 프레임 cars의 두 변수 speed와 dist를 표준화 시킨 후 산점도를 작성해 보자. 기호는 빨간 원으로 하자. 작성된 그래프는 그림 7.1 에서 볼 수 있다. library(tidyverse) with(cars, my_plot(x = speed, y = dist, shape = 20, color = &quot;red&quot;, size = 2)) 그림 7.1: 생략부호를 활용한 그래프 만일 함수 my_plot()에 NA가 있는 데이터를 입력한다면 어떻게 되겠는가? 표준화 과정에서 데이터는 모두 NA로 바뀌게 되어 결국 그래프 작성이 불가능하게 될 것이다. 데이터 프레임 airquality의 변수 Solar.R과 Ozone을 함수 my_plot()에 입력해 보면 확인할 수 있다. 이 경우, 옵션 na.rm = TRUE를 사용하기 위해 함수 mean()과 sd()에 다음과 같이 생략부호 변수를 포함시킨다고 해서 문제가 해결되지 않는다. my_plot_1 &lt;- function(x, y, ...){ z_x &lt;- (x - mean(x, ...))/sd(x, ...) z_y &lt;- (y - mean(y, ...))/sd(y, ...) ggplot(tibble(x = z_x, y = z_y)) + geom_point(aes(x, y), ...) } 그 이유는 함수 my_plot_1()에 추가된 옵션이 함수 mean()과 sd(), 그리고 geom_point()에 모두 전달이 되기 때문이다. 즉, 옵션 shape 혹은 color 등을 추가하면 그것이 함수 mean()과 sd()에도 입력되는데, 두 함수에는 그런 옵션이 없기 때문에 다음과 같은 오류가 발생한다. with(airquality, my_plot_1(x = Solar.R, y = Ozone, na.rm = TRUE, shape = 20, color = &quot;red&quot;, size = 2)) ## Error in sd(x, ...): unused arguments (shape = 20, color = &quot;red&quot;, size = 2) 따라서 결측값에 대한 옵션을 다음과 같이 변수로 지정하는 것이 문제를 해결하는 한 가지 방법이 된다. my_plot_2 &lt;- function(x, y, na = FALSE, ...){ z_x &lt;- (x - mean(x, na.rm = na))/sd(x, na.rm = na) z_y &lt;- (y - mean(y, na.rm = na))/sd(y, na.rm = na) ggplot(tibble(x = z_x, y = z_y)) + geom_point(aes(x, y), ...) } with(airquality, my_plot_2(x = Solar.R, y = Ozone, na = TRUE, shape = 20, color = &quot;red&quot;, size = 2)) ## Warning: Removed 42 rows containing missing values (`geom_point()`). 그림 7.2: 생략부호를 활용한 그래프 7.1.3 변수 지정 두 개의 변수를 가지고 있는 다음과 같은 함수 my_power()를 살펴보자. my_power &lt;- function(base, exponent) base^exponent 함수를 실행하기 위해서는 함수에 포함된 변수에 값을 지정해야 한다. 함수 my_power()을 사용하여 \\(2^{5}\\)을 계산한다면 두 변수인 base와 exponent에 값을 지정해 주어야 하 는데, 함수의 변수를 지정하는 방법에는 다음 세 가지가 있다. 전체 이름: 함수를 정의할 때 사용된 변수의 이름 전체를 사용하여 지정하는 방법 my_power(exponent = 5, base = 2) ## [1] 32 my_power(base = 2, exponent = 5) ## [1] 32 부분 이름: 함수를 정의할 때 사용된 변수 이름의 처음 일부분만을 사용하여 지정하는 방법 my_power(ex = 5, ba = 2) ## [1] 32 my_power(ba = 2, ex = 5) ## [1] 32 변수의 순서: 함수를 정의할 때 지정된 변수의 순서 my_power(2, 5) ## [1] 32 변수의 전체 이름 혹은 부분 이름을 사용하는 경우에는 변수의 입력순서가 문제가 되지 않는다. 부분 이름을 사용할 경우에는 다른 변수와 구분이 될 만큼은 입력해야 한다. 당장의 편리함만을 생각한다면 순서로 변수를 지정하는 방법을 사용하는 것이 좋을 듯하나, 어떤 값이 어떤 변수에 대한 것인지 불분명하게 될 가능성이 있기 때문에, 조금은 귀찮지만 전체 이름을 모두 사용하여 지정하는 것이 가장 안전하고 명확하게 프로그램을 작성하는 방법이라고 하겠다. 7.1.4 결과의 출력 함수의 연산 결과는 함수 return()으로 출력하는 것이 바람직하다. 예를 들어 다음의 함수 my_desc()는 입력된 벡터의 평균과 표준편차를 계산하여 리스트 형태로 출력하는 내용의 함수이다. my_desc &lt;- function(x, ...){ m.x &lt;- mean(x, ...) sd.x &lt;- sd(x, ...) res &lt;- list(mean = m.x, sd = sd.x) return(res) } 연산 결과는 리스트 객체 res에 할당되었고 그 결과는 함수 return()으로 출력되는 절차를 밟고 있다. 함수 my_desc()에 데이터 프레임 cars의 dist와 airquality의 Ozone을 각각 적용시키고, 그 결과를 살펴보자. with(cars, my_desc(x = dist)) ## $mean ## [1] 17.7 ## ## $sd ## [1] 10.22035 with(airquality, my_desc(x = Ozone, na.rm = TRUE)) ## $mean ## [1] 42.12931 ## ## $sd ## [1] 32.98788 함수 return()을 사용하지 않으면 가장 마지막에 실행된 표현식의 결과가 출력된다. 따라서 만일 마지막 표현식이 실행결과를 객체에 할당하는 것이라면 아무런 결과도 출력 되지 않는다. 함수 my_desc()에서 함수 return()을 생략하고자 한다면 다음과 같이 수정해야 한다. my_desc_1 &lt;- function(x, ...){ m.x &lt;- mean(x, ...) sd.x &lt;- sd(x, ...) list(mean = m.x, sd = sd.x) } with(cars, my_desc_1(x = dist)) ## $mean ## [1] 17.7 ## ## $sd ## [1] 10.22035 결과를 출력할 때 함수 return()을 사용할지 여부는 사용자의 취향에 달린 문제이기는 하지만 함수 return()을 사용하는 편이 훨씬 명확하게 프로그램을 작성하는 방법이 된다. 7.1.5 유효 범위 함수에서 정의되고 사용되는 변수와 생성되는 객체들은 모두 해당 함수 안에서만 존재한다. 즉, 만일 어떤 함수 내에서 x라는 변수를 정의하고 사용하였어도, 함수 밖에서는 그 변수를 사용할 수 없다는 것이다. 예를 들어, 벡터 x와 y가 현재의 작업 공간에 없다고 하자. 그러면, 함수 my_test()에서는 변수 x가 사용되고 객체 y가 생성되어 출력되었으나, 함수 밖에서는 모두 사용할 수 없는 대상인 것이다. my_test &lt;- function(x) { y &lt;- x + 1 return(y) } my_test(x = 3) ## [1] 4 x ## Error in eval(expr, envir, enclos): object &#39;x&#39; not found y ## Error in eval(expr, envir, enclos): object &#39;y&#39; not found 만일 같은 이름의 객체가 함수 안과 밖에 모두 존재하더라도 이들은 서로 전혀 상관없는 객체이다. y &lt;- 10 my_test(x = 3) ## [1] 4 즉, 함수의 안과 밖은 서로 분리된 환경(environment)으로서 함수는 변수에 지정할 값을 함수 외부로부터 받아들여 함수 내부에서 연산하고 그 결과를 다시 함수 외부로 내보내는 방식으로 외부와 소통하고 있다. 이와 같이 프로그램 내에서 특정 변수가 정의되어 사용될 수 있는 부분을 유효 범위(scope)라고 한다. 함수 내에서 사용되는 변수의 유효 범위를 제한하는 것은 반드시 필요한 사항인데, 이것은 어떤 함수에서 정의된 객체의 내용이 다른 함수에서 같은 이름의 객체를 사용했다고 해서 변경되는 것을 방지하기 위함이다. 여기서 유의할 점은 함수 내부의 변수들은 유효 범위가 제한되어 있지만 함수 외부의 변수들은 그렇지 않다는 점이다. 만일 함수 외부에서 정의된 변수가 있는데, 함수 내부에 그와 동일한 이름의 변수가 따로 지정된 것이 없다면, 함수 내부에서도 그대로 사용할 수 있게 된다. 이러한 일종의 비대칭적인 유효 범위의 설정 덕분에 상당히 효과적인 프로그래밍이 가능하게 되었다. 다음의 예를 살펴보자. my_test2 &lt;- function(x){ y &lt;- x + z return(y) } z &lt;- 5 my_test2(x = 5) ## [1] 10 z &lt;- 10 my_test2(x = 5) ## [1] 15 함수 외부의 상황에 따라 계산 결과를 다르게 할 수 있음을 보여주는 예가 된다. 7.2 조건 연산 주어진 조건의 만족 여부에 따라 실행되는 표현식을 다르게 할 수 있는데, 이러한 작업은 함수 if(), ifelse() 혹은 switch()로 할 수 있다. 7.2.1 함수 if()에 의한 조건 연산 함수 if()의 일반적인 사용법은 다음과 같다. if(조건){ 표현식 } 조건이 만족되는 경우에만 표현식이 실행되는 구조이다. 함수 if()는 else 부분을 포함시킬 수도 있는데, 그 형태는 다음과 같다. if(조건) { 표현식 1 } else { 표현식 2 } 이 경우 조건이 만족되면 표현식 1이 실행되고 만족되지 않으면 표현식 2가 실행된다. 위 구조는 다음과 같이 더 확장될 수 있다. if(조건 1) { 표현식 1 } else if(조건 2) { 표현식 2 } else { 표현식 3 } 조건 1이 만족되면 표현식 1이 실행되고, 조건 2가 만족되면 표현식 2가 실행되며, 두 조건 모두 만족되지 않으면 표현식 3이 실행되는 구조이다. 예제로 근의 공식을 이용하여 이차방정식의 근을 구하는 프로그램을 작성해 보자. 이차방정식 \\(ax^{2}+bx+c=0\\) 의 근의 개수는 판별식 \\(D=b^{2}-4ac\\) 의 값에 따라 3가지로 분류된다. 따라서 판별식의 실행 값이 조건이 되어 3가지 경우에 대한 표현식을 작성해야 한다. find_roots &lt;- function(a,b,c){ if(a == 0){ roots &lt;- c(&quot;Not quadratic equation&quot;) } else{ D &lt;- b^2 - 4*a*c if(D &gt; 0){ roots &lt;- c((-b - sqrt(D))/(2*a),(-b + sqrt(D))/(2*a)) } else if(D == 0){ roots &lt;- -b/(2*a) } else{ roots &lt;- c(&quot;No real root&quot;) } } return(roots) } 사용자 정의 함수 find_roots()를 이용하여 이차방정식 \\(x^{2}+4x+3=0\\) 의 근을 다음과 같이 구할 수 있다. find_roots(a = 1, b = 4, c = 3) ## [1] -3 -1 함수 if()를 사용할 때 조심해야 할 사항이 두 가지 있다. 첫 번째 사항은 else에 대한 것인데, 만일 다음과 같이 프로그램을 작성하면 오류가 발생한다. if(조건) { 표현식 1} else { 표현식 2 } 문제는 새로운 줄이 else로 시작했다는 것인데, 이렇게 작성이 되면 함수 if()는 ’표현식 1’에서 종료된 것으로 간주된다. 이어서 R은 else라는 함수를 찾게 되는데, 그런 함수가 없기 때문에 오류가 발생하는 것이다. 두 번째 사항으로 if()의 조건에는 하나의 논리값만이 사용되어야 한다는 점이다. 만일 길이가 1을 초과라는 논리 벡터가 입력되면 오류가 발생한다. 길이가 4인 두 벡터를 비교하여 큰 값을 차례로 출력하고자 하는 경우 함수 if()로 작성하면 다음과 오류가 발생한다. x &lt;- c(10, 3, 6, 9) y &lt;- c(1, 5, 4, 12) if(x &gt; y) x else y ## Error in if (x &gt; y) x else y: the condition has length &gt; 1 7.2.2 함수 ifelse()에 의한 조건 연산 조건 연산이 하나의 논리값에 의한 것이 아니라 논리 벡터에 의한 것이라면 함수 ifelse() 또는 dplyr::if_else()를 사용해야 한다. 함수 ifelse() 사용법은 ifelse(condtion, true, false)가 되는데, condition은 조건 연산으로 생성되는 논리형 벡터이고, 논리형 벡터의 값이 TRUE인 경우에는 true의 값이 할당되고, FALSE인 경우에는 false의 값이 할당된다. 함수 dplyr::if_else()의 사용법도 동일하다. 두 벡터를 비교하여 큰 값을 차례로 출력하고자 했던 앞의 예제는 다음과 같이 해결할 수 있다. x &lt;- c(10, 3, 6, 9) y &lt;- c(1, 5, 4, 12) ifelse(x &gt; y, x, y) ## [1] 10 5 6 12 주어진 점수가 50 미만이면 ‘Fail’, 50 이상이면 ‘Pass’를 점수와 함께 출력시키는 프로그램을 작성해 보자. score &lt;- c(80, 75, 40, 98) grade &lt;- ifelse(score &gt;= 50, &quot;Pass&quot;, &quot;Fail&quot;) data.frame(score, grade) ## score grade ## 1 80 Pass ## 2 75 Pass ## 3 40 Fail ## 4 98 Pass 7.2.3 함수 switch()에 의한 조건 연산 함수 switch()는 표현식이 갖는 값에 따라 몇 가지 항목 중 하나를 선택하는 기능을 갖고 있는 함수이다. 사용법은 switch(표현식, 선택 항목)인데, 표현식이 갖는 값이 숫자인 경우와 문자인 경우에 따라 선택하는 방식에 차이가 있다. 표현식의 결과가 숫자인 경우에는 선택할 항목의 위치를 지정하는 것이다. 예를 들어 Park, Lee, Kim 중 한 사람을 임의로 선택해야 한다면, 함수 sample()로 1, 2, 3 중 숫자 하나를 임의로 뽑고, 그 숫자를 세 사람의 이름이 콤마로 구분되어 있는 선택 항목과 함께 함수 switch()에 입력한다. 그러면 입력된 숫자의 위치에 있는 사람을 선택하게 된다. (x &lt;- sample(1:3, 1)) ## [1] 2 switch(x, &quot;Park&quot;, &quot;Lee&quot;, &quot;Kim&quot;) ## [1] &quot;Lee&quot; 표현식의 결과가 문자인 경우에는 선택할 항목 중 그 문자와 같은 항목을 선택하게 된다. 예를 들어 자료의 특성을 보고, 그 자료의 대푯값으로 산술평균과 중앙값 중 하나를 선택해서 계산할 수 있도록 하는 함수를 작성해 보자. 함수 my_center()는 입력되는 변수 type의 값에 따라 함수 mean() 혹은 median()을 사용하게 된다. my_center &lt;- function(x, type){ switch(type, mean = mean(x), med = median(x)) } 벡터 x에 1, 2, 3, 4, 50이 입력되어 있을 경우, 산술평균과 중앙값 중 하나를 선택해서 대푯값을 계산해 보자. x &lt;- c(1,2,3,4,50) my_center(x, type = &quot;med&quot;) ## [1] 3 my_center(x, type = &quot;mean&quot;) ## [1] 12 7.3 루프 연산 프로그램의 특정 부분을 일정 횟수 반복시켜 작업하는 것을 루프 연산이라고 한다. R에서 루프 연산은 함수 for()와 while()로 할 수 있다. 7.3.1 for 루프 정규분포에서 10개의 임의표본을 추출하여 평균을 계산하는 과정을 다섯 번 반복한다고 하자. 이 경우 동일한 명령문을 다섯 번 작성해서 차례로 실행하는 것은 그리 좋은 방법은 아니다. 거의 비슷한 연산을 반복해서 수행해야 한다면 for 루프를 사용하는 것이 바람직하다. 다음 예제로 함수 for()의 사용법을 살펴보자. set.seed(123) res &lt;- vector(&quot;double&quot;, 5) for(i in seq_along(res)){ res[i] &lt;- mean(rnorm(10)) } res |&gt; round(3) ## [1] 0.075 0.209 -0.425 0.322 -0.009 for 루프는 세 가지 요소로 구성되어 있다. 첫 번째는 루프 연산으로 생성될 결과물 객체를 위한 빈 공간의 생성이다. 즉, 비어있는 벡터를 미리 만드는 것인데, 루프 연산으로 산출된 결과값의 할당이 대부분 대괄호를 이용한 인덱싱으로 이루어지기 때문에, 미리 이것을 대비한 것이다. 빈 공간의 생성은 함수 vector()로 할 수 있는데, 함수 안에 벡터의 유형과 벡터의 길이를 지정해야 한다. 벡터의 유형은 \"logical\", \"integer\", \"double\", \"character\" 등이 가능하다. 두 번째 요소는 반복 횟수 및 반복 인덱스 변수의 지정이다. 일반적으로 for(var in seq)의 형태를 취하는데, 인덱스 변수 var는 seq의 값을 차례로 취하면서 루프를 수행하게 된다. 위의 예제에서는 인덱스 변수로 i가 사용되었고, 루프가 수행되면서 i가 seq_along(res)의 값인 1, 2, 3, 4, 5의 값을 차례로 취하게 된다. 세 번째 요소는 중괄호 안에서 반복 수행이 되는 표현식이다. 그 중 가장 중요한 부분은 수행 결과물을 미리 공간을 확보한 결과물 벡터에 대괄호를 이용한 인덱싱 기법으로 할당하는 것이다. 즉, 첫 번째 반복에서는 res[1] &lt;- mean(rnorm(10))으로 결과물을 할당하고, 두 번째 반복에서는 res[2] &lt;- mean(rnorm(10))이 수행되는 식이 된다. for 루프를 활용한 다른 예제로서 factorial 값을 계산해 보자. fac.x &lt;- 1 for(i in 1:5){ fac.x &lt;- fac.x*i cat(i, &quot;!=&quot;, fac.x, &quot;\\n&quot;, sep=&quot;&quot;) } ## 1!=1 ## 2!=2 ## 3!=6 ## 4!=24 ## 5!=120 Factorial의 계산절차는 먼저 변수 fac.x에 초기값 1을 할당하고 이어서 for 루프로 들어가 본격적인 연산을 한다. 루프 안에서는 먼저 변수 i가 1의 값을 갖고 fac.x &lt;- fac.x*i를 실행한 후 함수 cat()으로 ‘1!=1’을 출력함으로써 첫 번째 연산이 종료된다. 두 번째 연산에서는 변수 i가 2가 되고 할당 기호 오른쪽의 fac.x는 이전 연산에서 할당된 1의 값을 갖고 있어서 1×2의 값이 다시 fac.x에 할당된다. 세 번째 연산에서는 변수 i가 3, 할당 기호 오른쪽의 fac.x는 1×2가 됨으로 1×2×3이 fac.x의 새로운 값이 된다. 네 번째와 다섯 번째도 동일한 작업이 반복되어 factorial 계산을 마치게 된다. 함수 cat()은 여러 개의 데이터 객체를 한데 묶어서 출력할 때 유용하게 사용되는 함수이다. 문자열 \"\\n\"을 입력하여 다음 연산의 결과가 새로운 줄에서 출력되도록 하였다. 7.3.2 while 루프 for 루프를 사용하기 위해서는 반복 횟수가 명확하게 정해져야 한다. 그러나 어떤 경우에는 특정 조건이 만족될 때까지 반복을 지속해야 할 때도 있다. 이런 상황에서는 for 루프를 사용할 수 없고, 대신 while 루프를 사용해야 한다. 함수 while()에 의한 루프 연산의 일반적인 사용법은 다음과 같다. 중괄호 안의 표현식은 조건이 만족되는 동안 계속해서 실행된다. while(조건){ 표현식 } for 루프 연산은 while 연산으로 전환이 가능하다. Factorial 계산 예제를 while 루프 연산으로 계산해 보자. 루프 연산 이전에 인덱스 변수 i에 초기값 1을 할당하고, 루프 연산마다 인덱스 변수에 1을 더해 주는 작업을 추가하면 전환이 가능하다. fac.x &lt;- 1 i &lt;- 1 while(i &lt;= 5){ fac.x &lt;- fac.x*i cat(i, &quot;!=&quot;, fac.x, &quot;\\n&quot;, sep=&quot;&quot;) i &lt;- i+1 } ## 1!=1 ## 2!=2 ## 3!=6 ## 4!=24 ## 5!=120 7.4 함수형 프로그래밍 동일한 작업이 반복되어야 하는 상황에서 루프 연산은 좋은 대안이라 할 수 있다. 하지만 루프 연산도 항상 좋은 평가를 받고 있는 것은 아니다. 프로그램의 의미 파악이 쉽지 않다는 문제가 자주 지적되곤 한다. 루프 연산에 대한 대안으로 제시되는 것이 함수형(functional) 프로그래밍이다. Functional이란 함수를 입력 변수로 받는 함수를 의미한다. 예를 들어 다음과 같이 정의된 함수 my_desc()는 벡터와 요약통계 함수를 입력 변수로 받아 자료의 요약통계량을 출력하는 단순한 형태의 functional이 된다. my_desc &lt;- function(x, fun) fun(x) set.seed(12) x &lt;- rnorm(20) my_desc(x, mean) ## [1] -0.3312091 my_desc(x, median) ## [1] -0.3043269 함수를 입력변수로 받을 수 있는 함수 중 중요하게 사용되는 함수가 lapply()와 sapply()이다. 함수 lapply()의 기본적인 사용법은 lapply(X, FUN, ...)이며, 여기서 X는 벡터 또는 리스트가 된다. 입력된 벡터 또는 리스트의 각 요소마다 FUN에 지정한 함수를 적용하여 그 결과를 리스트로 출력하는 것이 lapply()의 기본적인 작동 방식이다. set.seed(124) x &lt;- list(a1 = 1:5, a2 = rnorm(5), a3 = c(TRUE, FALSE, TRUE, TRUE)) lapply(x, mean) ## $a1 ## [1] 3 ## ## $a2 ## [1] -0.0943867 ## ## $a3 ## [1] 0.75 함수 sapply()는 사용법이 lapply()와 동일하지만 결과를 내보내는 방식이 sapply()는 벡터 혹은 행렬이 된다는 점에서 lapply()와 차이가 있다. sapply(x, mean) ## a1 a2 a3 ## 3.0000000 -0.0943867 0.7500000 함수 lapply() 또는 sapply()는 for 루프 연산을 함수형 프로그래밍으로 전환할 때 매우 유용하게 사용되는 함수이다. 예를 들어 데이터 프레임 iris에 있는 모든 변수의 class 속성을 확인해 보자. 우선 for 루프 연산을 이용해 보자. res &lt;- vector(&quot;character&quot;, length(iris)) for(i in seq_along(res)){ res[i] &lt;- class(iris[[i]]) } names(res) &lt;- names(iris) res ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; 동일한 내용의 작업을 함수 sapply()을 이용하여 실행해 보자. 훨씬 단순하고 쉽게 작업할 수 있음을 알 수 있다. sapply(iris, class) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; 루프 연산과 함수형 프로그래밍의 비교를 위한 또 다른 예제로 평균이 각각 -2, -1, 0, 1, 2이고 표준편차가 0.5인 정규분포에서 10개씩의 임의표본을 추출하여 평균값을 계산해보자. 먼저 루프 연산으로 실행해 보자. set.seed(1234) m &lt;- -2:2 res &lt;- vector(&quot;double&quot;, length(m)) for(i in seq_along(res)){ res[i] &lt;- mean(rnorm(n = 10, mean = m[i], sd = 0.5)) } res ## [1] -2.1915787 -1.0590854 -0.1939734 0.6169035 1.6951015 동일한 내용의 작업을 함수 lapply()와 sapply()를 이용해서 실행해 보자. 루프 연산에서는 실제로 두 가지 작업이 한꺼번에 수행되었는데, 하나는 정규분포에서 난수를 발생 하는 것이고, 다른 하나는 자료의 평균값을 계산하는 것이다. 함수형 프로그래밍에서는 두가지 작업을 분리하여 실행해야 할 것으로 보인다. 우선 다섯 개의 정규분포에서 10개의 난수를 각각 발생시켜, 그 결과를 리스트에 보관하는 작업을 lapply()로 실행해 보자. 이어서 리스트 각 요소에 mean()을 적용하는 것인데, 이 작업은 결과를 벡터로 출력하기 위해서 sapply()로 실행해 보자. set.seed(1234) m &lt;- -2:2 x &lt;- lapply(m, rnorm, n = 10, sd = 0.5) sapply(x, mean) ## [1] -2.1915787 -1.0590854 -0.1939734 0.6169035 1.6951015 만일 앞 예제에서 10개 자료에 대한 평균값뿐만이 아니라 표준편차 등 다른 요약통계량 값도 계산해야 한다고 하자. 함수 sapply()의 경우에는 mean 대신 sd를 입력하여 sapply(x, sd)를 한 번 더 실행하거나 또는 다른 필요한 함수를 대신 입력하면 되는 간단한 문제이지만, 루프 연산의 경우에는 프로그램에서 필요한 함수만 바꾸고 전체를 다시 입력하고 실행해야 되는 번거로운 일이 된다. 따라서 루프 연산을 사용하는 경우에라도 함수형 프로그래밍의 장점을 활용할 수 있도록 다음과 같이 사용자 정의 함수 안에 루프 연산을 집어넣는 것이 훨씬 효과적이다. my_desc &lt;- function(x, fun){ res &lt;- vector(&quot;double&quot;, length(x)) for(i in seq_along(res)){ res[i] &lt;- fun(x[[i]]) } return(res) } 함수 my_desc()는 루프 연산을 사용하고 있으나, 함수를 입력 변수로 지정할 수 있도록 조정하였다. 사실상 함수 sapply()와 동일한 함수라고 할 수 있다. set.seed(1234) m &lt;- -2:2 x &lt;- lapply(m, rnorm, n = 10, sd = 0.5) my_desc(x, mean) ## [1] -2.1915787 -1.0590854 -0.1939734 0.6169035 1.6951015 sapply(x, mean) ## [1] -2.1915787 -1.0590854 -0.1939734 0.6169035 1.6951015 my_desc(x, sd) ## [1] 0.4978938 0.5336688 0.3330006 0.4471229 0.3935776 sapply(x, sd) ## [1] 0.4978938 0.5336688 0.3330006 0.4471229 0.3935776 7.5 함수형 프로그래밍으로 행렬과 데이터 프레임 다루기 행렬과 데이터 프레임을 대상으로 데이터 분석할 때 반복된 작업이 필요한 경우가 있다. 예를 들어 주어진 행렬의 각 열 또는 각 행의 평균값을 계산해야 한다고 하자. 이런 경우에 for 루프에 의한 반복 작업보다는 함수형 프로그래밍을 적절하게 적용하면 매우 효과적으로 작업을 진행할 수 있다. 7.5.1 행렬에 함수형 프로그래밍 적용하기 행렬에 적용할 수 있는 functional은 함수 apply()이다. 기본적인 사용법은 apply(X, MARGIN, FUN, ...)인데, 여기서 X는 행렬 또는 배열이고, MARGIN은 FUN에 지정한 함수가 적용되는 방향을 나타내는 정수로써, MARGIN = 1이면 행 방향, MARGIN = 2이면 열 방향으로 함수를 적용한다. 예를 들어 A라는 행렬에 Park, Lee, Kim의 세 사람에 대한 반복된 측정값이 들어 있다고 하자. A ## trial1 trial2 trial3 trial4 ## Park 0.8 1.1 0.0 0.6 ## Lee 1.3 1.3 1.2 1.4 ## Kim 1.0 1.3 0.2 0.6 세 사람마다 반복 측정된 값들의 평균값을 apply()를 사용하여 계산해 보자. 이것은 행렬 A의 각 행에 mean()을 적용하는 것이므로 MARGIN = 1이 된다. apply(A, 1, mean) ## Park Lee Kim ## 0.625 1.300 0.775 함수의 적용 결과가 벡터로 나오게 되면 apply()의 결과는 행렬이 된다. apply(A, 1, range) ## Park Lee Kim ## [1,] 0.0 1.2 0.2 ## [2,] 1.1 1.4 1.3 이번에는 행렬 A 각 열의 평균값을 계산해 보자. apply(A, 2, mean) ## trial1 trial2 trial3 trial4 ## 1.0333333 1.2333333 0.4666667 0.8666667 7.5.2 데이터 프레임에 함수형 프로그래밍 적용하기 \\(\\bullet\\) 그룹별 요약통계량 계산 데이터 프레임의 변수 중에 요인이 있다면 그 요인의 수준(level)에 따라 다른 변수의 관찰값들을 따로 묶을 수 있다. 이런 경우 요인의 수준에 의해 구분되는 그룹에 따라 특정 변수의 분포에 어떤 차이가 있는지를 알아보는 것은 중요한 분석 과제가 될 수 있다. 이런 경우 사용할 수 있는 functional에는 함수 tapply()가 있다. 기본적인 사용법은 tapply(X, INDEX, FUN, simplify = TRUE)이다. 여기서 X는 벡터이고, INDEX는 요인, FUN은 요약통계량을 계산하는 함수이며, simplify는 출력 형태를 지정하는 것으로 디폴트(TRUE) 값이 주어지면 벡터, FALSE가 주어지면 리스트로 출력된다. 동일한 내용의 작업을 함수 split()과 lapply()를 연이어 사용해도 수행할 수 있다. 함수 split()은 벡터 혹은 데이터 프레임을 요인에 따라 그룹을 분리하여 리스트로 출력하는 기능을 갖고 있다. 사용법은 split(x, f)이며, x는 벡터 또는 데이터 프레임이고, f는 요인이다. 패키지 MASS에 있는 Cars93에는 요인으로 Origin이라는 변수가 있는데, USA와 non-USA의 2개 수준이 있다. 변수 MPG.city를 Origin에 따라 두 그룹으로 구분하여 평균값을 비교해 보자. 먼저 함수 tapply()로 그룹별 평균을 구해 보자. data(Cars93, package = &quot;MASS&quot;) with(Cars93, tapply(MPG.city, Origin, mean)) ## USA non-USA ## 20.95833 23.86667 with(Cars93, tapply(MPG.city, Origin, mean, simplify = FALSE)) ## $USA ## [1] 20.95833 ## ## $`non-USA` ## [1] 23.86667 이번에는 함수 split()으로 그룹별 자료를 분리하여 리스트에 저장하고, 이어서 함수 lapply() 또는 sapply()를 적용해 보자. x_g &lt;- with(Cars93, split(MPG.city, Origin)) str(x_g) ## List of 2 ## $ USA : int [1:48] 22 19 16 19 16 16 25 25 19 21 ... ## $ non-USA: int [1:45] 25 18 20 19 22 46 30 24 42 24 ... lapply(x_g, mean) ## $USA ## [1] 20.95833 ## ## $`non-USA` ## [1] 23.86667 sapply(x_g, mean) ## USA non-USA ## 20.95833 23.86667 그룹별 요약통계량을 구하는 작업은 패키지 dplyr의 함수 group_by()와 summarise()를 사용해도 구할 수 있다. library(dplyr) Cars93 %&gt;% group_by(Origin) %&gt;% summarise(m = mean(MPG.city), n = n()) ## # A tibble: 2 × 3 ## Origin m n ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 USA 21.0 48 ## 2 non-USA 23.9 45 \\(\\bullet\\) 데이터 프레임의 모든 변수에 함수 적용 행렬의 경우 모든 열에 특정 함수를 각각 적용시킬 때 사용할 수 있는 함수는 apply()이다. 즉, apply(X, 2, FUN)를 실행시키면 주어진 행렬 X의 모든 열에 특정 함수 FUN을 적용시킬 수 있다. 데이터 프레임도 행렬과 같이 2차원 배열이기 때문에 함수 apply()를 적용할 수는 있다. 그러나 함수 apply()를 데이터 프레임에 적용하여 원하는 결과를 얻기 위해서는 주어진 데이터 프레임의 모든 데이터들이 동일한 유형이어야 한다는 문제가 있다. 즉, 모두 숫자이거나 문자이어야 한다. 데이터 프레임의 모든 데이터들이 동일한 유형일 가능성은 높지 않기 때문에 함수 apply()를 사용하기에는 적절하지 않은 상황이 많을 것이다. 이런 경우 함수 lapply()와 sapply()를 대신 사용할 수 있다. 두 함수는 벡터나 리스트의 각 요소에 동일한 함수를 적용하는 기능을 가진 함수이다. 데이터 프레임은 행렬과 같은 2차원 구조이지만 함수 typeof()로 확인할 수 있는 유형은 리스트이다. 따라서 함수 lapply()나 sapply()를 사용할 수 있는데, 이 경우에는 데이터 프레임의 각 변수(열)에 동일한 함수가 적용된다. 패키지 MASS에 있는 데이터 프레임 cabbages에는 4개의 변수가 있는데, 이 변수들의 class 속성을 벡터로 출력하고자 한다면 어떻게 해야 하겠는가? 함수 sapply()를 이용하여 데이터 프레임 cabbages의 네 변수에 함수 class()를 적용시켜 보자. data(cabbages, package = &quot;MASS&quot;) sapply(cabbages, class) ## Cult Date HeadWt VitC ## &quot;factor&quot; &quot;factor&quot; &quot;numeric&quot; &quot;integer&quot; 함수 apply()로 데이터 프레임 cabbages에 있는 4개 변수의 class 속성을 확인해 보자. 함수 sapply()에 의한 결과와는 다르게 모든 변수가 문자형으로 나타났다. 어떤 문제가 발생한 것일까? apply(cabbages, 2, class) ## Cult Date HeadWt VitC ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; 데이터 프레임 airquality를 구성하는 모든 변수의 평균값을 구해 보자. 측정 일자를 나타내는 변수 Month와 Day를 제외한 네 변수의 평균값을 함수 sapply()로 계산해 보자. library(dplyr) airs &lt;- airquality %&gt;% select(-Month, -Day) airs %&gt;% sapply(mean, na.rm = TRUE) ## Ozone Solar.R Wind Temp ## 42.129310 185.931507 9.957516 77.882353 함수 sapply() 대신 패키지 dplyr의 함수 across()를 summarise()와 함께 사용해도 같은 결과를 얻을 수 있다. airs %&gt;% summarise(across(.fns = mean, na.rm = TRUE)) ## Warning: There was 1 warning in `summarise()`. ## ℹ In argument: `across(.fns = mean, na.rm = TRUE)`. ## Caused by warning: ## ! The `...` argument of `across()` is deprecated as of dplyr 1.1.0. ## Supply arguments directly to `.fns` through an anonymous function instead. ## ## # Previously ## across(a:b, mean, na.rm = TRUE) ## ## # Now ## across(a:b, \\(x) mean(x, na.rm = TRUE)) ## Ozone Solar.R Wind Temp ## 1 42.12931 185.9315 9.957516 77.88235 데이터 프레임 airquality의 분석 목적은 변수 Ozone의 변동을 Solar.R과 Wind, 그리고 Temp로 설명하는 모형을 만드는 것이다. 분석의 첫 단계로 네 변수 사이의 상관계수를 월별로 구분하여 계산해 보자. 함수 split()으로 데이터 프레임을 월별로 구분하여 리스트로 저장하고, 함수 lapply()를 사용하여 리스트의 각 요소인 월별로 구분된 데이터 프레임에 함수 cor()을 각각 적용시켜 상관계수를 계산하면 된다. 결측값이 있는 데이터이기 때문에 결측값을 제외하고 상관계수를 계산하기 위하여 use=\"pairwise\"를 추가해야 한다. airs %&gt;% split(airquality$Month) %&gt;% lapply(cor, use = &quot;pairwise&quot;) ## $`5` ## Ozone Solar.R Wind Temp ## Ozone 1.0000000 0.2428635 -0.3742975 0.5540792 ## Solar.R 0.2428635 1.0000000 -0.2268858 0.4547569 ## Wind -0.3742975 -0.2268858 1.0000000 -0.3732760 ## Temp 0.5540792 0.4547569 -0.3732760 1.0000000 ## ## $`6` ## Ozone Solar.R Wind Temp ## Ozone 1.0000000 0.7177528 0.3572546 0.6683386 ## Solar.R 0.7177528 1.0000000 0.3498991 0.4037639 ## Wind 0.3572546 0.3498991 1.0000000 -0.1210353 ## Temp 0.6683386 0.4037639 -0.1210353 1.0000000 ## ## $`7` ## Ozone Solar.R Wind Temp ## Ozone 1.0000000 0.4293259 -0.6673491 0.7227023 ## Solar.R 0.4293259 1.0000000 -0.1277751 0.3210154 ## Wind -0.6673491 -0.1277751 1.0000000 -0.3052355 ## Temp 0.7227023 0.3210154 -0.3052355 1.0000000 ## ## $`8` ## Ozone Solar.R Wind Temp ## Ozone 1.0000000 0.5296827 -0.7085496 0.5978993 ## Solar.R 0.5296827 1.0000000 -0.1650273 0.3929261 ## Wind -0.7085496 -0.1650273 1.0000000 -0.5076146 ## Temp 0.5978993 0.3929261 -0.5076146 1.0000000 ## ## $`9` ## Ozone Solar.R Wind Temp ## Ozone 1.0000000 0.1803730 -0.6104514 0.8281521 ## Solar.R 0.1803730 1.0000000 -0.1013448 0.1230107 ## Wind -0.6104514 -0.1013448 1.0000000 -0.5704701 ## Temp 0.8281521 0.1230107 -0.5704701 1.0000000 만일 월별로 변수 Ozone과 Solar.R의 상관계수만을 계산하여 벡터로 출력하고자 한다면 sapply()에 사용자 정의 함수를 입력하면 된다. 아래에 입력된 사용자 정의 함수는 함수 이름이 없는 일명 anonymous 함수이다. airs %&gt;% split(airquality$Month) %&gt;% sapply(function(df) with(df, cor(Ozone, Solar.R, use = &quot;pairwise&quot;))) ## 5 6 7 8 9 ## 0.2428635 0.7177528 0.4293259 0.5296827 0.1803730 7.6 purrr에 의한 프로그래밍 루프 연산의 대안으로써 살펴본 함수 lapply() 등은 base R에 속한 함수이다. 나름의 역할을 충실하게 수행한다고 할 수 있으나, 더 개선된 기능을 갖고 있는 함수들이 core tidyverse에 속한 패키지 purrr에 마련되어 있다. 대표적인 함수는 map()으로서, 기본적인 사용법은 map(.x, .f, ...)이다. 여기서 .x는 벡터 혹은 리스트이고 .f는 .x의 각 요소에 적용하고자 하는 함수이며, 결과는 리스트로 출력된다. 예를 들어 아래에 주어진 리스트 x를 구성하는 세 벡터의 평균을 각각 구해 보자. library(tidyverse) set.seed(124) x &lt;- list(a1 = 1:5, a2 = rnorm(5), a3 = c(TRUE, FALSE, TRUE, TRUE)) map(x, mean) ## $a1 ## [1] 3 ## ## $a2 ## [1] -0.0943867 ## ## $a3 ## [1] 0.75 함수 map()으로 리스트 x의 세 요소인 x$a1, x$a2, x$a3에 mean()을 각각 적용하여 생성된 결과가 리스트로 출력되었다. 만일 결과를 리스트가 아닌 벡터로 출력하고자 한다면, 출력되는 벡터의 유형에 따라 map_lgl(), map_int(), map_dbl(), map_chr() 중 하나를 선택하면 된다. 또한 결과를 데이터 프레임의 형태로 출력하고자 한다면, map_dfr() 또는 map_dfc() 중 하나를 선택하면 된다. 예를 들어 위에 주어진 리스트 x를 구성하는 세 요소의 평균은 소수점이 있는 숫자이므로 함수 map_dbl()을 이용해야 숫자형 벡터로 출력된다. map_dbl(x, mean) ## a1 a2 a3 ## 3.0000000 -0.0943867 0.7500000 함수 map()에는 생략부호(...) 변수가 포함되어 있어서 .f에 전달되는 부가적인 옵션을 추가할 수 있다. 데이터 프레임 airquality의 변수 Ozone, Solar.R, Wind, Temp의 평균을 계산하는 경우에, 함수 mean()에 결측값을 제외하는 옵션 na.rm = TRUE를 다음과 같이 추가할 수 있다. airs &lt;- airquality %&gt;% select(-c(Month, Day)) airs %&gt;% map_dbl(mean, na.rm = TRUE) ## Ozone Solar.R Wind Temp ## 42.129310 185.931507 9.957516 77.882353 함수 map()에는 사용자 정의 함수를 입력해서 사용할 수 있다. 위에서 정의된 데이터 프레임 airs의 네 변수의 평균을 anonymous 함수로 계산해 보자. airs %&gt;% map_dbl(function(x) sum(x, na.rm = TRUE)/sum(!is.na(x))) ## Ozone Solar.R Wind Temp ## 42.129310 185.931507 9.957516 77.882353 사용자 정의함수를 입력해서 사용할 수 있다는 것은 함수 lapply()에서도 가능한 것이다. 차이점은 함수 map()에서는 조금 더 간편한 방식으로 함수를 정의할 수 있다는 것이다. 사용자 정의함수는 반드시 function(x)로 시작하는데, 이것을 물결표(~)로 대치할 수 있고, 한 변수만이 사용되는 함수에서는 .x를 변수 대신 사용할 수 있다. 따라서 위의 예는 다음과 같이 작성할 수 있다. airs %&gt;% map_dbl(~ sum(.x, na.rm = TRUE)/sum(!is.na(.x))) ## Ozone Solar.R Wind Temp ## 42.129310 185.931507 9.957516 77.882353 두 개의 변수가 사용되는 함수에서는 .x와 .y를 두 변수 대신 사용하고, 세 개 이상의 변수가 사용되는 함수에서는 ..1, ..2, ..3 등을 대신 사용하면 된다. 사용자 정의 함수를 사용하는 다른 예제로써 데이터 프레임 airquality의 변수 Ozone과 Solar.R의 상관계수를 월별로 계산해 보자. 우선 airquality를 함수 split()을 사용하여 월별로 구분한 결과를 리스트에 할당하고 이어서 함수 cor()로 이루어진 사용자 정의 함수를 map()에 다음과 같이 입력하면 된다. airquality %&gt;% split(airquality$Month) %&gt;% map_dbl(~ with(.x, cor(Ozone, Solar.R, use = &quot;pairwise&quot;))) ## 5 6 7 8 9 ## 0.2428635 0.7177528 0.4293259 0.5296827 0.1803730 이 문제는 함수 map()을 사용하지 않고 패키지 dplyr의 함수 nest_by()를 사용하여 rowwise 데이터 프레임을 구성하는 방법으로도 해결할 수 있다. 함수 nest_by()로 생성된 데이터 프레임은 첫 번째 열은 그룹 변수인 Month이고, 두 번째 열은 나머지 변수로 구성된 리스트로서 이름이 data이다. 데이터 프레임의 한 열을 리스트로 구성하는 것은 매우 특이한 상황으로 보일 수 있으나, 자료 분석 과정을 상당히 간편하게 만들 수 있는 대단히 뛰어난 아이디어라고 하겠다. airquality %&gt;% nest_by(Month) ## # A tibble: 5 × 2 ## # Rowwise: Month ## Month data ## &lt;int&gt; &lt;list&lt;tibble[,5]&gt;&gt; ## 1 5 [31 × 5] ## 2 6 [30 × 5] ## 3 7 [31 × 5] ## 4 8 [31 × 5] ## 5 9 [30 × 5] 이제 rowwise 데이터 프레임의 특성을 활용하여 각 행별로 data에 있는 두 변수의 상관계수를 구해보자. airquality %&gt;% nest_by(Month) %&gt;% summarise(rho = with(data, cor(Ozone, Solar.R, use = &quot;pairwise&quot;))) ## # A tibble: 5 × 2 ## # Groups: Month [5] ## Month rho ## &lt;int&gt; &lt;dbl&gt; ## 1 5 0.243 ## 2 6 0.718 ## 3 7 0.429 ## 4 8 0.530 ## 5 9 0.180 함수 map()의 .f 위치에 함수 대신 문자나 숫자 또는 리스트가 입력되면, 특정 요소를 선택하는 일종의 인덱싱이 이루어진다. 예를 들어 다음의 리스트 df1을 구성하고 있는 세 벡터의 두 번째 요소를 선택해 보자. 함수 map()에 숫자가 입력되면 선택할 위치를 지정하는 것으로써, 리스트 df1을 구성하는 각 벡터의 두 번째 요소를 선택하게 된다. df1 &lt;- list(x1 = 1:3, x2 = 2:4, x3 = 3:6) map_int(df1, 2) ## x1 x2 x3 ## 2 3 4 이번에는 문자를 입력하여 특정 요소를 선택하는 예제를 살펴보자. 예를 들어 \\(N(-1,1)\\) 과 \\(N(1,1)\\) 에서 각각 발생시킨 5개의 난수를 함수 summary()에 입력하여 계산된 요약통계량 값을 리스트에 할당해 보자. set.seed(123) df2 &lt;- list(x1 = rnorm(n = 5, mean = -1), x2 = rnorm(n = 5, mean = 1)) %&gt;% map(summary) df2 ## $x1 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -1.5605 -1.2302 -0.9295 -0.8064 -0.8707 0.5587 ## ## $x2 ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## -0.2651 0.3131 0.5543 0.9557 1.4609 2.7151 리스트 df2의 각 요소에서 \"Mean\"으로 이름이 붙여진 자료를 선택해 보자. 즉, 두 종류 자료에 대한 요약 통계량을 각각 계산하고, 그 중 평균값을 추출하는 작업이 된다. df2 %&gt;% map_dbl(&quot;Mean&quot;) ## x1 x2 ## -0.8064297 0.9556810 선택된 자료가 df2를 구성하고 있는 벡터들의 네 번째 자료이므로 map_dbl(df2, 4)를 실행해도 같은 결과를 얻을 수 있다. 함수 map()은 하나의 리스트(혹은 벡터)의 각 구성요소에 특정 함수를 반복 적용시킬 때 사용되는 함수이다. 만일 두 개의 리스트(혹은 벡터)를 입력 변수로 하여 특정 함수를 반복 적용시켜야 하는 경우가 있다면 map2()가 사용될 수 있다. 기본적인 사용법은 map2(.x, .y, .f, ...)이며, .x와 .y는 두 개의 입력 리스트(혹은 벡터)로서 길이가 같아야 한다. 길이가 1인 벡터의 경우에만 순환법칙이 적용된다. 정규분포에서 난수를 발생시키되 \\(N(-5, 2^{2})\\) 과 \\(N(5, 1^{2})\\) 의 경우와 같이 평균과 표준편차가 모두 다른 경우를 생각해 보자. 이 경우에는 -5와 5가 입력된 벡터 mu를 .x에, 2와 1이 입력된 벡터 sigma를 .y에 지정하여 map2()에 입력하고 이어서 rnorm()을 입력하면 된다. mu &lt;- c(x1 = -5, x2 = 5) sigma &lt;- c(x1 = 2, x2 = 1) set.seed(123) map2(.x = mu, .y = sigma, rnorm, n = 5) ## $x1 ## [1] -6.120951 -5.460355 -1.882583 -4.858983 -4.741425 ## ## $x2 ## [1] 6.715065 5.460916 3.734939 4.313147 4.554338 결과를 데이터 프레임으로 출력하고자 하는 경우에는 함수 map()의 경우에서처럼 map2_dfc()를 대신 사용하면 된다. set.seed(123) map2_dfc(.x = mu, .y = sigma, rnorm, n = 5) ## # A tibble: 5 × 2 ## x1 x2 ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -6.12 6.72 ## 2 -5.46 5.46 ## 3 -1.88 3.73 ## 4 -4.86 4.31 ## 5 -4.74 4.55 7.7 연습문제 1. 데이터 프레임 airquality 에서 숫자형 변수의 요약 통계량을 월별로 계산하고자 한다 변수 Ozone의 월별 평균값을 다음과 같이 나타내 보자. ## 5 6 7 8 9 ## 23.61538 29.44444 59.11538 59.96154 31.44828 변수 Ozone의 월별 평균, 표준편차와 측정된 날수를 다음의 형식으로 나타내 보자. ## 5 6 7 8 9 ## Mean 23.61538 29.44444 59.11538 59.96154 31.44828 ## Sd 22.22445 18.20790 31.63584 39.68121 24.14182 ## N 26.00000 9.00000 26.00000 26.00000 29.00000 변수 Ozone의 월별 평균, 표준편차와 측정된 날수를 다음의 형식으로 나타내 보자. ## # A tibble: 5 × 4 ## Month Mean Sd N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5 23.6 22.2 26 ## 2 6 29.4 18.2 9 ## 3 7 59.1 31.6 26 ## 4 8 60.0 39.7 26 ## 5 9 31.4 24.1 29 2. 데이터 프레임 iris를 구성하고 있는 변수들의 유형을 파악하여 유형별로 적절한 요약통계를 계산해 보자 함수 map()을 사용하여 iris 변수들의 유형을 파악하고 다음과 같이 벡터로 출력해 보자. ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; 함수 map2()을 사용하여 변수의 유형이 numeric인 경우에는 평균을 계산하고, 유형이 factor인 경우에는 범주의 개수를 계산하여 다음과 같이 출력해 보자. ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 5.843333 3.057333 3.758000 1.199333 3.000000 "],["chapter-distribution.html", "8 장 확률분포 8.1 R에서의 확률분포 이름 8.2 연속형 확률분포 8.3 이산형 분포 8.4 모의실험", " 8 장 확률분포 확률분포와 관련된 이론들은 통계학의 기본이라고 할 수 있다. R에는 확률과 연관된 많은 함수들이 있다. 이러한 함수들을 이용하면 다양한 확률분포들을 대상으로 특정 사건이 발생할 확률을 계산할 수도 있고, 특정 분포의 분위수를 구할 수도 있으며, 특정 모집단에서 난수를 발생시킬 수도 있다. 8.1 R에서의 확률분포 이름 R에는 각각의 확률분포를 지칭하는 이름이 있다. 예를 들어 정규분포는 “norm”이라는 이름으로 불리는데, 이 이름을 근간으로 하여 그 앞자리에 d, p, q, r을 하나씩 붙이는 방식으로 아래와 같이 분포와 관련된 네 종류의 함수가 정의된다. 함수 기능 dnorm 확률밀도함수 pnorm 누적분포함수 qnorm 분위수함수 rnorm 난수발생함수 일반적으로 많이 사용되는 연속형 확률분포와 이산형 확률분포의 R 이름 및 그 이름을 근간으로 정의되는 분포와 관련된 네 종류의 함수에서 중요한 역할을 하는 모수들이 아래의 두 표에 정리되어 있다. 연속형 확률분포의 R 이름 연속형 확률분포 R 이름 관련된 모수 베타분포 beta shape1 , shape2 : 베터분포의 두 모수 코쉬분포 cauchy location : 위치모수, scale : 척도모수 카이제곱분포 chisq df : 자유도 지수분포 exp rate : 비율 (평균의 역수) F-분포 f df1 df2 : 자유도 감마분포 gamma shape : 형태모수, scale : 척도모수 로지스틱분포 logis location : 위치모수, scale : 척도모수 정규분포 norm mean : 평균, sd : 표준편차 t-분포 t df : 자유도 균등분포 unif min : 하한, max : 상한 와이블분포 weibull shape : 형태모수, scale : 척도모수 이산형 확률분포의 R 이름 이산형 확률분포 R 이름 관련된 모수 이항분포 binorm size : 실행횟수, prob : 성공 확률 기하분포 geom prob : 성공확률 초기하분포 hyper m : 바구니 속 흰 공 개수, n : 바구니 속 검은 공 개수, k : 바구니에서 추출된 공의 개수 음이항분포 nbinom size : 성공 실행 횟수의 목푝값, prob : 성공확률 포아송분포 pois lambda : 평균 위의 두 표에 정리되어 있는 분포들은 모두 R의 base 시스템에 설치되어 있는데, 이외에도 다양한 분야에서 사용되는 많은 분포들이 여러 패키지에 설치되어 있다. 확률분포와 관련된 패키지의 소개는 CRAN Task View: Probability Distributions 을 참고하기 바란다. 8.2 연속형 확률분포 일반적으로 가장 빈번하게 사용되는 정규분포, 지수분포, 균등분포 그리고 t-분포와 관련된 R 함수들의 사용법을 자세하게 살펴보자. 8.2.1 정규분포 정규분포와 관련된 네 종류 함수들의 일반적인 사용법은 다음과 같다. 함수 사용법 확률밀도함수 dnorm(x, mean = 0, sd =1) 누적분포함수 pnorm(q, mean = 0, sd = 1, lower.tail = TRUE) 분위수함수 qnorm(p, mean = 0, sd = 1, lower.tail = TRUE) 난수발생함수 rnorm(n, mean = 0, sd = 1) 단, x는 확률변수가 취하는 값, q는 분위수, p는 확률, n은 표본 크기를 각각 나타낸다. 정규분포와 관련된 함수들에서 공통적으로 사용된 mean과 sd는 모집단의 평균과 표준편차를 나타내는 것으로 각각 0과 1을 디폴트 값으로 하고 있다. 따라서 표준정규분포를 대상으로 하는 경우에는 mean과 sd를 생략할 수 있으나, 일반적인 정규분포를 대상으로 하는 경우에는 반드시 평균과 표준편차를 따로 지정해야 한다. 함수 dnorm()은 정규분포의 확률밀도함수 값을 계산하는 함수이다. 이 함수를 이용하여 정규분포 확률밀도함수의 그래프를 그려 보자. 예를 들어 표준정규분포의 확률밀도함수와 평균이 1, 표준편차가 0.5인 정규분포의 확률밀도함수를 -3에서 3의 구간에서 그려보자. ggplot2에서 특정 함수의 그래프 작성은 stat_function()으로 할 수 있다. 이 경우 입력되는 데이터 프레임은 X축의 범위를 지정하는 두 숫자로만 구성하면 된다. library(tidyverse) ggplot(tibble(x = c(-3, 3)), aes(x)) + stat_function(fun = dnorm) + labs(title = &quot;Standard Normal Distribution&quot;, x = NULL, y = NULL) 그림 8.1: 표준정규분포 확률밀도함수 그래프 표준정규분포는 함수 dnorm()의 디폴트 상태이므로 추가로 입력해야 할 것이 없었으나, 평균이 1이고 표준편차가 0.5인 정규분포의 경우에는 dnorm()의 mean과 sd 값을 수정해야 한다. 이러한 경우에는 함수 stat_function()의 변수 args에 수정된 값을 리스트 형태로 입력해야 한다. 또한 제목에 수학 기호 등을 포함시킬 수 있는데, 수학 기호에 대한 R 표현식을 함수 expression()에 입력하여 함수 labs()의 title에 지정하면 된다. ggplot(tibble(x = c(-3, 3)), aes(x)) + stat_function(fun = dnorm, args = list(mean = 1, sd = 0.5)) + labs(title = expression(list(mu==1,sigma==0.5)), y = NULL, x = NULL) 그림 8.2: 정규분포 확률밀도함수 그래프 함수 pnorm()은 정규분포의 누적분포함수의 값을 계산하는 함수이다. 따라서 \\(X \\sim N(m, s^{2})\\) 경우 \\(P(X \\leq q)\\) 계산은 pnorm(q, mean = m, sd = s)으로 할 수 있으며, \\(P(X &gt; q)\\) 값을 계산하고자 한다면 pnorm(q, mean = m, sd = s, lower.tail = FALSE)를 실행시켜야 한다. pnorm(0) ## [1] 0.5 pnorm(-1.96) ## [1] 0.0249979 pnorm(1.96, lower.tail = FALSE) ## [1] 0.0249979 연속형 확률변수 \\(X\\) 의 누적분포함수 \\(F(x)\\) 와 확률밀도함수 \\(f(x)\\) 의 관계는 다음과 같다. \\[ F(x) = \\int_{-\\infty}^{x}f(t)dt \\] 위 관계를 함수 pnorm()과 dnorm()을 이용하여 확인해 보자. 예를 들어 pnorm(1.645)은 표준정규분포의 확률변수가 1.645 이하의 값을 가질 확률이며, 이 값은 함수 dnorm()을 음의 무한대에서 1.645까지 적분한 결과와 같아야 한다. R에서 1차원 함수의 수치적분은 함수 integrate()로 할 수 있으며 일반적인 사용법은 integrate(FUN, lower, upper)이다. 수치적분의 오차가 무시할만한 수준이며, 계산된 두 확률이 동일함을 알 수 있다. pnorm(1.645) ## [1] 0.9500151 integrate(dnorm, -Inf, 1.645) ## 0.9500151 with absolute error &lt; 8.7e-08 표준정규분포와 평균이 1, 표준편차가 0.5인 정규분포의 누적분포함수 그래프를 작성해 보자. 함수 stat_function()에 pnorm()을 입력하는 것 외에는 정규분포의 확률밀도함수 그래프 작성과 동일함을 알 수 있다. ggplot(tibble(x = c(-3, 3)), aes(x)) + stat_function(fun = pnorm) + labs(title = &quot;Cumulative Standard Normal Distribution&quot;, y = NULL, x = NULL) 그림 8.3: 표준정규분포 누적분포함수 그래프 ggplot(tibble(x = c(-3, 3)), aes(x)) + stat_function(fun = pnorm, args = list(mean = 1, sd = 0.5)) + labs(title = expression(paste(&quot;Cumulative Distribution of&quot;,~N(1,0.5^2))), y = NULL, x = NULL) 그림 8.4: 정규분포 누적분포함수 그래프 분위수함수는 누적분포함수의 역함수라고 할 수 있다. 즉, qnorm(p)는 \\(p = P(X \\leq q)\\) 되는 q를 찾아 주며, qnorm(p, lower.tail=FALSE)는 \\(p = P(X &gt; q)\\) 가 되는 q를 찾아준다. qnorm(0.5) ## [1] 0 qnorm(pnorm(1)) ## [1] 1 c(qnorm(.025), qnorm(.975)) ## [1] -1.959964 1.959964 기초 통계학 수준의 서적에서 흔히 볼 수 있는 표준정규분포의 확률표는 함수 pnorm()과 qnorm()을 적절하게 사용하면 더 이상 참조할 필요가 없을 것이다. 함수 rnorm()은 정규분포에서 난수를 발생시키는 기능을 갖고 있다. 특정 분포에서 난수를 발생시키는 작업은 계산통계분야에서 가장 중요한 기본이 되는데, 검정과 모의실험 등 여러 방면에서 매우 필요한 작업이 된다. 표준정규분포 모집단에서 1000개의 자료를 추출하여 히스토그램을 작성해 보자. 작성된 히스토그램에 표준정규분포의 확률밀도함수 그래프도 덧붙여 그려보자. 히스토그램을 확률밀도함수의 그래프와 덧붙여 그리기 위해서는 히스토그램 막대의 높이를 함수 geom_histogram()에서 계산된 변수 after_stat(density)로 설정해야 한다. 또한 히스토그램의 구간 설정은 구간의 폭을 지정하는 binwidth 또는 구간의 개수를 지정하는 bins으로 할 수 있으며, 디폴트는 bins = 30이다. set.seed(123) ggplot(tibble(x = rnorm(1000))) + geom_histogram(aes(x = x, y = after_stat(density)), bins = 20) + stat_function(fun = dnorm, color = &quot;red&quot;, size = 1) + labs(x = NULL, y = NULL) ## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. ## ℹ Please use `linewidth` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. 그림 8.5: 표준정규분포에서 발생된 1000개 난수의 히스토그램 8.2.2 지수분포 지수분포는 어떤 특정 사건이 일어날 때까지 걸리는 시간을 나타내는 분포로 빈번하게 사용되고 있다. 예를 들어 어떤 도로의 특정 지점에 다음 차가 지나갈 때까지 걸리는 시간, 전화가 올 때까지 걸리는 시간 등의 분포로 지수분포가 사용된다. 지수분포의 확률밀도함수는 다음과 같다. \\[ f(x)= \\lambda~ e^{-\\lambda ~x} \\] 단, \\(x \\geq 0\\), \\(\\lambda &gt; 0\\) . 평균과 분산은 각각 \\(E(X) = 1/\\lambda\\), \\(Var(X) = 1/\\lambda^{2}\\) 이다. 지수분포와 관련된 R 함수들의 일반적인 사용법은 다음과 같다. 단, 모수 rate는 \\(\\lambda\\) 를 의미한다. 함수 사용법 확률밀도함수 dexp(x, rate = 1) 누적분포함수 pexp(q, rate = 1, lower.tail = TRUE) 분위수함수 qexp(p, rate = 1, lower.tail = TRUE) 난수발생함수 rexp(n, rate = 1) 모수 \\(\\lambda = 1, 2, 3\\) 인 지수분포의 확률밀도함수를 하나의 그래프에 나타내 보자. 함수 stat_function()을 세 번 사용하여, 각 \\(\\lambda\\) 값에 대한 그래프를 작성하면서 시각적 요소 color에 각 곡선의 라벨을 함수 aes() 안에서 매핑함으로써 범례가 추가되도록 하였다. ggplot(tibble(x = c(0, 4)), aes(x)) + stat_function(aes(color = &quot;rate = 1&quot;), fun = dexp, size = 1.2) + stat_function(aes(color = &quot;rate = 2&quot;), fun = dexp, args = list(rate = 2), size = 1.2) + stat_function(aes(color = &quot;rate = 3&quot;), fun= dexp, args= list(rate = 3), size = 1.2) + labs(title = &quot;Exponential \\n Distribution&quot;, color = NULL, x = NULL, y = NULL) 그림 8.6: 지수분포 확률밀도함수 그래프 지수분포를 이용해서 해결해야 하는 확률 문제들이 많이 있는데, 함수 pexp()를 이용하면 쉽게 해결할 수 있다. 예를 들어 다음의 문제를 풀어보자. 어떤 은행의 창구대기 시간이 오후 1시쯤에는 평균 5분이 된다고 한다. 오후 1시에 은행에 도착한 사람이 대기 번호표를 뽑고 기다리는 시간이 5분 이상이 될 확률과 5분에서 10분 사이가 될 확률을 구해 보자. 대기시간의 평균이 5분이므로 함수 pexp()에 사용될 모수 rate의 값은 1/5이 되며, 문제의 답은 다음과 같다. pexp(5, rate = 1/5, lower.tail = FALSE) # 5분 이상 ## [1] 0.3678794 pexp(10, rate = 1/5) - pexp(5, rate = 1/5) # 5분에서 10분 사이 ## [1] 0.2325442 함수 qexp()와 rexp()의 사용법 및 의미 등에 대한 설명은 생략하겠다. 8.2.3 균등분포 구간 \\([\\alpha, \\beta]\\) 에서 정의된 균등분포는 그 구간에 걸쳐서 값이 균등하게 퍼져 있는 모집단을 묘사할 때 유용하게 사용되는 분포이다. 확률변수 \\(X \\sim Unif(\\alpha, \\beta)\\) 의 확률밀도함수는 다음과 같은 상수가 된다. \\[ f(x) = \\frac{1}{\\beta - \\alpha}, ~~\\alpha \\leq x \\leq \\beta \\] 균등분포와 관련된 R 함수의 일반적인 사용법은 다음과 같다. 함수 사용법 확률밀도함수 dunif(x, min = 0, max = 1) 누적분포함수 punif(q, min = 0, max = 1, lower.tail = TRUE) 분위수함수 qunif(p, min = 0, max = 1, lower.tail = TRUE) 난수발생함수 runif(n, min = 0, max = 1) 균등분포의 확률밀도함수와 누적분포함수의 그래프는 앞 절에서 설명된 방법을 거의 그대로 적용시키면 쉽게 작성할 수 있을 것이며, 균등분포와 관련된 확률 문제도 앞 절에서 설명된 방법을 함수 punif()에 적용하면 어렵지 않게 해결할 수 있을 것이다. 10,000개의 표본을 \\(Unif(0, 1)\\) 에서 임의로 추출하고, 그 분포를 히스토그램으로 나타내 보자. set.seed(134) tibble(x = runif(10000)) %&gt;% ggplot(aes(x, y = after_stat(density))) + geom_histogram(bins = 500) + labs(x = NULL, y = NULL) 그림 8.7: 균등분포에서 추출된 표본의 히스토그램 8.2.4 t-분포 통계량의 표본분포로 자주 사용되는 분포는 t-분포와 F-분포, 그리고 카이제곱분포이다. 표본크기와 관련된 자유도를 모수로 갖고 있는 분포이며, 각 분포의 R 이름은 각각 t, f, chisq이다. 이들 중 t-분포와 관련된 R 함수들의 일반적인 사용법은 다음과 같다. 함수 사용법 확률밀도함수 dt(x, df) 누적분포함수 pt(q, df, lower.tail = TRUE) 분위수함수 qt(p, df, lower.tail = TRUE) 난수발생함수 rt(n, df) 자유도를 나타내는 df에는 디폴트로 지정된 값이 없음을 알 수 있다. t-분포는 표준정규분포와 동일하게 0을 중심으로 좌우 대칭이지만 분포의 꼬리가 정규분포보다 두껍다는 특징이 있다. 이것을 그래프로 나타내보자. ggplot(tibble(x = c(-7, 7)), aes(x)) + stat_function(aes(color = &quot;N(0,1)&quot;), fun = dnorm, size = 1.2) + stat_function(aes(color = &quot;t(1)&quot;), fun = dt, args = list(df = 1), size = 1.2) + stat_function(aes(color = &quot;t(2)&quot;), fun = dt, args = list(df = 2), size = 1.2) + labs(title = &quot;Normal Distribution \\n and t-Distribution&quot;, color = NULL, x = NULL, y = NULL) 그림 8.8: 정규분포와 t-분포의 확률밀도함수 그래프 8.3 이산형 분포 이산형 확률분포 중 빈번하게 사용되는 분포들과 관련된 R 함수들의 사용법을 살펴보자. 8.3.1 베르누이 분포와 이항분포 확률변수 \\(X\\) 가 베르누이 분포를 따른다고 하면 \\(X\\) 가 가질 수 있는 값은 0 혹은 1이 되어야 하며, 분포는 다음과 같아야 한다. \\[ P(X=x)=p^{x}(1-p)^{1-x},~~x=0,1 \\] \\(X=1\\) 이 되는 사건을 우리는 종종 ‘성공’이라고 부르고, \\(X=0\\) 이 되는 사건을 ’실패’라고 부른다. 베르누이 시행이란 연속된 통계적 실험으로서, 실험의 결과가 ’성공’ 또는 ‘실패’ 중 하나로 나타나며 ’성공’의 확률은 고정되어 있고 각각의 실험이 서로 독립인 경우를 말한다. 베르누이 시행을 R에서 실시하고자 한다면 함수 sample()을 이용하면 된다. 예를 들어 동전을 10번 던지는 실험에 대응되는 모의실험은 다음과 같다. set.seed(134) sample(c(&quot;H&quot;, &quot;T&quot;), size = 10, replace = TRUE) ## [1] &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; 위의 예는 \\(P(H)=P(T)=0.5\\) 가 되는 경우이다. 만일 ’성공’의 확률을 0.2로 하는 베르누이 시행을 실시하고자 한다면 변수 prob를 추가하면 된다. set.seed(134) sample(c(&quot;H&quot;, &quot;T&quot;), size = 10, replace = TRUE, prob = c(0.2, 0.8)) ## [1] &quot;T&quot; &quot;T&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; &quot;H&quot; 확률변수 \\(X\\) 가 \\(n\\) 번의 베르누이 시행에서의 성공 횟수를 나타내는 것이라면 \\(X\\) 의 분포는 이항분포가 된다. 만일 베르누이 시행의 성공확률이 \\(p\\) 라고 하면 \\(X \\sim B(n, p)\\) 로 표시하며, 확률분포함수는 다음과 같다. \\[ P(X=x)= \\binom{n}{k} p^{x} (1-p)^{n-x}, ~~~x=0,1,\\ldots,n \\] 이항분포와 관련된 R 함수의 일반적인 사용법은 다음과 같다. 변수 size는 베르누이 시행 횟수를 나타내며 prob는 성공확률을 의미한다. 함수 사용법 확률분포함수 dbinom(x, size, prob) 누적분포함수 pbinom(q, size, prob, lower.tail = TRUE) 분위수함수 qbinom(p, size, prob, lower.tail = TRUE) 난수발생함수 rbinom(n, size, prob) 함수 dbinom()을 사용하여 \\(X \\sim B(10, 0.5)\\) 의 확률분포함수 그래프를 작성해 보자. 입력된 자료 그대로를 사용하여 막대 그래프를 작성하도록 함수 geom_col()을 사용하였고, 막대 폭을 좁게 하여 이산형 확률분포함수를 표현하기 위해 옵션 width = 0.3을 사용하였다. X축의 눈금을 직접 입력하기 위해 함수 scale_x_continuous()에 breaks를 사용하여, 막대마다 해당되는 확률변수의 값을 눈금으로 지정하였다. tibble(x = 0:10, y = dbinom(x, size = 10, prob = 0.5)) %&gt;% ggplot(aes(x, y)) + geom_col(width = 0.3) + scale_x_continuous(breaks = 0:10) + labs(title = &quot;B(10,0.5)&quot;, y = NULL, x = NULL) 그림 8.9: 이항분포의 확률분포함수 그래프 이항분포와 관련된 확률 문제를 함수 dbinom()과 pbinom()을 이용하여 해결해 보자. 예를 들어 \\(X \\sim B(10, 0.5)\\) 의 경우에 다음 사건에 대한 확률을 계산해 보자. \\(P(X=5)\\) \\(P(X \\leq 6)\\) \\(P(X \\geq 7)\\) 각 사건에 대한 확률을 다음과 같이 구할 수 있다. # 1) dbinom(5, size = 10, prob = 1/2) ## [1] 0.2460938 # 2) sum(dbinom(0:6, size = 10, prob = 1/2)) ## [1] 0.828125 pbinom(6, size = 10, prob = 1/2) ## [1] 0.828125 # 3) sum(dbinom(7:10, size = 10, prob = 1/2)) ## [1] 0.171875 1-pbinom(6, size = 10, prob = 1/2) ## [1] 0.171875 pbinom(6, size = 10, prob = 1/2, lower.tail = FALSE) ## [1] 0.171875 함수 pbinom()에 옵션 lower.tail = FALSE가 사용되면 계산되는 확률은 \\(P(X&gt;k)\\) 이 된다. 따라서 \\(P(X \\geq 7)\\) 을 계산하고자 한다면 함수 pbinom()에 7이 아닌 6을 입력해야 한다. 함수 sample()을 이용하여 R에서 베르누이 시행에 대한 모의실험을 실시하는 방법은 이미 살펴보았다. 함수 rbinom()을 이용해도 동일한 실험을 실시할 수 있다. 1은 성공, 0은 실패를 나타내는 것이고 prob = 0.2는 성공확률, 즉 \\(P(x=1)=0.2\\) 를 의미하는 것이다. set.seed(12) rbinom(10, size = 1, prob = 0.2) ## [1] 0 1 1 0 0 0 0 0 0 0 \\(X \\sim B(n, p)\\) 의 경우, \\(n\\) 이 커지게 되면 확률분포함수가 정규분포 \\(N(np, np(1-p))\\) 로 접근해 간다. 이것을 R에서 나타내 보자. 우선 특정 사건이 발생할 확률을 이항분포에서 구한 값이 \\(n\\) 이 커짐에 따라 정규분포에서 구한 값에 수렴해 가는 현상을 살펴보자 예를 들어 확률변수 \\(X\\) 를 주사위를 \\(n\\) 번 던져 1의 눈이 나온 횟수라고 할 때, 다음의 확률을 이항분포와 정규분포에서 각각 계산해 보자. 10번 주사위를 던져 1의 눈이 1번 이하로 나올 확률 100번 던져 1의 눈이 10번 이하로 나올 확률 이산형 분포인 이항분포의 확률을 연속형 분포인 정규분포를 이용해서 계산하는 것이므로 함수 pnorm()에는 수정 계수 0.5를 포함하여 확률을 계산하였다. \\(n\\) 이 커짐에 따라 이항분포에서 구한 확률과 정규분포에서 구한 확률의 차이가 줄어들고 있음을 알 수 있다. # 1) pbinom(1, size = 10, prob = 1/6) ## [1] 0.4845167 pnorm(1.5, mean = 10*(1/6), sd = sqrt(10*(1/6)*(5/6))) ## [1] 0.4437685 # 2) pbinom(10, size = 100, prob = 1/6) ## [1] 0.04269568 pnorm(10.5, mean = 100*(1/6), sd = sqrt(100*(1/6)*(5/6))) ## [1] 0.04899367 이번에는 이항분포의 확률분포함수의 형태가 정규분포의 확률밀도함수의 형태로 수렴해 가는 과정을 그래프로 표현해 보자. \\(X \\sim B(n, p)\\) 에서 \\(p = 0.2, 0.5, 0.8\\) 경우에 \\(n = 10,100\\) 에 대한 확률분포함수의 그래프를 하나의 그래픽 창에 함께 나타나도록 배치해 보자. ggplot2에서 여러 개의 그래프를 하나의 그래픽창에 배치하기 위해서는 패키지 patchwork를 사용하면 된다. 그래픽 객체를 먼저 생성하고, 이어서 +와 / 기호를 사용해서 적절하게 배치할 수 있다. 자세한 사용법은 patchwork 에서 찾아볼 수 있다. n &lt;- c(10, 100) p &lt;- c(0.2, 0.5, 0.8) np &lt;- expand_grid(n, p) p_b &lt;- vector(mode = &quot;list&quot;, length = nrow(np)) for(k in 1:nrow(np)){ df &lt;- tibble(n = np$n[k], p = np$p[k], x = 0:n, y = dbinom(x, size = n, prob = p)) p_b[[k]] &lt;- ggplot(df, aes(x, y)) + geom_col(width = 0.3) + labs(y = &quot;Prob&quot;) + ggtitle(paste0(&quot;X ~ B(&quot;, df$n, &quot;,&quot;, df$p, &quot;)&quot;)) } library(patchwork) (p_b[[1]] + p_b[[2]] + p_b[[3]])/(p_b[[4]] + p_b[[5]] + p_b[[6]]) 그림 8.10: n의 크기에 따른 이항분포 밀도함수 그래프의 변화 \\(n\\) 이 커짐에 따라 이항분포의 확률분포함수의 형태가 정규분포의 확률밀도함수의 형태와 비슷해짐을 알 수 있다. 8.3.2 포아송 분포 연속형 확률분포인 지수분포는 어떤 특정 사건의 발생 간격에 대한 분포이다. 이에 반하여 포아송 분포는 정해진 기간 내에 어떤 특정 사건이 발생한 횟수에 대한 분포이다. 예를 들어 하루 동안 잘못 걸려온 전화통화 수, 1시간 동안 은행을 방문한 고객의 수, 어느 도로에서 하루 동안 발생한 교통사고 건수, 책 한 페이지당 오타 수 등등이 포아송 분포로 설명될 수 있는 예가 된다. 포아송 분포의 확률분포함수는 다음과 같다. \\[ P(X=x)=e^{- \\lambda} \\frac{\\lambda^{x}}{x!}~, ~~~x=0,1,\\ldots \\] 포아송 분포와 관련된 R 함수의 일반적인 사용법은 다음과 같다. 함수 사용법 획률분포함수 dpois(x, lambda) 누적분포함수 ppois(q, lambda, lower.tail = TRUE) 분위수함수 qpois(p, lambda, lower.tail = TRUE) 난수발생함수 rpois(n, lambda) 함수 dpois()를 사용하여 \\(\\lambda=3\\) 인 포아송 분포의 확률분포함수 그래프를 작성해 보자. tibble(x = 0:11, y = dpois(x, lambda = 3)) %&gt;% ggplot(aes(x, y)) + geom_col(width = 0.3) + scale_x_continuous(breaks = 0:11) + labs(title = expression(paste(&quot;Poisson&quot;,&quot;(&quot;,lambda==3,&quot;)&quot;)), y = NULL, x = NULL) 그림 8.11: 포아송분포의 확률분포함수 그래프 포아송 분포와 관련된 확률 문제를 R 함수를 이용하여 풀어보자. 예를 들어 어떤 책의 한 페이지당 오타의 개수가 \\(\\lambda = 1/2\\) 인 포아송 분포를 한다고 했을 때 특정 페이지에서 적어도 한 개의 오타가 나올 확률을 구해 보자. 구하는 확률은 \\(P(X \\geq 1)\\) 이 되는데, 이것은 \\(1-P(X=0)\\) 과 같기 때문에, 두 가지 방법으로 계산해 보자. 1 - dpois(0, lambda = 1/2) ## [1] 0.3934693 ppois(0, lambda = 1/2, lower.tail = FALSE) ## [1] 0.3934693 포아송 분포가 많이 사용되는 이유 중 하나는 \\(n\\) 이 크고 \\(p\\) 가 작은 경우의 이항분포와 매우 비슷한 분포형태가 된다는 것이다. 이 경우 포아송 분포의 모수는 \\(\\lambda = np\\) 가 된다. 이 현상을 R을 이용하여 살펴보도록 하자. 확률변수 X의 분포가 \\(X \\sim B(n, p)\\) 일 때 \\(P(X=2)\\) 의 값을 \\(n=10,~p=0.1\\) 인 경우와 \\(n=100,~p=0.01\\) 인 경우에 이항분포와 포아송 분포를 이용하여 각각 구해 보자. n &lt;- 10 p &lt;- 0.1 dbinom(2, size = n, prob = p) ## [1] 0.1937102 dpois(2, lambda = n*p) ## [1] 0.1839397 n &lt;- 100 p &lt;- 0.01 dbinom(2, size = n, prob = p) ## [1] 0.1848648 dpois(2, lambda = n*p) ## [1] 0.1839397 포아송 분포의 모수 \\(\\lambda\\) 값은 두 경우 모두 1이 되는데, \\(n=100\\) 인 두 번째 경우에 포아송분포에서 구한 확률이 이항분포에서 구한 확률에 훨씬 더 근접한 값이 됨을 알 수 있다. 8.3.3 초기하분포 어떤 바구니에 \\(m\\) 개의 흰 공과 \\(n\\) 개의 검은 공이 들어있다고 하자. 이 바구니에서 \\(k\\) 개의 공을 비복원추출 방식으로 임의로 추출했을 때 선택된 흰 공의 개수를 \\(X\\) 라고 하면, 확률변수 \\(X\\) 는 초기하분포를 따르게 된다. 초기하분포의 확률밀도함수는 다음과 같다. \\[ P(X=x)=\\frac{\\binom{m}{x} \\binom{n}{k-x}}{\\binom{m+n}{k}}~,~~~x=0,1,2,\\ldots,k \\] 초기하분포와 관련된 R 함수의 일반적인 사용법은 다음과 같다. 함수 사용법 획률분포함수 dhyper(x, m, n, k) 누적분포함수 phyper(q, m, n, k, lower.tail = TRUE) 분위수함수 qhyper(p, m, n, k, lower.tail = TRUE) 난수발생함수 rhyper(n, m, n, k) 초기하분포와 이항분포는 모집단을 구성하고 있는 개체가 두 가지 특성만을 지니고 있다는 점에서 공통점을 갖고 있으나, 표본추출방식에서 초기하분포는 비복원추출에, 이항분포는 복원추출에 각각 해당된다는 점에서 차이가 있다. 그러나 \\(m\\) 과 \\(n\\) 의 값이 \\(k\\) 에 비하여 큰 값인 경우에는 복원과 비복원의 차이가 무시될 수 있는 수준이 되어 두 분포 사이에는 큰 차이가 없게 된다. 이 사실을 R을 이용하여 확인해 보자. 모집단의 구성이 \\(m=5\\), \\(n=10\\) 의 경우와 \\(n=1000\\), \\(m=2000\\) 의 경우에 \\(k=5\\) 의 크기로 표본을 추출했을 때 \\(P(X=1)\\) 의 값을 초기하분포와 이항분포에 각각 구해 보자. 이항분포에서는 두 경우 모두 \\(p=m/(m+n)=1/3\\) 이 된다. m &lt;- 5 n &lt;- 10 k &lt;- 5 p &lt;- m/(n+m) dbinom(1, size = k, prob = p) ## [1] 0.3292181 dhyper(1, m = m, n = n, k = k) ## [1] 0.3496503 \\(n=1000\\), \\(m=2000\\) 의 경우 두 분포에서 각각 구한 확률이 거의 동일함을 알 수 있다. m &lt;- 1000 n &lt;- 2000 k &lt;- 5 p &lt;- m/(n+m) dbinom(1, size = k, prob = p) ## [1] 0.3292181 dhyper(1,m = m, n = n, k = k) ## [1] 0.3293278 초기하분포는 여러 분야에서 응용되는 분포로서 모집단의 개체 수를 추정할 때도 사용할 수 있는 분포이다. 예를 들어 어떤 호수에 살고 있는 물고기의 개체 수를 추정한다고하자. 이러한 경우 다음의 절차에 따라 물고기의 개체 수를 추정할 수 있다. 호수에서 \\(m\\) 마리의 물고기를 잡아 꼬리표를 부착시키고 풀어준다. 그러면 호수에는꼬리표가 부착된 \\(m\\) 마리의 물고기와 꼬리표가 없는 \\(n\\) 마리의 물고기가 있게 되어 물고기의 개체 수는 모두 \\((m+n)\\) 마리가 된다. 다시 \\(k\\) 마리의 물고기를 잡아서 그 중 꼬리표가 있는 물고기의 마리 수를 \\(x\\) 라고 둔다. 이때 가정해야 하는 사항은 호수 전체에 꼬리표가 부착된 물고기의 비율인 \\(m/(m+n)\\)이 잡힌 \\(k\\) 마리의 물고기에서도 그대로 유지된다는 것이다. 위 실험에서 두 번째 잡힌 \\(k\\) 마리의 물고기 중 꼬리표가 있는 물고기의 마리 수를 확률변수 \\(X\\) 라고 두면 \\(X\\) 는 초기하분포를 따르게 되는데, 위 실험결과 확률변수 \\(X\\) 의 값은 \\(x\\) 가 됐다. 이제 \\(P(X=x)\\) 의 값을 계산해 보면, \\(n\\) 이 미지수로 남아있기 때문에 확률 값은 \\(n\\) 의 함수가 됨을 알 수 있으며, \\(P(X=x)\\) 를 최대화시키는 \\(n\\) 의 값을 꼬리표가 없는 물고기 개체 수로 추정하는 것이 현실적인 방안이라고 할 수 있다 이제 \\(m=50\\), \\(k=40\\), \\(x=3\\) 의 경우에 \\(n\\) 의 값을 추정하여 물고기의 총 개체 수를 추정해 보자. 추정절차는 여러 개의 \\(n\\) 값을 입력하여 확률을 계산하고 그 중 확률이 최대가 되는 \\(n\\) 값을 선택하는 방식으로 이루어졌다. 확률이 최대가 되는 \\(n\\) 값을 찾는 데 사용된 함수 \\(which.max()\\)는 주어진 숫자형 벡터 최댓값의 인덱스, 즉 최댓값의 위치를 찾는 기능을 갖고 있다. m &lt;- 50 k &lt;- 40 x &lt;- 5 n &lt;- 200:700 p.n &lt;- vector(&quot;double&quot;, length = length(n)) for(i in seq_along(n)){ p.n[i] &lt;- dhyper(x, m = m, n = n[i], k = k) } max.n &lt;- n[which.max(p.n)] tibble(n, p.n) %&gt;% ggplot(aes(x = n, y = p.n)) + geom_line(color = &quot;red&quot;, size = 1.2) + geom_vline(xintercept = max.n, linetype = 2) + labs(title = paste0(&quot;Total number of fish is estimated by &quot;, m + max.n, &quot;\\n(&quot;, m, &quot; tagged and &quot;, max.n, &quot; untagged)&quot;), x = &quot;untagged fish&quot;, y = &quot;probability&quot;) 그림 8.12: 물고기 개체 수 추정 결과 여러 개의 \\(n\\) 값에 대해 계산된 확률값은 geom_line()으로 그렸으며, 최댓값의 위치를 나타내는 수직선은 geom_vline()으로 작성했다. 또한 개체 수 추정 결과가 그래프의 제목에 바로 나타나도록 추정 결과가 할당된 객체를 함수 labs()의 변수 title에 연결하였다. 8.4 모의실험 R에는 매우 효과적인 난수발생함수가 있어서, 다양한 분포에서 손쉽게 난수를 발생시킬 수 있다. 특정 분포에서 난수를 발생시킬 수 있다는 것은 곧 그 특정 분포를 모집단분포로 가정하는 상황에서 표본을 반복해서 추출할 수 있다는 것을 의미하는 것이며, 따라서 어떤 특정 통계적 실험을 반복해서 실행할 수 있다는 것을 의미한다. 이 절에서는 R에 장착된 다양한 분포의 난수발생함수를 이용하여 몇 가지 모의실험 예제를 다뤄보고자 한다. R에서 다루고 있지 않은 분포에서의 난수발생 기법 등을 포함한 모의실험 전체에 대한 체계적인 소개는 Jones and Robinson (2009) 를 참조하기 바란다. \\(\\bullet\\) 모의실험 예제 1 : 상대도수 개념에 의한 확률 특정 사건 A가 발생할 확률을 상대도수의 개념으로 다음과 같이 정의할 수 있다. \\[ P(A)=\\lim_{n \\rightarrow \\infty} \\frac{n(A)}{n} \\] 단, \\(n\\) 은 실험의 시행횟수, \\(n(A)\\) 는 \\(n\\) 번의 실험에서 사건 \\(A\\) 가 발생한 횟수를 각각 의미한다. 이제 상대도수의 개념을 이용하여 주사위를 던져 1의 눈이 나올 확률이 1/6임을 나타내보자. 구체적인 방법은 주사위를 던지는 모의실험을 20,000번 실시하여, 시행마다 1이 눈이 나온 상대도수를 계산하고, 그 변화를 그래프로 나타내는 것이다. 많은 경우 모의실험은 for 루프를 사용하게 되는데, 나름의 장점을 가지고 있는 방법이다. 그러나 경우에 따라서는 for 루프를 사용하지 않고 모의실험을 실시하는 것이 더 효율적일 수 있으므로, 두 방법을 각각 사용하여 모의실험을 실시해 보자. 우선 for 루프를 사용하여 상대도수를 계산해 보자. 주사위를 한 번 던지는 실험은 sample(1:6, 1)로 실시할 수 있고, 그 값이 1과 같게 되면 num의 값을 하나씩 증가시키며, 실행마다 상대도수를 계산하여 객체 prob에 할당하는 방법이다. set.seed(12) rep &lt;- 20000 num &lt;- 0 prob &lt;- vector(&quot;double&quot;, rep) for(i in seq_along(prob)){ x &lt;- sample(1:6, 1) if(x == 1) num &lt;- num + 1 prob[i] &lt;- num/i } For 루프를 사용하지 않는다면 20,000개의 난수를 한 번에 모두 발생시켜 벡터에 할당하고, 이어서 함수 cumsum()을 사용하여 상대도수를 계산하면 된다. 이 경우에는 더 효율적인 방식으로 보인다. set.seed(12) rep &lt;- 20000 x &lt;- sample(1:6, rep, replace = TRUE) prob &lt;- cumsum(x == 1)/(1:rep) 이어서 계산된 상대도수를 그래프로 나타내 보자. 객체 prob에 저장된 상대도수 값은 함수 geom_line()으로 나타냈고, 확률 1/6을 표시 하는 수평선은 함수 geom_hline()으로 추가하였다. 1의 눈이 나온 상대도수가 1/6로 수렴하는 것을 확인할 수 있다. tibble(x = 1:rep, y = prob) %&gt;% ggplot(aes(x, y)) + geom_line() + geom_hline(yintercept = 1/6, color = &quot;red&quot;) + labs(title = &quot;Relative frequency and Probability&quot;, x = &quot;Number of Trials&quot;, y = &quot;Relative frequency&quot;) 그림 8.13: 상대도수와 확률 \\(\\bullet\\) 모의실험 예제 2 : 표본분포 \\(X_{1}, \\ldots, X_{n}\\) 을 \\(N(\\mu, \\sigma^{2})\\) 에서의 확률포본이라고 하자. 그러면 확률변수 \\(T=\\frac{\\bar{X}-\\mu}{S/\\sqrt{n}}\\) 의 분포는 \\(t(n-1)\\) 을 따르게 된다는 정리를 모의실험을 통하여 확인해 보자. 구체적인 모의실험 절차는 다음과 같다. \\(X_{1}, \\ldots, X_{n}\\) 을 \\(N(\\mu, \\sigma^{2})\\) 에서 추출한다. 추출된 표본에서 \\(T=\\frac{\\bar{X}-\\mu}{S/\\sqrt{n}}\\) 의 값을 계산한다. 위 두 단계를 \\(N\\) 번 반복하여 구한 \\(T\\) 값의 분포를 \\(t(n-1)\\) 과 비교한다. 표준정규분포를 대상으로 표본크기를 \\(n=5\\) 로 하고 반복 횟수를 \\(N=10000\\) 번으로 하여 \\(T\\) 통계량 값을 계산하고, 그 결과를 히스토그램으로 작성한 후 \\(t(4)\\) 의 확률밀도함수 그래프를 겹쳐서 그려보자. 먼저 for 루프를 사용하여 모의실험을 실시해 보자. set.seed(124) n &lt;- 5 N &lt;- 10000 Tsample &lt;- vector(&quot;double&quot;, length = N) for (i in seq_along(Tsample)) { Xsample &lt;- rnorm(n) Tsample[i] &lt;- mean(Xsample)/(sd(Xsample)/sqrt(n)) } For 루프를 사용하지 않는다면 정규분포에서 필요한 난수를 한 번에 모두 발생시키고, 그 결과를 행렬에 할당해야 한다. 이어서 난수 행렬을 대상으로 필요한 통계량을 함수 apply()로 계산하면 된다. set.seed(124) n &lt;- 5 N &lt;- 10000 xsample &lt;- rnorm(n*N) dim(xsample) &lt;- c(n,N) m.x &lt;- apply(xsample, 2, mean) sd.x &lt;- apply(xsample, 2, sd) Tsample &lt;- m.x/(sd.x/sqrt(n)) 이어서 객체 Tsample의 값에 대한 히스토그램으로 작성하고, \\(t(4)\\) 의 확률밀도함수를 겹쳐서 나타내 보자. tibble(x = Tsample) %&gt;% ggplot() + geom_histogram(aes(x = x, y = after_stat(density)), bins = 100) + stat_function(fun = dt, args = list(df = n - 1), color = &quot;red&quot;) + labs(x = NULL, y = NULL, title = &quot;Sampling Distribution of sample mean&quot;) 그림 8.14: 표본평균의 표본분포 그래프 \\(\\bullet\\) 모의실험 예제 3 : 신뢰구간에서 신뢰계수의 의미 \\(N(\\mu, \\sigma^{2})\\) 의 분포에서 모평균 \\(\\mu\\) 에 대한 95% 신뢰구간은 다음과 같다. \\[ P(\\bar{X}-1.96 \\frac{S}{\\sqrt{n}}\\leq\\mu\\leq \\bar{X}+1.96\\frac{S}{\\sqrt{n}})=0.95 \\] 여기에서 신뢰계수 0.95의 의미는 \\(n\\) 개의 확률표본을 추출하여 신뢰구간을 구하는 작업을 \\(N\\) 번 반복하여 얻은 \\(N\\) 개의 신뢰구간 중 95%에는 미지의 모수 \\(\\mu\\) 가 포함되어 있지만, 나머지 5%의 신뢰구간에는 모수 \\(\\mu\\) 가 포함되어 있지 않다는 것이다. 이것을 \\(n=20\\) 과 \\(N=100\\) 의 경우에 대한 모의실험을 통해 나타내 보자. 먼저 100개의 신뢰구간을 계산하고, 각 신뢰구간에 모평균 포함 여부를 확인해야 한다. 먼저 for 루프에 의한 방법이다. set.seed(123) n &lt;- 20; N &lt;- 100 mu &lt;- 10; sigma &lt;- 1 alpha &lt;- 0.05 upper &lt;- lower &lt;- vector(&quot;double&quot;, length = N) ok &lt;- vector(&quot;logical&quot;, length = N) for(i in seq_along(upper)) { x &lt;- rnorm(n, mean = mu, sd = sigma) upper[i] &lt;- mean(x) + qnorm(1 - alpha/2)*sd(x)/sqrt(n) lower[i] &lt;- mean(x) - qnorm(1 - alpha/2)*sd(x)/sqrt(n) ok[i] &lt;- mu &lt;= upper[i] &amp; mu &gt;= lower[i] } for 루프를 사용하지 않는 방법이다. set.seed(123) n &lt;- 20; N &lt;- 100 mu &lt;- 10; sigma &lt;- 1 alpha &lt;- 0.05 x &lt;- rnorm(n = n*N, mean = mu, sd = sigma) dim(x) &lt;- c(n, N) x_bar &lt;- apply(x, 2, mean) x_sd &lt;- apply(x, 2, sd) lower &lt;- x_bar - qnorm(1 - alpha/2)*x_sd/sqrt(n) upper &lt;-x_bar + qnorm(1 - alpha/2)*x_sd/sqrt(n) ok &lt;- mu &gt;= lower &amp; mu &lt;= upper 계산된 신뢰구간을 선분으로 표시하기 위해서는 함수 geom_segment()를 사용해야 한다. 이 함수의 필수 매핑 대상으로는 선분의 시작점을 나타내는 시각적 요소 x, y와 끝점을 나타내는 xend, yend가 있다. 신뢰구간 선분을 수직으로 표시할 것이라면, Y축에는 신뢰구간의 상한과 하한을 표시하고 X축은 신뢰구간의 일련번호를 표시해야 할 것이다. 따라서 y에는 객체 lower를 연결하고, yend에는 객체 upper를 연결하며, x와 xend 모두에는 1:N을 동일하게 연결한다. 또한 모평균의 포함 여부를 색으로 표시하기 위해 객체 ok를 color에 매핑하는 것도 필요하다. tibble(lower, upper, ok) %&gt;% ggplot() + geom_segment(aes(y = lower, yend = upper, x = 1:N, xend = 1:N, color = ok), size = 1) + labs(title = paste(&quot;모평균이 포함된 신뢰구간 비율:&quot;, mean(ok)), color = &quot;모평균 포함&quot;, x = NULL, y = NULL) + theme(plot.title = element_text(face = &quot;bold&quot;, size = 20)) 그림 8.15: 신뢰계수의 의미 "],["chapter-EDA.html", "9 장 자료 탐색 9.1 일변량 범주형 자료 탐색 9.2 이변량 및 다변량 범주형 자료 탐색 9.3 일변량 연속형 자료 탐색 9.4 이변량 연속형 자료 탐색 9.5 연습문제", " 9 장 자료 탐색 수많은 변수들로 이루어져 있는 통계 자료가 주어지면 개별 변수들이 갖고 있는 정보를 탐색하는 것이 통계분석의 첫 단계가 된다. 개별 변수들의 정보를 따로따로 탐색하는 것은 결국 하나의 변수로 이루어진 일변량 자료를 탐색하는 것이라 할 수 있으며, 일변량 자료가 갖고 있는 정보 중 우리가 가장 관심을 두는 사항은 자료의 분포 형태가 될 것이다. 자료의 분포 형태를 그래프로 잘 표현하려면, 자료의 속성에 가장 적합한 그래프를 선택해야 한다. 한 변수를 대상으로 하는 일변량 자료의 탐색 과정이 끝나면, 두 변수를 동시에 고려하는 이변량 자료의 탐색을 시작해야 한다. 일변량 자료에 대해서는 자료의 분포에 대한 정보만이 필요했지만, 이변량 자료에 대해서는 각 자료의 분포에 대한 정보뿐 아니라, 두 변수의 분포를 비교하는 것과 두 변수 간의 관계가 중요한 정보가 된다. 이 장에서는 범주형 자료와 연속형 자료로 구분하여 각각의 경우에 자료 탐색에 사용할 수 있는 그래프의 작성방법을 살펴볼 것이다. 9.1 일변량 범주형 자료 탐색 여러 범주들로만 이루어진 범주형 자료는 명목형 자료와 순서형 자료로 구분된다. 명목형 자료란 범주들 간에 순서척도가 없는 경우로, 거주지, 성별, 종교 등이 여기에 해당되고, 순서형 자료란 강의 만족도와 같이 범주들을 순서에 따라 나열할 수 있는 경우를 지칭한다. 이 절에서는 막대그래프(bar chart), 파이그래프(pie chart)와 Cleveland의 점그래프(dot chart)를 사용하여 일변량 범주형 자료의 탐색 과정을 살펴볼 것인데, 이 그래프들은 명목형과 순서형 구분 없이 모두에게 잘 적용되는 그래프들이다. 9.1.1 막대그래프 범주형 자료에 대한 그래프로 가장 흔하게 볼 수 있는 그래프로서, 각 범주의 도수를 막대의 높이로 나타내는 그래프이다. 예제로 요인 state.region의 막대그래프를 작성해 보자. 요인 state.region는 미국 50개 주를 4개의 지역 범주로 구분한 명목형 자료이다. state.region[1:10] ## [1] South West West South West West Northeast ## [8] South South South ## Levels: Northeast South North Central West 함수 geom_bar()를 사용해서 막대그래프를 작성해 보자. library(tidyverse) tibble(state.region) %&gt;% ggplot() + geom_bar(aes(x = state.region)) + xlab(&quot;Region&quot;) 그림 9.1: 요인 state.region의 막대그래프 옆으로 누운 형태의 막대그래프도 작성해 보자. tibble(state.region) %&gt;% ggplot() + geom_bar(aes(y = state.region)) + ylab(&quot;Region&quot;) 그림 9.2: 요인 state.region의 옆으로 누운 형태의 막대그래프 도수분포표가 자료로 주어진 경우에 막대그래프의 작성 방법을 살펴보자. 요인이 아닌 도수분포표를 자료로 사용하는 경우에는 함수 geom_bar()에 stat=“identity”를 추가하거나 geom_col()을 사용해야 한다. 요인 state.region을 데이터 프레임으로 전환하고, 함수 count()로 계산한 각 범주에 대한 도수가 변수로 포함된 데이터 프레임 df_1을 생성하자. df_1 &lt;- tibble(state.region) %&gt;% count(state.region) df_1 ## # A tibble: 4 × 2 ## state.region n ## &lt;fct&gt; &lt;int&gt; ## 1 Northeast 9 ## 2 South 16 ## 3 North Central 12 ## 4 West 13 함수 geom_col()에서 데이터 프레임 df_1의 변수 중 범주를 나타내는 state.region과 각 범주의 도수를 나타내는 n을 시각적 요소 x, y에 매핑하면 막대그래프를 작성할 수 있다. library(patchwork) bar1 &lt;- ggplot(df_1, aes(x = state.region, y = n)) + geom_col(fill = &quot;steelblue&quot;) + labs(x = NULL, y = NULL) bar2 &lt;- bar1 + coord_flip() bar1 + bar2 그림 9.3: 도수분포표가 자료로 주어진 경우의 막대그래프 작성 많은 경우에 막대그래프는 각 범주의 빈도를 이용하여 작성되지만, 경우에 따라서는 각 범주의 상대도수를 이용하여 작성해야 할 때도 있다. 이런 경우에는 함수 geom_bar()에서 생성된 변수 after_stat(prop)를 매핑하면서, 시각적 요소 group에 하나의 값을 지정해 주면 된다. tibble(state.region) %&gt;% ggplot() + geom_bar(aes(x = state.region, y = after_stat(prop), group = 1), fill = &quot;skyblue&quot;) + labs(x = &quot;Region&quot;, y = &quot;Proportion&quot;) 그림 9.4: 상대도수에 의한 막대그래프 9.1.2 파이그래프 범주형 자료에 대한 그래프로 실생활에서 많이 사용되는 그래프 중 하나가 바로 파이그래프일 것이다. 파이그래프는 각 범주의 상대도수에 비례한 면적으로 원을 나누어 나타내는 그래프이다. 그러나 면적의 차이를 시각적으로 구분하는 것은 길이의 차이를 구분하는 것보다 훨씬 어렵기 때문에 대부분의 통계학자들은 파이그래프의 가치를 막대그래프보다 낮게 평가하고 있다. 파이조각의 면적을 비교하는 데 도움을 줄 수 있는 방안으로 각 파이 조각에 면적의 백분율을 라벨로 추가해 주는 것을 생각해 볼 수 있다. 파이그래프를 작성하기 위해서는 함수 geom_bar()에 시각적 요소 fill을 사용하여 쌓아올린 막대그래프를 작성하고, 함수 coord_polar()에서 theta에 “y”를 연결하여 상대도수에 비례한 각도를 계산해야 한다. tibble(state.region) %&gt;% ggplot() + geom_bar(aes(x = &quot;&quot;, fill = state.region), width = 1) + labs(x = NULL, y = NULL) + coord_polar(theta = &quot;y&quot;) 그림 9.5: 요인 state.region의 파이그래프 각 파이 조각의 비교를 돕기 위한 하나의 방안으로 백분율을 각 조각의 라벨로 추가해 보자. 이 경우에 라벨로 사용할 각 조각의 백분율을 데이터 프레임에 변수로 포함시키는 것이 필요하다. 숫자를 ‘%’ 기호가 포함된 백분율로 변환할 때 편하게 사용할 수 있는 함수가 패키지 scales에 있는 percent()이다. 요인 state.region을 데이터 프레임으로 전환하고, 각 범주에 대한 도수 및 백분율을 추가해서 df_2를 만들어 보자. library(scales) df_2 &lt;- tibble(state.region) %&gt;% count(state.region) %&gt;% mutate(pct = percent(n/sum(n))) %&gt;% print() ## # A tibble: 4 × 3 ## state.region n pct ## &lt;fct&gt; &lt;int&gt; &lt;chr&gt; ## 1 Northeast 9 18% ## 2 South 16 32% ## 3 North Central 12 24% ## 4 West 13 26% 이제 파이그래프를 작성하기 바로 전 단계인 쌓아 올린 막대그래프를 작성해 보자. 그림 9.6에서 볼 수 있듯이 쌓아 올려지는 조각의 순서는 데이터 프레임 df_2의 첫 번째 행 이 제일 위에 위치하고 두 번째 행이 그 밑으로 배치되는 위에서 아래 방향이 된다. 그래프에 라벨 추가는 함수 geom_text()로 할 수 있다. 데이터 프레임 df_2의 변수 pct를 시각적 요소 label에 매핑하고, 라벨의 위치를 position에 지정하면 되는데, 쌓아 올려진 각 조각의 중간 부분이 적절할 것으로 보여서 함수 position_stack()에서 변수 vjust에 0.5를 지정했다. df_2 %&gt;% ggplot(aes(x = &quot;&quot;, y = n, fill = state.region)) + geom_col(width = 1) + geom_text(aes(label = pct), size = 5, position = position_stack(vjust = 0.5)) + labs(x = NULL, y = NULL, fill = NULL) 그림 9.6: 쌓아올린 막대그래프에 백분율 라벨 추가하기 쌓아올린 막대그래프에 함수 coord_polar()를 적용시켜 파이그래프를 작성해 보자. df_2 %&gt;% ggplot(aes(x = &quot;&quot;, y = n, fill = state.region)) + geom_col(width = 1) + geom_text(aes(label = pct), size = 5, position = position_stack(vjust = 0.5)) + labs(x = NULL, y = NULL, fill = NULL) + coord_polar(theta = &quot;y&quot;) + theme_void() 그림 9.7: 각 조각에 벡분율을 라벨로 추가한 파이그래프 신문이나 잡지 등에 작성된 파이그래프 중에는 3차원 효과를 준 파이그래프도 종종 발견된다. 3D 파이그래프는 패키지 plotrix의 함수 pie3D()로 작성할 수 있다. 3차원 파이그래프도 파이그래프가 갖고 있는 근본적인 문제에서 자유로울 수는 없으며, 따라서 비록 시각적으로는 화려한 그래프이지만 정보의 효과적인 전달이라는 측면에서는 문제가 많은 그래프라고 할 수 있다. library(plotrix) pie_val &lt;- df_2$n pie_lab &lt;- with(df_2, paste(state.region, pct)) pie3D(pie_val, explode = 0.1, labels = pie_lab) 그림 9.8: 패키지 plotrix의 3차원 파이그래프 파이그래프의 가장 큰 문제는 파이조각들의 면적을 서로 비교하는 것이 매우 힘들다는 점이다. 이러한 문제를 해결하는 방안으로 제시된 그래프가 fan plot이다. R에서는 패키지 plotrix에 함수 fan.plot()으로 작성할 수 있다. Fan plot에서는 조각들이 크기순으로 서로 겹치도록 재배치되는데, 조각의 반지름을 조절하여 모든 조각을 볼 수 있도록 하였다. 그림 9.9에서 우리는 조각의 크기가 South &gt; West &gt; North Central &gt; Northeast의 순서로 되어 있음을 쉽게 알 수 있다. 많이 사용되고 있지는 않지만 파이그래프보다는 훨씬 효과적인 그래프라고 할 수 있다. fan.plot(pie_val, labels = pie_lab) 그림 9.9: 패키지 plotrix의 Fan plot 9.1.3 Cleveland의 점그래프 점 그래프는 통계 그래픽스 분야에 큰 기여를 한 Cleveland가 개발한 그래프이다. 비록 막대그래프나 파이그래프처럼 화려하게 치장할 수는 없으나 범주형 데이터의 속성을 정확 하게 표시할 수 있는 이상적인 그래프로 인정받고 있다. 예제 데이터로는 앞 절에서 살펴본 state.region을 다시 사용해 보자. 점그래프 작성은 도수분포표 자료인 df_1을 함수 geom_point()에 적용시키면 된다. 함수 theme()은 그래프의 디폴트 형태를 변경하고자 할 때 사용되는 것으로, 이 경우에는 그래프에 수평선을 추가하기 위해 사용되었다. df_1 %&gt;% ggplot(aes(x = n, y = state.region)) + geom_point(size = 2) + theme(panel.grid.major.y = element_line(linetype = 3, colour = &quot;gray40&quot;)) + labs(x = NULL, y = NULL) 그림 9.10: 요인 state.region의 점그래프 9.2 이변량 및 다변량 범주형 자료 탐색 범주형 자료가 주어지면 가장 먼저 해야 할 작업은 도수분포표 혹은 분할표를 작성하는 것이다. 이 절에서는 일변량 범주형 자료에 대한 도수분포표의 작성과 이변량 범주형 자료의 분할표의 작성에 사용할 수 있는 R 함수를 살펴볼 것이다. 또한 2차원 분할표로 정리된 자료를 효과적으로 시각화할 수 있는 그래프 작성법도 살펴볼 것이다. 9.2.1 분할표 작성 R에는 도수분포표 및 분할표를 작성하는 데 사용되는 몇 가지 함수가 있다. 그중 많이 사용되는 함수들이 다음의 표에 정리되어 있다. 도수분포표 및 분할표 작성에 관련된 함수 함수 대략의 기능 table(var1, var2, … , varN) N개의 범주형 변수로 N차원 분할표 작성 xtab(formula, data) data의 범주형 변수를 formula 에 정의된 방식으로 분할표 작성 prop.table(table, margins) 작성된 분할표의 결합분포 또는 margins 로 정의된 방향으로 조건분포 작성 margin.table(table, margins) 작성된 분할표의 한계분포를 margins 로 정의된 방향으로 작성 addmargins(table, margins) 작성된 분할표에 margins로 정의된 방향의 한계분포를 추가 위 함수들의 사용법을 예제를 이용하여 살펴보자. 예제로 사용할 자료는 패키지 vcd에 있는 데이터 프레임 Arthritis이다. 이 자료는 류머티즘 관절염 환자들을 대상으로 새로운 치료법의 효과를 알아보기 위해 이루어진 임상실험 자료이다. data(Arthritis, package = &quot;vcd&quot;) head(Arthritis) ## ID Treatment Sex Age Improved ## 1 57 Treated Male 27 Some ## 2 46 Treated Male 29 None ## 3 77 Treated Male 30 None ## 4 17 Treated Male 32 Marked ## 5 36 Treated Male 46 Marked ## 6 23 Treated Male 58 Marked 변수 Treatment는 “Placebo”와 “Treated”를, Sex는 “Male”과 “Female”을, Improved는 “None”, “Some”, “Marked”을 범주로 갖고 있는 범주형 자료다. \\(\\bullet\\) 1차원 도수분포표 작성 1차원 도수분포표는 일변량 범주형 자료의 도수분포표를 의미한다. 함수 table()과 xtabs()로 변수 Improved의 1차원 도수분포표를 작성해 보자. with(Arthritis, table(Improved)) ## Improved ## None Some Marked ## 42 14 28 xtabs(~ Improved, data = Arthritis) ## Improved ## None Some Marked ## 42 14 28 우선 두 함수의 실행결과가 동일함을 알 수 있다. 사용법에서는 약간의 차이가 있는데, 함수 table() 안에는 벡터를 입력해야 하기 때문에, 함수 with()와 함께 사용하였다. 함수 xtabs() 안에는 R 공식으로 도수분포표 혹은 분할표의 형태를 정의하는데, 1차원 도수분포표의 경우는 ~ 표시 오른쪽에 해당 변수를 하나 입력하면 된다. 공식을 사용하여 모형을 정의하는 함수 안에는 데이터 프레임을 지정하여 사용할 수 있는 것이 일반적이다. \\(\\bullet\\) 1차원 상대도수분포표 작성 상대도수분포표는 함수 table() 또는 xtabs()로 작성된 table 객체를 함수 prop.table()에 입력하면 된다. my_table1 &lt;- with(Arthritis, table(Improved)) prop.table(my_table1) ## Improved ## None Some Marked ## 0.5000000 0.1666667 0.3333333 위의 결과에서 우리는 소수점 자릿수가 너무 길다는 문제를 발견할 수 있다. 소수점 자릿수의 조정은 함수 options()으로 할 수 있는데, 이 함수는 R의 전체적인 환경에 관련된 여러 옵션을 조정하는 가능을 갖고 있다. 이 중 출력되는 소수점 자릿수의 현재 값을 알아보는 방법과 수정하는 방법은 다음과 같다. options(&quot;digits&quot;) ## $digits ## [1] 7 options(&quot;digits&quot; = 2) 원래의 값은 소수점 이하 7자리까지 출력하는 것인데, 이것을 2자리로 수정하고 다시 변수 Improved의 상대도수분포표를 출력해 보자. prop.table(my_table1) ## Improved ## None Some Marked ## 0.50 0.17 0.33 \\(\\bullet\\) 2차원 분할표 작성 1차원 도수분포표의 경우와 같이 2차원 분할표도 함수 table() 혹은 xtabs()로 작성할 수 있다. 변수 Improved와 Treatment의 2차원 분할표를 작성해 보자. with(Arthritis, table(Treatment, Improved)) ## Improved ## Treatment None Some Marked ## Placebo 29 7 7 ## Treated 13 7 21 xtabs(~ Treatment + Improved, data = Arthritis) ## Improved ## Treatment None Some Marked ## Placebo 29 7 7 ## Treated 13 7 21 함수 table()에서는 두 개의 변수가 콤마로 연결되고, 함수 xtabs()에서는 두 변수가 + 기호로 연결되는데, 두 경우 모두 첫 번째 변수가 분할표의 행 변수가 되고, 두 번째 변수가 열 변수가 된다. \\(\\bullet\\) 2차원 상대도수 분할표(결합분포) 작성 작성된 분할표를 함수 prop.table()에 입력하면 된다. my_table2 &lt;- with(Arthritis, table(Treatment, Improved)) prop.table(my_table2) ## Improved ## Treatment None Some Marked ## Placebo 0.345 0.083 0.083 ## Treated 0.155 0.083 0.250 위에서 options(\"digits\" = 2)가 선언된 상태이지만 소수점 3자리까지 출력된 것을 볼 수 있다. 이것은 “digits”에 대한 함수 options()의 선언이 일종의 기댓값이기 때문이다. \\(\\bullet\\) 2차원 분할표의 한계분포(marginal distribution) 작성 2차원 분할표에서 한계분포를 작성하는 방법은 행 또는 열에 대한 합계를 구하는 것으로써, 함수 margin.table()로 작성할 수 있다. 사용법은 margin.table(x, margin = NULL)이다. x는 함수 table() 등으로 작성된 분할표나 행렬이 되고, margin은 1은 행, 2는 열을 지정하는 것인데, 실질적으로 이 함수는 apply(x,1, sum) 또는 apply(x,2, sum)과 동일한 작업을 수행한다. margin에 아무것도 지정하지 않으면 sum(x)를 출력한다. 변수 Improved와 Treatment의 2차원 분할표인 my_table2를 대상으로 한계분포표를 작성해 보자. margin.table(my_table2, 1)은 행 방향으로 합계를 구하는 것이므로 행 변수 Treatment의 도수분포표, 즉 한계분포표가 작성된다. margin.table(my_table2, 2)는 열 방향의 합계를 구하는 것으로 열 변수 Improved의 한계분포표가 작성된다. margin.table(my_table2)는 margin에 아무것도 지정하지 않은 것으로 이 경우에는 관찰값의 총 개수가 계산된다. my_table2 ## Improved ## Treatment None Some Marked ## Placebo 29 7 7 ## Treated 13 7 21 margin.table(my_table2, 1) ## Treatment ## Placebo Treated ## 43 41 margin.table(my_table2, 2) ## Improved ## None Some Marked ## 42 14 28 margin.table(my_table2) ## [1] 84 한계분포표를 상대도수로 표현하려면 함수 margin.table()의 결과를 prop.table()에 입력하면 된다. prop.table(margin.table(my_table2, 1)) ## Treatment ## Placebo Treated ## 0.51 0.49 위 연산 방식은 함수 안에 다른 함수를 입력하는 방식인데, 이것보다 더 효율적인 방식은 pipe 연산자를 이용하는 것이다. Pipe 연산자는 tidyverse 생태계에서 사용되는 magrittr의 %&gt;%가 있지만, base R에도 |&gt;가 있다. 두 pipe 연산자의 기본적인 사용법은 lhs %&gt;% rhs와 lhs |&gt; rhs으로 동일하다. 차이점은 lhs가 rhs의 첫 번째 변수가 아닌 경우에 대한 위치 지정 기호이다. 예를 들어, f(y, x)를 표현할 때 %&gt;% 연산자의 경우에는 .을 사용해서 x %&gt;% f(y, .)라고 하지만, |&gt;의 경우에는 _를 사용해서 x |&gt; f(y, _)라고 한다. my_table2 |&gt; margin.table(1) |&gt; prop.table() ## Treatment ## Placebo Treated ## 0.51 0.49 2차원 분할표에 한계분포표를 추가하려면 함수 addmargins()를 사용하면 된다. my_table2 |&gt; addmargins() ## Improved ## Treatment None Some Marked Sum ## Placebo 29 7 7 43 ## Treated 13 7 21 41 ## Sum 42 14 28 84 my_table2 |&gt; prop.table() |&gt; addmargins() ## Improved ## Treatment None Some Marked Sum ## Placebo 0.345 0.083 0.083 0.512 ## Treated 0.155 0.083 0.250 0.488 ## Sum 0.500 0.167 0.333 1.000 행 또는 열 변수 중 한 변수의 한계분포만을 추가하려면 함수 addmargins()에 margin에 관련된 숫자를 지정하면 된다. 함수 addmargins()에 margin = 1이 입력되면 행에 한계분포가 추가되고, margin = 2가 입력되면 열에 한계분포가 추가된다. my_table2 |&gt; prop.table() |&gt; addmargins(1) ## Improved ## Treatment None Some Marked ## Placebo 0.345 0.083 0.083 ## Treated 0.155 0.083 0.250 ## Sum 0.500 0.167 0.333 my_table2 |&gt; prop.table() |&gt; addmargins(2) ## Improved ## Treatment None Some Marked Sum ## Placebo 0.345 0.083 0.083 0.512 ## Treated 0.155 0.083 0.250 0.488 \\(\\bullet\\) 조건분포 작성 조건분포는 함수 prop.table()에 margin을 지정함으로써 작성할 수 있다. 두 범주형 변수의 관계가 반응변수와 설명변수로 설정되어 있는 경우에는 결합분포인 2차원 상대도수 분할표보다 두 변수 사이의 관계를 규명하는 데 더 도움이 된다. 조건 변수를 행 변수로 할 것인지 혹은 열 변수로 할 것인지는 함수 prop.table()의 옵션 margin에 1 또는 2 중 하나를 선택하면 된다. my_table2 |&gt; prop.table(1) ## Improved ## Treatment None Some Marked ## Placebo 0.67 0.16 0.16 ## Treated 0.32 0.17 0.51 my_table2 |&gt; prop.table(2) ## Improved ## Treatment None Some Marked ## Placebo 0.69 0.50 0.25 ## Treated 0.31 0.50 0.75 옵션 margin에 1을 입력한 첫 번째 경우는 행 변수 Treatment가 조건변수가 되어, 위약 처리한 Placebo에서는 16%의 환자에게서 큰 진전이 있었지만 새로운 처리방법으로 처리된 Treated에서는 51%의 환자에게서 큰 진전이 있었다는 것을 알 수 있다. 옵션 margin에 2를 입력한 두 번째 경우는 열 변수 Improved가 조건변수가 된 경우로 병세가 많이 호전된 Marked 그룹 중에 75%의 환자들이 Treated 그룹에 속한다는 것도 알 수 있다. \\(\\bullet\\) 분할표에서 결측값 처리 함수 table()은 자료에 포함된 NA 값을 무시하고 분할표를 작성하는 것이 디폴트이다. 만일 NA의 빈도수를 분할표에 나타내려면 옵션 useNA = “ifany”를 추가하면 된다. 예를 들어 데이터 프레임 airquality에서 변수 Ozone의 값이 80이 넘는 날짜가 며칠이나 되는지 월별로 나타내는 분할표를 작성해 보자. with(airquality, table(OzHi = Ozone &gt; 80, Month)) ## Month ## OzHi 5 6 7 8 9 ## FALSE 25 9 20 19 27 ## TRUE 1 0 6 7 2 위의 분할표를 보면 5월은 26일, 6월은 9일밖에 없는 등 많은 날짜가 생략되어 있음을 알 수 있다. 이것은 자료에 NA가 있기 때문이며 이것을 모두 포함시키려면 다음과 같이 실행하면 된다. with(airquality, table(OzHi = Ozone &gt; 80, Month, useNA = &quot;ifany&quot;)) ## Month ## OzHi 5 6 7 8 9 ## FALSE 25 9 20 19 27 ## TRUE 1 0 6 7 2 ## &lt;NA&gt; 5 21 5 5 1 \\(\\bullet\\) SAS 또는 SPSS에서 출력되는 형태의 분할표 얻기 SAS의 PROC FREQ나 SPSS의 CROSSTABS의 실행결과와 비슷한 형태의 분할표를 얻고자 한다면 패키지 gmodels의 함수 CrossTable()을 사용하면 된다. library(gmodels) with(Arthritis, CrossTable(Treatment, Improved)) ## ## ## Cell Contents ## |-------------------------| ## | N | ## | Chi-square contribution | ## | N / Row Total | ## | N / Col Total | ## | N / Table Total | ## |-------------------------| ## ## ## Total Observations in Table: 84 ## ## ## | Improved ## Treatment | None | Some | Marked | Row Total | ## -------------|-----------|-----------|-----------|-----------| ## Placebo | 29 | 7 | 7 | 43 | ## | 2.616 | 0.004 | 3.752 | | ## | 0.674 | 0.163 | 0.163 | 0.512 | ## | 0.690 | 0.500 | 0.250 | | ## | 0.345 | 0.083 | 0.083 | | ## -------------|-----------|-----------|-----------|-----------| ## Treated | 13 | 7 | 21 | 41 | ## | 2.744 | 0.004 | 3.935 | | ## | 0.317 | 0.171 | 0.512 | 0.488 | ## | 0.310 | 0.500 | 0.750 | | ## | 0.155 | 0.083 | 0.250 | | ## -------------|-----------|-----------|-----------|-----------| ## Column Total | 42 | 14 | 28 | 84 | ## | 0.500 | 0.167 | 0.333 | | ## -------------|-----------|-----------|-----------|-----------| ## ## 위 결과는 SAS 결과물 형태로 출력된 것이며 SPSS 결과물 형태로 출력하고자 한다면 옵션 format = “SPSS”을 추가하면 된다. 자료의 도수와 기대도수만을 나타내고, 두 변수의 독립성 검정을 하고자 한다면 옵션 prop.r, prop.c, prop.t, prop.chisq에 FALSE를 지정하고, expected = TRUE와 chisq = TRUE를 추가하면 된다. with(Arthritis, CrossTable(Treatment, Improved, prop.r = FALSE, prop.c = FALSE, prop.t = FALSE, prop.chisq = FALSE, expected = TRUE, chisq = TRUE) ) ## ## ## Cell Contents ## |-------------------------| ## | N | ## | Expected N | ## |-------------------------| ## ## ## Total Observations in Table: 84 ## ## ## | Improved ## Treatment | None | Some | Marked | Row Total | ## -------------|-----------|-----------|-----------|-----------| ## Placebo | 29 | 7 | 7 | 43 | ## | 21.500 | 7.167 | 14.333 | | ## -------------|-----------|-----------|-----------|-----------| ## Treated | 13 | 7 | 21 | 41 | ## | 20.500 | 6.833 | 13.667 | | ## -------------|-----------|-----------|-----------|-----------| ## Column Total | 42 | 14 | 28 | 84 | ## -------------|-----------|-----------|-----------|-----------| ## ## ## Statistics for All Table Factors ## ## ## Pearson&#39;s Chi-squared test ## ------------------------------------------------------------ ## Chi^2 = 13 d.f. = 2 p = 0.0015 ## ## ## 9.2.2 이변량 및 다변량 범주형 자료를 위한 그래프 이변량 범주형 자료를 대상으로 그래프를 작성하는 주된 목적은 두 범주형 변수의 관계를 탐색하는 것이다. 많이 사용되는 그래프는 막대 그래프이며, 이변량의 경우 쌓아 올린 형태의 막대 그래프와 옆으로 붙여 놓은 형태의 막대 그래프가 사용된다. 패키지 ggplot2에서는 함수는 geom_bar()가 두 형태의 그래프를 작성할 수 있다. 또한 이변량 및 다변량 범주형 자료의 관계 탐색에 적합한 그래프로써 mosaic plot이 있는데, 이 그래프는 패키지 vcd의 mosaic()으로 작성할 수 있다. 예제로 패키지 vcd의 데이터 프레임 Arthritis의 변수 Treatment와 Improved의 관계 탐색을 위한 그래프를 작성해 보자. 우선 함수 count()로 두 변수의 분할표를 작성해 보자. data(Arthritis, package = &quot;vcd&quot;) Arthritis %&gt;% count(Treatment, Improved) ## Treatment Improved n ## 1 Placebo None 29 ## 2 Placebo Some 7 ## 3 Placebo Marked 7 ## 4 Treated None 13 ## 5 Treated Some 7 ## 6 Treated Marked 21 \\(\\bullet\\) 쌓아 올린 막대그래프 쌓아 올린 막대그래프를 작성할 때 주의할 점은 행 변수와 열 변수 중 어느 변수를 위주로 막대를 쌓아 올릴 것인지를 결정해야 한다는 것이다. 만일 두 변수가 설명변수와 반응변수의 성격을 갖고 있다면, 설명변수를 위주로 막대를 쌓는 것이 두 변수의 관계 탐색에 더 효과적일 것이다. 데이터 프레임 Arthritis의 경우에는 변수 Improved가 반응변수이고 나머지 변수는 모두 설명변수가 되기 때문에 변수 Treatment를 위주로 쌓아 올린 막대그래프를 작성해 보자. 함수 geom_bar()에서 시각적 요소 x에는 설명변수를, 시각적 요소 fill에는 반응변수를 연결하면, 설명변수를 위주로 쌓아 올린 막대그래프를 작성할 수 있다. 위약 그룹과 실제 치료가 이루어진 그룹 안에서 병세 호전 정도의 분포를 확인할 수 있으며, 두 그룹 사이에 병세 호전 정도의 차이를 확인할 수 있는 그래프이다. library(tidyverse) Arthritis %&gt;% ggplot(aes(x = Treatment, fill = Improved)) + geom_bar() + ylab(NULL) 그림 9.11: 쌓아 올린 막대그래프 두 변수의 분할표를 데이터로 사용하여 쌓아 올린 막대그래프를 작성해야 하는 경우에는 분할표를 데이터 프레임 형태로 생성시키고, 설명변수인 Treatment를 x에, 빈도수인 n를 y에, 반응변수인 Improved를 fill에 매핑하고, 함수 geom_col() 또는 geom_bar(stat = ”identity”)를 사용하면 된다. Arthritis %&gt;% count(Treatment, Improved) %&gt;% ggplot(aes(x = Treatment, y = n, fill = Improved)) + geom_col() + ylab(NULL) 그림 9.12: 쌓아 올린 막대그래프 \\(\\bullet\\) 옆으로 붙여 놓은 막대그래프 옆으로 붙여 놓은 막대 그래프를 작성하기 위해서는 함수 geom_bar()의 변수 position에 “dodge” 혹은 “dodge2”를 지정하면 된다. “dodge2”는 막대 폭을 조금 줄여서 막대 사이에 약간의 빈틈을 만들어 주는 차이가 있다. Arthritis %&gt;% ggplot(aes(x = Treatment, fill = Improved)) + geom_bar(position = &quot;dodge&quot;) + ylab(NULL) 그림 9.13: 옆으로 붙여 놓은 막대그래프 Arthritis %&gt;% ggplot(aes(x = Treatment, fill = Improved)) + geom_bar(position = &quot;dodge2&quot;) + ylab(NULL) 그림 9.14: 옆으로 붙여 놓은 막대그래프 두 변수의 분할표를 데이터로 사용하여 옆으로 붙여 놓은 막대그래프를 작성해 보자. Arthritis %&gt;% count(Treatment, Improved) %&gt;% ggplot(aes(x = Treatment, y = n, fill = Improved)) + geom_col(position = &quot;dodge&quot;) + ylab(NULL) 그림 9.15: 옆으로 붙여 놓은 막대그래프 상대도수를 사용하여 옆으로 붙여 놓은 막대 그래프를 작성해 보자. 먼저 함수 geom_bar()와 함수 facet_wrap()을 추가로 사용한 방법이다. Arthritis %&gt;% ggplot(aes(x = Improved, y = after_stat(prop), group = 1)) + geom_bar() + facet_wrap(vars(Treatment)) + ylab(NULL) 그림 9.16: 상대도수에 의한 옆으로 붙여 놓은 막대 그래프 상대도수를 사용자가 직접 계산해서 함수 geom_col()을 사용한 방법이다. Arthritis %&gt;% count(Treatment, Improved) %&gt;% mutate(prop = n/sum(n)) %&gt;% ggplot(aes(x = Treatment, y = prop, fill = Improved)) + geom_col(position = &quot;dodge2&quot;) + ylab(NULL) 그림 9.17: 상대도수에 의한 옆으로 붙여 놓은 막대 그래프 함수 geom_bar()로 두 변수의 막대그래프를 작성하는 경우, 시각적 요소 x와 fill에 각각 동일한 변수를 매핑하여도 position에 어떤 값을 지정하는가에 따라 다른 형태의 막대그래프가 작성된다. 디폴트는 “stack”으로 쌓아 올린 형태가 되고, “dodge”는 옆으로 붙여 놓은 형태가 됨을 알 수 있었다. 또 다른 가능한 다른 값으로 “fill”이 있는데, 이 경우에는 x 변수에 대한 fill 변수의 조건부 확률로 막대그래프가 각각 작성된다. 따라서 각 막대의 높이는 1이 된다. Arthritis %&gt;% ggplot(aes(x = Treatment, fill = Improved)) + geom_bar(position = &quot;fill&quot;) + ylab(NULL) 그림 9.18: 조건부 확률을 표현한 쌓아 올린 막대그래프 그림 9.18 에서 각 조각의 면적은 행 변수인 Treatment를 조건으로 하는 열 변수 Improved의 조건부 확률에 의하여 결정됨을 다음의 분할표와 비교해 보면 알 수 있다. 설명변수와 반응변수 사이의 관계를 파악하는 데 더 적합하다고 할 수 있다. Arthritis %&gt;% group_by(Treatment, Improved) %&gt;% tally() %&gt;% mutate(prop = n/sum(n)) ## # A tibble: 6 × 4 ## # Groups: Treatment [2] ## Treatment Improved n prop ## &lt;fct&gt; &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Placebo None 29 0.674 ## 2 Placebo Some 7 0.163 ## 3 Placebo Marked 7 0.163 ## 4 Treated None 13 0.317 ## 5 Treated Some 7 0.171 ## 6 Treated Marked 21 0.512 \\(\\bullet\\) Mosaic plot 이변량 혹은 다변량 범주형 변수의 관계를 탐색할 때 유용하게 사용되는 그래프가 mosaic plot이다. 이 그래프는 쌓아 올린 막대그래프를 확장한 그래프라고 할 수 있으며, 패키지 vcd의 함수 mosaic()으로 작성할 수 있다. 데이터 프레임 Arthritis의 변수 Treatment와 Improved의 분할표인 객체 my_table을 사용하여 작성해 보자. my_table &lt;- with(Arthritis, table(Treatment, Improved)) library(vcd) mosaic(my_table, direction = &quot;v&quot;) 그림 9.19: Mosaic plot 작성방법은 두 변수의 분할표 행 변수(Treatment)의 상대도수(Placebo 0.512, Treated 0.488)의 비율에 따라 정사각형을 수직(direction = “v”)으로 분리한다. 이어서 수직으로 분리된 두 조각을 행 변수 Treatment를 조건으로 하는 열 변수 Improved의 조건부 확률에 비례하여 수평방향으로 각각 분리하여 작성한다. 옵션 direction = “v”가 생략되면 첫번째 분할은 수평방향(direction = “h”)으로 이루어지고, 따라서 두 번째 분할은 수직으로 이루어진다. 함수 mosaic()은 R 공식 형태로도 변수를 지정할 수 있다. 만일 ~ 기호의 오른쪽에만 mosaic(~ var1 + var2)의 형태로 변수를 입력을 하면 var1이 첫 번째 분할 변수, var2가 두 번째 분할 변수로 사용된다. 또한 mosaic(var1 ~ var2)의 형태로 입력되면 var1이 반응변수, var2가 설명변수로 지정되는 것이며, 설명변수가 먼저 분할 변수로 사용되고 마지막으로 반응변수가 분할 변수로 사용된다. 또한 반응변수의 수준에 따라 각 조각이 다른 색으로 채워진다. mosaic(Improved ~ Treatment, data = Arthritis, direction = &quot;v&quot;) 그림 9.20: Mosaic plot 이번에는 반응변수 Improved와 설명변수 Treatment, Sex의 관계를 mosaic plot으로 나타내 보자. mosaic(Improved ~ Treatment + Sex, data = Arthritis, direction = &quot;v&quot;) 그림 9.21: 세 변수의 mosaic plot 함수 mosaic()에서 선의 종류나 색 등의 그래픽 모수는 패키지 grid를 통해 조절이 된다. 패키지 grid에서 그래픽 모수의 기본적인 설정은 gp = gpar(...)이 되며, 다각형도형을 색으로 채우는 옵션은 fill이 된다. mosaic(Improved ~ Treatment + Sex, data = Arthritis, direction = &quot;v&quot;, gp = gpar(fill = c(&quot;pink&quot;, &quot;rosybrown&quot;, &quot;steelblue&quot;))) 그림 9.22: 세 변수의 mosaic plot 그림 9.21 에서 확인할 수 있는 또 다른 사항은 Treatment가 Placebo이고, Sex가 Male인 그룹에서 Improved가 Some에 해당하는 부분에 점이 찍혀있는 것이다. 그것은 이 그룹에 해당되는 자료가 없기 때문인데, 이때 사용되는 점의 크기는 옵션 zero_size로 조절할 수 있다. Mosaic plot을 포함한 범주형 자료의 시각화와 관련된 다양한 방법에 대해서는 Michael Friendly의 홈페이지 를 참조하기 바란다. 9.3 일변량 연속형 자료 탐색 일변량 연속형 자료에 대해서 우리가 가장 관심을 갖고 있는 정보는 자료의 분포 형태일 것이다. 자료의 중심은 어디인가? 자료의 퍼짐 정도는 어떠한가? 이러한 질문에 효과적인 답을 얻기 위해서는 적절한 그래프를 잘 선택해야 할 것이다. 9.3.1 줄기-잎 그림 줄기-잎 그림은 비교적 소규모 자료의 분포를 나타내는 데 적합한 그래프라고 할 수 있다. 자료를 ’줄기’와 ’잎’으로 구분하고, ’줄기’를 수직으로 세운 후에 해당되는 ’줄기’에 ’잎’들을 크기 순서로 붙여 나타내는 그림이다. 줄기-잎 그림은 함수 stem()으로 작성할 수 있으며, 일반적인 사용법은 stem(x, scale = 1)이다. 변수 x는 숫자형 벡터이며, scale은 줄기-잎 그림의 길이를 조절하는 것으로 scale = 2가 되면 대략 2배 길이의 그래프가 그려진다. 그래프의 길이를 늘이는 방법은 대부분 ’줄기’를 더 세분화시키는 방식으로 이루어진다. 예제 데이터로는 데이터 프레임 women을 사용해 보자. 여기에는 30세에서 39세 사이의 미국 여성들의 키와 몸무게 데이터가 height와 weight로 입력되어 있다. 두 변수의 줄기-잎 그림을 그려보자. 줄기-잎 그림은 Console 창에 결과가 나타난다. with(women, stem(height)) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 5 | 89 ## 6 | 01234 ## 6 | 56789 ## 7 | 012 with(women, stem(weight)) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 11 | 57 ## 12 | 0369 ## 13 | 259 ## 14 | 26 ## 15 | 049 ## 16 | 4 옵션 scale을 이용하여 그래프의 길이를 늘여야 하는 경우에 대한 예제를 살펴보자. x &lt;- c(98, 102, 114, 122, 132, 144, 106, 117, 151, 118, 124, 115) stem(x) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 8 | 8 ## 10 | 264578 ## 12 | 242 ## 14 | 41 자료의 개수에 비해 ’줄기’가 지나치게 많은 경우로, 디폴트 scale 값에서는 ’줄기’가 통합되어 실제로는 없는 줄기가 나타났다. 이것을 scale = 2로 조정하여 작성해 보자. stem(x, scale = 2) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 9 | 8 ## 10 | 26 ## 11 | 4578 ## 12 | 24 ## 13 | 2 ## 14 | 4 ## 15 | 1 9.3.2 상자그림 상자그림은 box plot 혹은 box-and-whiskers plot이라고 불리는 그래프로 John Tukey가 개발하였다. 사분위수인 0.25분위수(Q1), 중앙값, 0.75분위수(Q3)를 이용하여 작성하는 단순한 형태의 그래프이나, 분포의 중심, 퍼짐 정도, 치우침 정도(skewness), 꼬리의 길이 등이 상당히 명확하게 나타난다. 상자그림의 작성에서 0.25분위수, 중앙값, 그리고 0.75분위수로 표현되는 상자로부터 양쪽 꼬리 방향으로 그려지는 whisker의 길이에 대한 두 가지 대안이 있는데, 첫 번째 방법은 최솟값과 최댓값까지 단순하게 연결하는 것이다. 두 번째 방법은 상자의 길이(IQR)의 1.5배가 넘지 않는 관찰값까지 연결하고, 그 범위를 초과하는 관찰값들은 따로 점으로 표시하는 방법이다. 첫 번째 방법은 꼬리 부분에 있을 수 있는 이상값에 대한 정보를 전혀 표현할 수 없기 때문에 최근에는 거의 사용되지 않는 방법이라 하겠다. 따라서 두 번째 방법으로만 상자그림을 작성하겠다. 예제 데이터로는 패키지 UsingR에 있는 데이터 프레임 alltime.movies를 사용해 보자. 데이터 프레임 alltime.movies에는 2003년까지 미국에서 상영된 영화 중 총수입이 가장 많았던 79개 영화의 총수입(Gross)과 처음 상영된 년도(Release.Year)가 변수로 있고, 영화제목은 행 이름으로 입력되어 있다. 총수입 Gross의 상자그림을 작성해 보자. 상자그림은 함수 geom_boxplot()으로 작성할 수 있다. 한 변수의 상자그림을 작성하는 경우에도 시각적 요소 x와 y가 모두 필요하다. x에 하나의 값만을 갖는 문자를 매핑하고, y에 연속형 변수를 매핑하면 수직방향으로 상자그림이 작성되고, x에 연속형 변수를, y에 하나의 값을 갖는 문자를 매핑하면 수평방향으로 상자그림이 작성된다. data(alltime.movies, package = &quot;UsingR&quot;) library(tidyverse) ggplot(alltime.movies, aes(x = &quot;&quot;, y = Gross)) + geom_boxplot() + xlab(NULL) 그림 9.23: 변수 Gross의 수직방향 상자그림 library(tidyverse) ggplot(alltime.movies, aes(y = &quot;&quot;, x = Gross)) + geom_boxplot() + ylab(NULL) 그림 9.24: 변수 Gross의 수평방향 상자그림 함수 geom_boxplot()으로 작성된 그림 9.24 의 상자그림에 표시된 이상값이 어떤 케이 스에 해당되는 것인지 확인해 보는 것은 중요한 작업이 될 수 있다. 이러한 작업에 필요한 함수는 ggplot_build()이다. 이 함수에 ggplot 객체를 입력하면 그래프 작성에 사용된 모든 내용을 보여준다. 생성된 결과는 리스트로서 각 레이어(layer) 작성에 필요한 통계량이 데이터 프레임 형태로 입력되어 있다. 이제 그림 9.24를 작성한 ggplot 객체를 함수 ggplot_build()에 입력하고 생성된 리스트의 첫 번째 요소인 데이터 프레임의 내용을 살펴보자. bp &lt;- ggplot(alltime.movies, aes(y = &quot;&quot;, x = Gross)) + geom_boxplot() ggplot_build(bp)[[1]][[1]] %&gt;% str() ## &#39;data.frame&#39;: 1 obs. of 26 variables: ## $ xmin : num 172 ## $ xlower : num 184 ## $ xmiddle : num 216 ## $ xupper : num 260 ## $ xmax : num 357 ## $ outliers :List of 1 ## ..$ : num 601 461 435 431 404 ## $ notchupper : num 230 ## $ notchlower : num 202 ## $ y : &#39;mapped_discrete&#39; num 1 ## $ flipped_aes: logi TRUE ## $ PANEL : Factor w/ 1 level &quot;1&quot;: 1 ## $ group : int 1 ## $ xmin_final : num 172 ## $ xmax_final : num 601 ## $ ymin : &#39;mapped_discrete&#39; num 0.625 ## $ ymax : &#39;mapped_discrete&#39; num 1.38 ## $ xid : num 1 ## $ newx : num 1 ## $ new_width : num 0.75 ## $ weight : num 1 ## $ colour : chr &quot;grey20&quot; ## $ fill : chr &quot;white&quot; ## $ alpha : logi NA ## $ shape : num 19 ## $ linetype : chr &quot;solid&quot; ## $ linewidth : num 0.5 이상값으로 나타난 변수 Gross의 값은 $outliers에 리스트로 입력되어 있다. 이것을 벡터 형태로 추출해 보자. bp_out &lt;- ggplot_build(bp)[[1]][[1]]$outliers[[1]] bp_out ## [1] 601 461 435 431 404 이제 변수 Gross가 위의 값을 갖는 관찰값들이 어떤 케이스, 즉 어떤 영화의 총수입에 해당되는지를 알아보자. 우선 영화제목이 데이터 프레임 alltime.movies의 rownames로 입력되어 있는데, 이것을 데이터 프레임에 변수로 포함시켜 보자. alltime &lt;- alltime.movies %&gt;% rownames_to_column(var = &quot;Movie.Title&quot;) %&gt;% as_tibble() %&gt;% print(n = 3) ## # A tibble: 79 × 3 ## Movie.Title Gross Release.Year ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &quot;Titanic &quot; 601 1997 ## 2 &quot;Star Wars &quot; 461 1977 ## 3 &quot;E.T. &quot; 435 1982 ## # ℹ 76 more rows 이제 데이터 프레임 alltime에서 변수 Gross의 값이 bp_out의 값과 같은 케이스를 패키지 dplyr의 함수 filter()에 연산자 %in%을 사용하여 선택해 보자. alltime %&gt;% filter(Gross %in% bp_out) ## # A tibble: 5 × 3 ## Movie.Title Gross Release.Year ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 &quot;Titanic &quot; 601 1997 ## 2 &quot;Star Wars &quot; 461 1977 ## 3 &quot;E.T. &quot; 435 1982 ## 4 &quot;Star Wars: The Phantom Menace &quot; 431 1999 ## 5 &quot;Spider-Man &quot; 404 2002 상자그림에 자료의 위치를 점으로 함께 나타내는 것도 나름 의미가 있는 그래프가 된다. 함수 geom_point()를 추가하면 되는데, 이때 한 가지 주의할 점은 함수 geom_boxplot()에서 이상값을 점으로 표시하지 않도록 해야 한다는 것이다. 이 작업은 옵션 outlier.shape = NA 또는 ourlier.color = NA 또는 outlier.size = -1을 함수 geom_boxplot()에 포함시키면 된다. ggplot(alltime.movies, aes(x = &quot;&quot;, y = Gross)) + geom_boxplot(outlier.shape = NA) + geom_point(color = &quot;red&quot;) + xlab(NULL) 그림 9.25: 상자그림에 자료의 위치 추가 상자그림의 상자 안에 많은 점들이 서로 겹쳐져 있는 것을 볼 수 있다. 이런 경우에 점들의 위치에 약간 난수를 더해 조정해 주면 점들이 서로 겹쳐지는 문제를 어느 정도 해결 할 수 있는데, 함수 geom_jitter()로 할 수 있는 작업이다. ggplot(alltime.movies, aes(x = &quot;&quot;, y = Gross)) + geom_boxplot(outlier.shape = NA) + geom_jitter(color = &quot;red&quot;, width = 0.01) + xlab(NULL) 그림 9.26: 상자그림에 자료의 위치 추가 상자그림은 자료의 분위수를 기반으로 작성된 그래프이다. 따라서 중앙값의 위치는 표시가 되지만 평균값의 위치는 나타나지 않는 것이 일반적인 모습이다. 하지만 평균값의 위치를 추가적으로 표시하는 것이 자료의 분포를 이해하는 데 도움이 될 수도 있을 것이다. 자료의 요약통계량을 계산해서 그래프에 표시하는 작업은 함수 stat_summary()를 사용하면 할 수 있다. 이 함수는 개별 x값에 대하여 주어진 y값의 요약통계량 또는 개별 y값에 대하여 주어진 x값의 요약통계량을 계산하는 기능이 있다. 원하는 요약통계량은 변수 fun에 지정하고, 원하는 그래프 형태를 변수 geom에 지정하면 된다. 평균값이 빨간 십자 형태로 상자그림에 표시되었음을 알 수 있다. ggplot(alltime.movies, aes(x = &quot;&quot;, y = Gross)) + geom_boxplot() + stat_summary(fun = &quot;mean&quot;, geom = &quot;point&quot;, color = &quot;red&quot;, shape = 3, size = 4, stroke = 2) + xlab(NULL) 그림 9.27: 상자그림에 평균값 표시 추가 \\(\\bullet\\) Violin plot 상자그림에 부가적인 정보를 추가한 변형된 형태의 상자그림이라고 할 수 있는 그래프로 violin plot이 있다. 이 그래프는 상자그림과 확률밀도함수 그래프의 조합이라고 할 수 있는데, 확률밀도함수 그래프는 9.3.4절에서 찾아볼 수 있다. Violin plot의 작성은 패키지 vioplot의 함수 vioplot()으로 할 수 있다. library(vioplot) vioplot(alltime.movies$Gross, col = &quot;pink&quot;, xlab = &quot; &quot;) 그림 9.28: 패키지 vioplot의 Violin plot: 수직방향 vioplot(alltime.movies$Gross, col = &quot;green&quot;, horizontal = TRUE) 그림 9.29: 패키지 vioplot의 Violin plot: 수평방향 그림 9.28와 그림 9.29 에서 볼 수 있듯이 violin plot은 상자그림을 중심으로 확률밀도함수 그래프를 대칭으로 그려놓은 그래프이다. 하얀 점은 중앙값을 나타내고 있으며, 검은 상자는 0.25분위수에서 0.75분위수까지 그려져 있고, whisker는 검은색 실선으로 그려져 있다. 상자그림 외부의 그림은 확률밀도함수 그래프가 그려져 있어서 시각적으로 조금 더 분명하게 분포형태에 대한 정보를 제공해주고 있다. 많이 사용되고 있지는 않지만 상당히 효과적으로 사용할 수 있는 그래프라고 할 것이다. 패키지 ggplot2에서 violin plot의 작성은 함수 geom_violin()으로 할 수 있다. 이 함수는 상자그림없이 확률밀도함수 그래프만을 대칭으로 작성한다. vio &lt;- ggplot(alltime.movies, aes(x = &quot;&quot;, y = Gross)) + xlab(NULL) vio + geom_violin() 그림 9.30: 패키지 ggplot2의 violin plot 분위수를 함께 표시하고자 한다면 변수 draw_quantiles에 표시를 원하는 분위수를 지정해야 한다. vio + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), fill = &quot;lightblue&quot;) 그림 9.31: 패키지 ggplot2의 violin plot: 분위수 함께 표시 상자그림과 함께 violin plot을 작성하고자 한다면 함수 geom_boxplot()을 함께 사용하면 된다. 변수 width는 상자그림의 폭을 조절하기 위해 추가했다. vio + geom_violin(fill = &quot;lightblue&quot;) + geom_boxplot(width = 0.1) 그림 9.32: 패키지 ggplot2의 violin plot: 상자그림 추가 함수 geom_violin()을 함수 geom_boxplot()의 뒤에 추가한다면 투명도를 조절하는 시각적 요소인 alpha의 값을 낮게 지정하여 투명도를 높여야 상자그림이 보이게 된다. vio + geom_boxplot(width = 0.1) + geom_violin(fill = &quot;lightblue&quot;, alpha = 0.3) 그림 9.33: 패키지 ggplot2의 violin plot: 상자그림 추가 9.3.3 히스토그램 히스토그램은 연속형 자료의 분포를 시각화하는 데 가장 많이 사용되는 그래프 중 하나이다. 작성방법은 자료의 전 범위를 서로 겹치지 않는 구간(bin)으로 구분하고, 각 구간에 속한 자료의 빈도를 구한다. 이어서 각각의 구간을 X축으로, 그 구간에 대한 빈도수를 나타내는 값을 Y축으로 하여 막대를 그리면 된다. 패키지 ggplot2에서는 함수 geom_histogram()으로 히스토그램을 작성할 수 있다. 구간 설정은 구간의 개수를 bins에 지정하거나, 구간의 폭을 binwidth에 지정하면 된다. 디폴트는 bins = 30으로 히스토그램을 작성한다. 예제 데이터로 데이터 프레임 faithful을 사용해 보자. 이 데이터 프레임에는 미국 Yellowstone 국립공원에 있는 Old Faithful이라는 간헐천의 분출지속시간(eruptions)과 분출간격(waiting)이 변수로 있다. 이 중 분출간격에 대한 분포를 히스토그램으로 나타내보자. 히스토그램의 형태는 구간을 어떻게 설정하는가에 따라 크게 변하게 된다. library(patchwork) h1 &lt;- ggplot(faithful, aes(waiting)) + geom_histogram() + ylab(NULL) h2 &lt;- ggplot(faithful, aes(waiting)) + geom_histogram(bins = 10) + ylab(NULL) h3 &lt;- ggplot(faithful, aes(waiting)) + geom_histogram(binwidth = 3) + ylab(NULL) h1 + h2 + h3 그림 9.34: 함수 geom_histogram()으로 작성한 히스토그램 그림 9.34에서 볼 수 있듯이 구간을 어떻게 설정하는가에 따라 히스토그램의 모습이 크게 변하게 된다. 디폴트 구간으로 작성된 히스토그램이 만족스러운 결과를 보여주는 경우도 있겠지만 전적으로 의존하기에는 아쉬운 점이 많다. 이렇듯 구간설정 문제는 히스토그램의 중요한 문제라 할 수 있으나, 적절한 구간설정에 관한 이론적 접근에 대해서는 생략한다. 히스토그램의 또 한 가지 문제는 연속형 데이터의 분포를 계단 형태로 표현함으로써 생기는 어색함이라고 할 수 있다. 이것은 히스토그램의 태생적인 한계라고 할 수 있는데, 이 문제는 9.3.4절에서 살펴볼 확률밀도함수 그래프를 히스토그램에 겹쳐서 나타내거나, 도수분포다각형을 작성하는 것으로 어느 정도 완화할 수 있다. 9.3.4 확률밀도함수 그래프 연속형 자료의 분포형태를 알아보기 위한 그래프로써 지금까지 줄기-잎 그림, 상자그림, 히스토그램을 살펴보았다. 이 그래프들은 모두 나름의 장점이 있는 좋은 그래프들이다. 그러나 줄기-잎 그림은 대규모의 데이터에는 적합하지 않다는 단점이 있고, 상자그림은 사분위수를 기본으로 하여 나타낸 그래프이기 때문에 분포의 세밀한 특징이 잘 나타나지 않을 수 있다. 또한 연속형 자료의 분포는 매끄러운 곡선의 형태를 지니고 있으나 히스토그램은 항상 계단함수의 형태를 보일 수밖에 없다는 한계가 있다. 대규모의 데이터에도 쉽게 적용되며 분포의 세밀한 특징도 잘 나타내고, 또한 매끄러운 곡선으로 분포의 형태를 나타낼 수 있는 방법이 바로 확률밀도함수를 추정하여 그래프로 나타내는 것이다. 분포 형태를 매우 효과적으로 나타낼 수 있기 때문에 최근 많이 사용되고 있는 방법이다. 패키지 ggplot2에서는 함수 geom_density()로 확률밀도함수 그래프를 작성할 수 있다. 다만 이때 주의할 점은 그래프를 표시할 X축의 구간을 자료의 실제 구간보다 더 넓게 잡아주어야 한다는 것인데, 그렇지 않았을 경우에는 꼬리가 잘린 형태의 확률밀도함수가 추정되어 그래프로 작성된다. 또한 X축에 자료의 위치를 눈금으로 표시해 주는 Rug plot은 함수 geom_rug()를 추가하면 작성된다. library(patchwork) d1 &lt;- ggplot(faithful, aes(waiting)) + geom_density(fill = &quot;skyblue&quot;) + ylab(NULL) d2 &lt;- ggplot(faithful, aes(waiting)) + geom_density(fill = &quot;skyblue&quot;) + ylab(NULL) + xlim(30, 110) d3 &lt;- ggplot(faithful, aes(waiting)) + geom_density(fill = &quot;skyblue&quot;) + geom_rug() + ylab(NULL) + xlim(30, 110) d1 + d2 + d3 그림 9.35: 함수 geom_density()로 작성한 확률밀도함수 그래프 확률밀도함수 그래프는 단독으로 작성되는 경우도 많이 있지만, 히스토그램과 겹쳐서 작성하는 것도 의미 있는 작업이 된다. 히스토그램과 확률밀도함수 그래프를 겹치게 작성하기 위해서는 함수 geom_histogram()에서 시각적 요소 y에 변수 after_stat(density)를 매핑해야 히스토그램이 확률밀도로 표현된다. 이어서 함수 geom_density()로 확률밀도함수 그래프를 추가하면 된다. ggplot(faithful, aes(x = waiting, y = after_stat(density))) + geom_histogram(fill = &quot;red&quot;, binwidth = 5) + geom_density(color = &quot;blue&quot;, size = 1) + xlim(30, 110) + ylab(NULL) ## Warning: Removed 2 rows containing missing values (`geom_bar()`). 그림 9.36: 히스토그램과 확률밀도함수 그래프를 겹쳐지게 작성 만일 geom_density()를 먼저 작성하고 geom_histogram()을 그 다음에 작성한다면 히스토그램을 투명하게 만드는 것이 필요하다. ggplot(faithful, aes(x = waiting, y = after_stat(density))) + geom_density(color = &quot;blue&quot;, size = 1) + geom_histogram(fill = &quot;red&quot;, binwidth = 5, alpha = 0.6) + xlim(30, 110) + ylab(NULL) ## Warning: Removed 2 rows containing missing values (`geom_bar()`). 그림 9.37: 히스토그램과 확률밀도함수 그래프를 겹쳐지게 작성 9.3.5 기타 유용한 그래프 지금까지 살펴본 그래프 외에 연속형 변수의 분포를 나타내는 유용한 그래프를 더 살펴보자. \\(\\bullet\\) 도수분포다각형(frequency polygon) 히스토그램이 각 구간에 속한 자료의 도수를 높이로 하는 막대로 분포를 나타내는 데 반하여 도수분포다각형은 각 구간의 도수를 선으로 연결한 다각형으로 분포를 나타내는 그래프이다. 그래프의 작성은 함수 geom_freqpoly()로 할 수 있으며, 사용법은 geom_histogram()과 동일하다. 예제로 데이터 프레임 faithful의 변수 waiting에 대한 도수분포다각형을 작성해 보자. library(patchwork) fp1 &lt;- ggplot(faithful, aes(waiting)) + geom_freqpoly(binwidth = 5) fp2 &lt;- ggplot(faithful, aes(waiting, after_stat(density))) + geom_freqpoly(binwidth = 5) fp1 + fp2 그림 9.38: 함수 geom_freqpoly()로 작성된 도수분포다각형 도수분포다각형은 범주형 변수에 의해 구분되는 그룹별로 연속형 변수의 분포를 비교하 는 경우에 히스토그램보다 더 유용하게 사용될 수 있는 그래프이다. \\(\\bullet\\) 점그래프(dot plot) 소규모 데이터의 분포를 표현할 때 유용하게 사용할 수 있는 그래프이다. 자료의 전 범위를 구간(bin)으로 구분하여 각 구간에 속한 자료 한 개당 하나의 점을 위로 쌓아 올리는 방식으로 작성되는 그래프이다. 패키지 ggplot2에서는 함수 geom_dotplot()으로 작성할 수 있으며, 구간의 간격은 변수 binwidth에 지정할 수 있다. 데이터 프레임 faithful의 변수 waiting에 대한 점그래프를 작성해 보자. ggplot(faithful, aes(waiting)) + geom_dotplot(binwidth = 1.5) 그림 9.39: 함수 geom_dotplot()으로 작성된 점 그래프 히스토그램과 유사한 특징을 보이는 그래프라는 것을 알 수 있다. 다만 그림 9.39의 Y축 scale이 잘못되어 있는데, 이것을 scale 함수로 제거하자. ggplot(faithful, aes(waiting)) + geom_dotplot(binwidth = 1.5) + scale_y_continuous(breaks = NULL) 그림 9.40: 함수 geom_dotplot()으로 작성된 점 그래프 \\(\\bullet\\) 경험적 누적분포함수 그래프 경험적 누적분포함수(empirical cumulative distribution function)는 각 자료값에서 \\(1/n\\) 의 높이를 갖고 증가하는 계단함수이다. 한 변수의 분포형태를 매우 정확하게 표현할 수 있는 그래프라고 할 수 있다. 다만 확률밀도함수가 아닌 분포함수를 나타내는 그래프이기 때문에 익숙하지 않은 사용자도 있을 것이다. 그래프의 작성은 stat_ecdf()로 할 수 있다. 데이터 프레임 faithful의 변수 waiting의 경험적 누적분포함수 그래프를 작성해 보자. ggplot(faithful, aes(waiting)) + stat_ecdf() 그림 9.41: 함수 stat_ecdf()로 작성된 경험적 누적분포함수 그래프 9.3.6 일변량 연속형 자료의 요약통계 일변량 자료분석의 첫 단계는 그래프를 이용하여 자료의 분포에 어떤 특징이 있는지를 살펴보는 것이다. 분포의 특징을 시각적으로 나타내는 것에 더하여 자료의 정보를 몇 개의 숫자로 요약해 주는 요약통계가 추가되면 다음 단계의 분석, 즉 다른 변수와의 비교 및 관계 탐구 등으로 나아가는 데 도움이 될 것이다. 이 절에서는 연속형 자료를 대상으로 자료의 중심을 나타내는 요약통계와 자료의 퍼짐을 나타내는 요약통계에 관련된 R 함수를 살펴보고자 한다. \\(\\bullet\\) 자료의 중심에 대한 요약통계 자료의 중심을 나타내는 요약통계량으로 가장 많이 사용되는 평균과 중앙값은 함수 mean()과 median()으로 각각 계산할 수 있다. 통계학개론에서 소개되는 최빈값은 연속형 데이터의 경우에는 의미가 없는 통계량이므로 여기에서는 다루지 않겠다. 자료에 결측값이 있는 경우, 함수 mean()과 median()의 계산 결과는 NA가 된다. 이런 경우에는 옵션 na.rm = TRUE를 포함시키면 자료에서 NA를 제외하고 나머지 자료만을 대상으로 계산을 하게 된다. 데이터 프레임 airquality의 변수 Ozone에는 다수의 결측값이 포함되어 있다. 변수 Ozone의 평균값과 중앙값을 각각 계산해보자. my_stat &lt;- list(m = ~ mean(.x, na.rm = TRUE), med = ~ median(.x, na.rm = TRUE)) airquality %&gt;% summarise(across(Ozone, my_stat)) ## Ozone_m Ozone_med ## 1 42 32 분포의 형태가 좌우대칭에 가까운 경우에는 평균값이 가장 좋은 요약통계량이 되지만 좌측 또는 우측으로 심하게 치우친 분포의 경우에는 극단값에 큰 영향을 받지 않는 중앙값이 분포의 중심을 더 정확하게 나타내는 요약통계량이 될 것이다. 따라서 만일 평균값과 중앙값이 크게 차이가 난다면 치우친 형태의 분포가 될 가능성이 높은 것이다. 패키지 UsingR에 있는 데이터 프레임 cfb는 2001년 미국 소비자 재정상태에 관한 조사 데이터인데, 이 중 변수 INCOME에는 가구당 소득이 들어있다. 변수 INCOME의 분포형태를 살펴보자. data(cfb, package = &quot;UsingR&quot;) cfb %&gt;% summarise(across(INCOME, my_stat)) ## INCOME_m INCOME_med ## 1 63403 38033 평균값이 중앙값의 약 1.67배가 될 정도로 크게 차이가 나는 것을 볼 때 우측으로 심하게 치우친 분포, 즉 우측 꼬리가 매우 긴 분포임을 알 수 있다. 변수 INCOME의 정확한 분포의 형태를 알아보기 위하여 히스토그램을 작성해 보자. ggplot(cfb, aes(x = INCOME, y = after_stat(density))) + geom_histogram(bins = 35, fill = &quot;steelblue&quot;) + geom_density(color = &quot;red&quot;, size = 1) 그림 9.42: 변수 INCOME의 히스토그램 심하게 치우친 분포에 대해서는 대부분 변수변환을 통해 좌우대칭에 가까운 분포로 형태를 바꿔주게 된다. 변수 INCOME의 분포는 우측으로 심하게 치우친 분포이므로 로그 혹은 제곱근 변환을 통해 좌우대칭 분포로 변환시킬 수 있는데, 여기에서는 로그변환을 실시해보자. cfb %&gt;% mutate(log_income = log(INCOME)) %&gt;% summarise(across(log_income, my_stat)) ## log_income_m log_income_med ## 1 -Inf 11 위 실행결과는 로그변환에서 주의할 점을 알려주고 있는데, 변수 log_income의 평균값이 -Inf가 된 것은 0이 포함된 변수 INCOME을 로그변환하였기 때문이다. 간단한 해결방안은 모든 자료를 우측으로 1만큼 이동시키는 것이다. cfb %&gt;% mutate(log_income = log(INCOME+1)) %&gt;% summarise(across(log_income, my_stat)) ## log_income_m log_income_med ## 1 10.49809 10.54623 로그변환된 변수 INCOME의 분포를 히스토그램으로 나타내 보자. cfb %&gt;% mutate(log_income = log(INCOME+1)) %&gt;% ggplot(aes(x = log_income, y = after_stat(density))) + geom_histogram(fill = &quot;steelblue&quot;, bins = 35) + geom_density(color = &quot;red&quot;, size = 1) 그림 9.43: 로그 변환된 변수 INCOME의 히스토그램 우측으로 심하게 치우친 모습을 보인 분포가 로그변환으로 좌우대칭의 모습을 보이는 분포로 바뀐 것을 알 수 있다. 그림 9.43의 좌측 끝부분에 있는 극단값은 변수 INCOME의 값이 0인 4개의 케이스에 해당되는 것이다. \\(\\bullet\\) 자료의 퍼짐정도에 대한 요약통계 자료의 중심에 대한 요약통계만으로는 자료의 분포에 대한 정확한 묘사가 불가능하다고 할 수 있는데, 다음에 주어진 시험점수 모의 자료를 살펴보자. 1차 시험(test1) 2차 시험(test2) 점수 75, 77, 80, 82, 85, 87, 88 50, 57, 80, 82, 86, 100, 100 평균 82 79.3 두 시험의 평균은 비슷하지만 자료의 퍼짐 정도에는 큰 차이가 있음을 알 수 있다. 자료의 퍼짐 정도를 측정하는 통계량에는 범위(range), 사분위범위(interquartile range), 표준편차 및 분산 등이 있다. 우선 1차 시험과 2차 시험 데이터의 범위를 구해 보자. 범위는 가장 단순한 자료 퍼짐 정도의 측정도구이다. 많은 수의 자료 중 오직 두 값(최솟값, 최댓값)만으로 계산하는 것이므로 전체 자료의 성격을 올바로 담아낼 수는 없다. 자료의 범위는 최솟값과 최댓값을 계산해주는 함수 range()의 결과를 함수 diff()에 입력하여 두 값의 차이를 계산하면 된다. test1 &lt;- c(75, 77, 80, 82, 85, 87, 88) test2 &lt;- c(50, 57, 80, 82, 86, 100, 100) test1 |&gt; range() |&gt; diff() ## [1] 13 test2 |&gt; range() |&gt; diff() ## [1] 50 다음으로 사분위범위와 관련된 함수에 대해서 살펴보자. 사분위범위는 분위수 혹은 백분위수를 기반으로 정의되는 것이므로 분위수에 대해서 먼저 살펴보자. \\(p\\) 분위수란 전체 자료 중 \\(100\\times p \\%\\)의 자료보다는 크고 나머지 \\(100 \\times (1-p) \\%\\) 의 자료보다는 작은 수를 의미한다. 단, 여기서 \\(p\\) 의 범위는 \\(0 \\leq p \\leq 1\\) 이다. 백분위수는 분위수를 백분율로 표시한 것이다. 따라서 중앙값은 0.5분위수 및 50백분위수가 된다. 이어서 4분위수란 전체 데이터를 크기순으로 나열했을 때 4등분하는 3개의 수를 의미하는 것으로써 0.25분위수(\\(Q_{1}\\)), 중앙값, 0.75분위수(\\(Q_{3}\\))를 의미한다. 이제 사분위범위를 정의할 수 있는데, 사분위범위란 0.75분위수와 0.25분위수의 차이를 의미한다. 분위수의 계산은 함수 quantile()로 하며, 기본적인 사용법은 quantile(x, probs = seq(0, 1, by = 0.25), ...)이다. 함수 quantile()의 옵션 probs에는 원하는 확률값을 지정할 수 있으며, 생략되면 최솟값(0%), 최댓값(100%)을 포함한 4분위수가 출력된다. 이제 시험점수 모의 데이터에 함수 quantile()을 적용해 보자. quantile(test1) ## 0% 25% 50% 75% 100% ## 75.0 78.5 82.0 86.0 88.0 quantile(test2) ## 0% 25% 50% 75% 100% ## 50.0 68.5 82.0 93.0 100.0 quantile(test1, probs = 0.25) ## 25% ## 78.5 quantile(test2, probs = 0.25) ## 25% ## 68.5 사분위범위는 함수 IQR()로 계산할 수 있다. IQR(test1) ## [1] 7.5 IQR(test2) ## [1] 24.5 자료의 퍼짐 정도를 측정하는 도구로 가장 많이 사용되는 통계량이 표준편차와 분산이다. 두 통계량은 각 자료들이 자료의 평균에서부터 떨어진 거리를 이용하여 퍼짐 정도를 측정하고 있다. 대략적으로 표준편차는 각 관찰값들이 평균에서부터 떨어져 있는 거리의 평균값이라고 해석할 수 있다. 표준편차와 분산은 함수 sd()와 var()로 계산할 수 있다. var(test1) ## [1] 24.66667 var(test2) ## [1] 377.5714 sd(test1) ## [1] 4.966555 sd(test2) ## [1] 19.4312 지금까지 살펴본 함수들과 함께 어울리며 일변량 자료의 요약통계를 계산하는 데 효과적으로 사용되는 함수가 summary()이다. 이 함수도 generic 함수로서 입력되는 객체의 class에 따라 다른 분석결과가 출력되는데, 숫자형 자료가 입력되면 4분위수와 평균값, 최솟값과 최댓값이 계산된다. data(cfb, package = &quot;UsingR&quot;) summary(cfb$INCOME) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0 20558 38033 63403 69898 1541866 변수 INCOME의 평균값이 0.75분위수와 무척 가까운 값임을 알 수 있는데, 실제 평균값이 몇 분위수에 해당되는지 어떻게 계산할 수 있겠는가? 이것은 변수 INCOME의 각 관찰값들 중 평균값보다 작은 값들의 비율을 계산하면 되는데, 다음과 같이 간단하게 계산할 수있다. 변수 INCOME의 평균값이 0.705분위수에 해당한다는 것을 알 수 있다. with(cfb, mean(INCOME &lt;= mean(INCOME))) ## [1] 0.705 중심과 퍼짐 정도가 다른 자료들은 표준화 과정을 통하여 동일한 중심과 퍼짐 정도를 갖게 된다. 자료의 표준화는 함수 scale()로 할 수 있으며, 일반적인 사용법은 scale(x, center = TRUE, scale = TRUE)가 된다. x는 숫자형 행렬 또는 벡터가 되는데, 행렬인 경우에는 각 열 단위로 표준화가 진행된다. 시험점수 자료를 행렬로 묶어서 표준화를 실시해 보자. cbind(test1, test2) |&gt; scale() ## test1 test2 ## [1,] -1.4094277 -1.50714924 ## [2,] -1.0067341 -1.14690381 ## [3,] -0.4026936 0.03675974 ## [4,] 0.0000000 0.13968700 ## [5,] 0.6040404 0.34554153 ## [6,] 1.0067341 1.06603239 ## [7,] 1.2080809 1.06603239 ## attr(,&quot;scaled:center&quot;) ## test1 test2 ## 82.00000 79.28571 ## attr(,&quot;scaled:scale&quot;) ## test1 test2 ## 4.966555 19.431197 시험점수자료의 변환 전 분포와 변환 후 분포를 나타낸 그래프가 그림 9.44에 있다. 그림 9.44: 표준화 전후의 자료 분포 9.4 이변량 연속형 자료 탐색 연속형 변수가 두 개 혹은 그 이상 주어질 때 우리의 주된 관심은 변수들의 분포 비교와 변수 사이의 관계 탐색이라고 할 수 있다. 이 작업들은 그래프와 요약통계를 함께 이용해야 효과적으로 이루어질 수 있다. 9.4.1 연속형 변수의 분포를 비교하기 위한 그래프 두 개 이상의 연속형 변수의 자료가 주어졌을 경우, 그 변수들의 분포를 비교하는 것은 가장 기본적인 작업이라고 할 수 있다. 만일 어느 한 연속형 변수의 분포가 어떤 요인으로 구분되는 그룹마다 다르다면, 그것은 곧 그룹변수가 연속형 변수에 통계적으로 유의한 영향을 미치고 있다고 해석될 수 있다. 일변량 연속형 변수의 분포를 나타내는 그래프라면 분포의 비교 목적으로도 사용될 수 있을 것이다. 그룹별로 분포를 비교하고자 할 때 먼저 시도할 수 있는 것은 facet일 것이다. 함수 facet_wrap() 혹은 facet_grid()를 이용하여 그룹별로 분포를 나타내는 그래프를 작성해서 비교하는 것을 생각해 볼 수 있다. 다른 방법으로는 그룹별 그래프를 겹치게 작성하는 것이다. 하나의 그래프에서 비교하는 것이므로 의미있는 비교가 될 수 있을 것이다. \\(\\bullet\\) 히스토그램에 의한 그룹 자료의 분포 비교 예제로 패키지 ggplot2에 있는 데이터 프레임 mpg의 변수 cyl에 따른 연속형 변수 hwy의 분포를 비교해 보자. 변수 cyl은 자동차 엔진의 실린더 개수를 의미하는 것으로 4, 5, 6, 8의 네 가지 값을 갖는 숫자형 변수이고, 변수 hwy는 자동차의 고속도로 연비를 나타내는 변수이다. 먼저 변수 cyl로 구분되는 그룹에 속한 자료의 개수를 구해 보자. library(tidyverse) mpg %&gt;% count(cyl) ## # A tibble: 4 × 2 ## cyl n ## &lt;int&gt; &lt;int&gt; ## 1 4 81 ## 2 5 4 ## 3 6 79 ## 4 8 70 변수 cyl이 5가 되는 자료의 개수가 너무 적다는 것을 알 수 있다. 따라서 변수 cyl이 4, 6, 8인 그룹에 대해서만 변수 hwy의 분포를 비교해 보자. mpg_1 &lt;- mpg %&gt;% filter(cyl != 5) 먼저 facet 그래프를 작성해 보자. 그룹별 분포를 수월하게 비교할 수 있다. ggplot(mpg_1, aes(hwy)) + geom_histogram(binwidth = 5) + facet_wrap(vars(cyl), ncol = 1) 그림 9.45: 그룹 자료의 분포 비교를 위한 히스토그램 그룹별 히스토그램을 작성해서 하나의 그래프에 겹치게 나타내보자. 겹쳐진 히스토그램을 작성하기 위해서는 시각적 요소 fill에 요인을 매핑해야 한다. 또한 함수 geom_histogram()은 position = \"stack\"이 디폴트이기 때문에, 이 경우에는 position = \"identity\"로 변경해야 원하는 형태의 그래프를 작성할 수 있다. 히스토그램을 겹쳐 그리는 경우에는 투명도를 높이는 것이 분포 비교에 큰 도움이 되지 않음을 알 수 있다. ggplot(mpg_1, aes(x = hwy, fill = factor(cyl))) + geom_histogram(binwidth = 5, alpha = 0.4, position = &quot;identity&quot;) + labs(fill = &quot;cyl&quot;) 그림 9.46: 그룹 자료의 분포 비교를 위한 히스토그램 \\(\\bullet\\) 도수분포다각형에 의한 그룹 자료의 분포 비교 패키지 ggplot2의 데이터 프레임 mpg의 변수 cyl에 따른 hwy의 분포를 비교해 보자. 변수 cyl이 5인 자료를 제외한 mpg_1을 사용하자. 함수 geom_freqpoly()에서 시각적 요소 color에는 요인을 매핑해야 겹쳐진 도수분포다각형이 작성된다. 각 그룹에 속한 자료의 개수가 다르게 때문에 빈도수에 의한 도수분포다각형으로는 그룹 간의 분포 비교가 부정확할 수 있다. 효과적인 비교를 하기 위해서는 상대도수를 사용하는 것이 더 바람직한 경우이다. library(patchwork) p1 &lt;- ggplot(mpg_1, aes(x = hwy, color = factor(cyl))) + geom_freqpoly(binwidth=5, show.legend = FALSE, size = 1) p2 &lt;- ggplot(mpg_1, aes(x = hwy, y = after_stat(density), color = factor(cyl))) + geom_freqpoly(binwidth=5, size = 1) + labs(color = &quot;cyl&quot;) p1 +p2 그림 9.47: 변수 cyl에 따른 hwy의 도수분포다각형 히스토그램과 도수분포다각형은 작성 과정에서 많은 부분을 공유하고 있는 그래프이며, 일변량 자료의 분포를 나타낼 때에는 모두 유용하게 사용되고 있다. \\(\\bullet\\) 나란히 서 있는 상자그림에 의한 그룹 자료의 분포 비교 상자그림의 경우에는 facet을 이용하는 것보다 그룹별로 작성된 상자그림을 옆으로 나란히 세워 놓는 것이 더 효과적으로 분포를 비교하는 방법이 될 것이다. 자료의 형태는 비교 대상이 되는 변수가 각기 독립된 벡터에 입력되어 있는 경우와 하나의 연속형 벡터와 그룹을 구분하는 하나의 요인으로 입력되어 있는 경우로 구분할 수 있다. 먼저 비교할 대상이 되는 변수들이 x1, x2, x3와 같이 개별적으로 구성된 경우를 살펴보자. 이런 경우 패키지 ggplot2에서는 자료를 데이터 프레임으로 구성하되, 개별적으로 구성된 벡터들을 하나의 연속형 벡터와 하나의 요인으로 나타내야 한다. 예제로 정규분포, t-분포, 균등분포에서 각각 발생시킨 난수의 분포를 나란히 서 있는 상자그림으로 비교해 보자. set.seed(124) x1 &lt;- rnorm(100) x2 &lt;- rt(100, df = 3) x3 &lt;- runif(100, min = -1, max = 1) tibble(x = c(rep(1:3, each = 100)), y = c(x1, x2, x3)) %&gt;% ggplot(aes(factor(x), y)) + geom_boxplot() + scale_x_discrete(labels = c(&quot;N(0,1)&quot;, &quot;t(3)&quot;, &quot;Unif(-1,1)&quot;)) + theme(axis.text.x = element_text(size = 15, face = &quot;bold&quot;)) + labs(x = NULL, y = NULL) 그림 9.48: 나란히 서 있는 상자그림 두 번째 경우로 하나의 연속형 변수가 하나 또는 그 이상의 요인에 의하여 몇 개의 그룹으로 구분되는 경우를 살펴보자. 이런 경우 함수 geom_boxplot()에 시각적 요소 x에는 요인을, y에는 연속형 변수를 매핑하면 수직방향의 나란히 서 있는 상자그림이 작성되고, y에 요인을 x에 연속형 변수를 매핑하면 수평방향의 나란히 서 있는 상자그림이 작성된다. 예제로 패키지 ggplot2의 데이터 프레임 mpg의 변수 cyl에 따른 hwy의 분포를 비교해 보자. 변수 cyl이 5인 자료를 제외한 mpg_1을 사용하자. mpg_1 &lt;- mpg %&gt;% filter(cyl!=5) ggplot(mpg_1, aes(x = factor(cyl), y = hwy)) + geom_boxplot() + labs(x = &quot;Number of Cylinders&quot;, y = &quot;MPG&quot;) 그림 9.49: 수직방향의 나란히 서 있는 상자그림 ggplot(mpg_1, aes(y = factor(cyl), x = hwy)) + geom_boxplot() + labs(y = &quot;Number of Cylinders&quot;, x = &quot;MPG&quot;) 그림 9.50: 수평방향의 나란히 서 있는 상자그림 그림 9.49의 상자그림에 점으로 표시된 이상값에 해당되는 자동차를 알아보자. 9.3.2절에서 살펴본 방법을 그대로 적용해 보자. pp &lt;- ggplot(mpg_1, aes(x = factor(cyl), y = hwy)) + geom_boxplot() pp_out &lt;- ggplot_build(pp)[[1]][[1]]$outliers pp_out ## [[1]] ## [1] 44 44 41 ## ## [[2]] ## numeric(0) ## ## [[3]] ## [1] 26 26 25 24 25 세 개의 상자그림 중 첫 번째는 3개의 이상값이 있고, 두 번째는 없으며, 세 번째에는 5개의 이상값이 있음을 알 수 있다. 함수 filter()를 사용해서 해당 자동차를 선택한 결과는 다음과 같다. mpg %&gt;% filter((cyl == 4 &amp; hwy %in% pp_out[[1]]) | (cyl == 8 &amp; hwy %in% pp_out[[3]])) %&gt;% arrange(desc(hwy)) %&gt;% select(1:2, cyl, hwy) ## # A tibble: 8 × 4 ## manufacturer model cyl hwy ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 volkswagen jetta 4 44 ## 2 volkswagen new beetle 4 44 ## 3 volkswagen new beetle 4 41 ## 4 chevrolet corvette 8 26 ## 5 chevrolet corvette 8 26 ## 6 chevrolet corvette 8 25 ## 7 pontiac grand prix 8 25 ## 8 chevrolet corvette 8 24 변수 cyl의 경우에는 실린더의 개수를 나타내는 4, 6, 8이라는 값이 나름의 순서가 있는 것이어서 그 순서대로 상자그림을 배치하는 것이 두 변수의 관계를 이해하는 데 도움이 된다. 그룹변수의 값들이 순서형 요인과 같이 자체적으로 순서가 있는 경우에는 그 순서대로 상자그림을 배치해도 괜찮겠지만, 명목형 요인과 같이 순서에 의미가 없는 경우에는 분석에 도움이 되도록 상자그림을 재배치하는 것이 더 좋을 것이다. 상자그림들을 재배치하려면 함수 reorder()를 사용하여 그룹변수로 사용되는 요인의 수준을 재정렬하면 된다. 먼저 데이터 프레임 mpg의 변수 hwy의 상자그림을 변수 class의 수준별로 작성해 보자. mpg %&gt;% ggplot(aes(x = class, y = hwy)) + geom_boxplot() 그림 9.51: 상자그림의 배치 순서 상자그림이 변수 class의 알파벳 순서로 배치되어 있다. 이것을 변수 class의 각 그룹별 변수 hwy의 중앙값을 기준으로 재배치하면, 변수 class별로 hwy의 분포를 한 눈에 파악할 수 있게 된다. 함수 reorder()를 사용하여 요인 class의 수준을 변수 hwy의 중앙값을 기준으로 다시 배치하는 방법은 reorder(class, hwy, FUN = median)이 된다. mpg %&gt;% ggplot(aes(x = reorder(class, hwy, FUN = median), y = hwy)) + geom_boxplot() + xlab(&quot;class&quot;) 그림 9.52: 상자그림의 배치 순서 조정 \\(\\bullet\\) 나란히 서 있는 violin plot에 의한 그룹 자료의 분포 비교 상자그림과 확률밀도함수 그래프의 조합이라고 할 수 있는 violin plot으로 그룹 자료의 분포를 비교해 보자. 데이터 프레임 iris의 변수 Sepal.Length의 분포가 Species에 따라 어떤 차이가 있는지 살펴보자. 패키지 vioplot의 함수 vioplot()을 사용해서 작성해 보자. library(vioplot) vioplot(Sepal.Length ~ Species, data = iris, col = c(&quot;lightgreen&quot;, &quot;lightblue&quot;, &quot;pink&quot;)) 그림 9.53: violin plot에 의한 분포 비교 ggplot2의 함수 geom_violin()을 사용해서 작성한 결과는 다음과 같다. ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_violin(fill = &quot;skyblue&quot;) + geom_boxplot(width = 0.1) 그림 9.54: violin plot에 의한 분포 비교 \\(\\bullet\\) 다중 점그래프에 의한 그룹 자료의 분포 비교 다중 점그래프도 그룹 자료의 분포를 비교하는 데 적합한 그래프라고 할 수 있다. 예제로 패키지 ggplot2의 데이터 프레임 mpg의 변수 cyl에 따른 hwy의 분포를 비교해 보자. 변수 cyl이 5인 자료를 제외한 mpg_1을 사용하자. mpg_1 &lt;- mpg %&gt;% filter(cyl!=5) ggplot(mpg_1, aes(x = factor(cyl), y = hwy)) + geom_dotplot(binaxis = &quot;y&quot;, binwidth = 0.5, stackdir = &quot;center&quot;) + labs(x = &quot;Number of Cylinders&quot;, y = &quot;MPG&quot;) 그림 9.55: 다중 점그래프 수직방향으로 점그래프를 작성하는 것이므로 구간 설정은 Y축 변수를 대상으로 이루어져야 한다. 옵션 binaxis는 구간 설정 대상이 되는 축을 지정하는 것으로 디폴트는 \"x\"이다. 점을 쌓아 가는 방향을 결정하는 옵션은 stackdir이다. 가능한 값은 \"up\", \"down\", \"center\"와 \"centerwhole“이 있다. 다중 점그래프를 상자그림과 겹쳐서 작성하는 것도 의미가 있는 그래프가 된다. 이 경우에도 상자그림에 outlier.shape = NA를 포함시켜 이상값을 점으로 표시하지 않도록 해야 하며, 상자 내부에 색을 채우지 않도록 fill = NA를 지정할 필요가 있다. 또한 상자의 폭을 줄여 주는 것도 필요하다고 본다. ggplot(mpg_1, aes(x = factor(cyl), y = hwy)) + geom_dotplot(binaxis = &quot;y&quot;, binwidth = 0.5, stackdir = &quot;center&quot;) + geom_boxplot(width = 0.3, outlier.shape = NA, color = &quot;red&quot;, fill = NA, size = 0.6) + labs(x = &quot;Number of Cylinders&quot;, y = &quot;MPG&quot;) 그림 9.56: 다중 점그래프 \\(\\bullet\\) 확률밀도함수 그래프에 의한 그룹 자료의 분포 비교 분포의 특징을 가장 세밀하게 표현할 수 있는 그래프가 확률밀도함수 그래프이다. Facet을 이용하여 그룹별밀도함수를 비교하는 것도 의미가 있으며, 하나의 그래프에 겹치게 작성하는 것도 괜찮은 방법이 된다. 예제로 패키지 ggplot2의 데이터 프레임 mpg의 변수 cyl에 따른 hwy의 분포를 비교해 보자. 변수 cyl이 5인 자료를 제외한 mpg_1을 사용하자. ggplot(mpg_1, aes(hwy)) + geom_density() + facet_wrap(vars(cyl), ncol = 1) + xlim(5,50) + ylab(NULL) 그림 9.57: Facet에 의한 그룹별 확률밀도함수의 비교 하나의 그래프에 겹치게 작성하는 방법으로써 시각적 요소 fill을 사용하는 것과 시각적 요소 color를 사용하는 것을 생각해 볼 수 있다. 시각적 요소 fill을 사용하면, 확률밀도함수가 색으로 채워지기 때문에 서로 겹쳐져서 가려지는 부분이 있게 된다. 이 문제는 색의 투명도를 높이면 해결된다. ggplot(mpg_1, aes(x = hwy, fill = factor(cyl))) + geom_density(alpha = 0.2) + xlim(5,50) + labs(y = NULL, fill = &quot;cyl&quot;) 그림 9.58: 겹쳐 그린 확률밀도함수 그래프 시각적 요소 fill 대신 color를 사용하면 서로 다른 색의 선으로만 밀도함수가 그려지는 그래프가 작성된다. ggplot(mpg_1, aes(x = hwy, color = factor(cyl))) + geom_density(size = 1) + xlim(5,50) + labs(y = NULL, color = &quot;cyl&quot;) 그림 9.59: 겹쳐 그린 확률밀도함수 그래프 그룹별로 작성되는 여러 개의 확률밀도함수를 하나의 그래프에 나타내는 또 다른 방법으로서 추정된 여러 개의 확률밀도함수를 위로 쌓아 올린 그래프와 x 변수의 주어진 값에 대한 각 그룹의 조건부 확률밀도함수를 작성한 그래프가 있다. 먼저 추정된 확률밀도함수를 위로 쌓아 올린 그래프를 작성해 보자. 이 경우에는 각 그룹마다 추정된 확률밀도에 자료의 수를 곱한 값을 사용하여 위로 쌓아 올리는 것이 각 그룹의 확률분포의 형태를 유지하며 통합하는 방법이 된다. 시각적 요소 y에 변수 after_stat(count)를 연결하고, position에 \"stack\"을 지정하여 그래프를 작성해 보자. ggplot(mpg_1, aes(x = hwy, fill = factor(cyl))) + geom_density(aes(y = after_stat(count)), position = &quot;stack&quot;) + xlim(5, 50) + labs(y = NULL, fill = &quot;cyl&quot;) 그림 9.60: 쌓아 올린 확률밀도함수 그래프 쌓아 올린 확률밀도함수 그래프와는 조금 다른 시각에서 분포를 비교할 수 있는 그래프로서 조건부 확률밀도함수 그래프를 작성해 보자. 이 그래프는 position에 \"fill\"을 지정하면 작성된다. ggplot(mpg_1, aes(x = hwy, fill = factor(cyl))) + geom_density(aes(y = after_stat(count)), position=&quot;fill&quot;) + labs(y = NULL, fill = &quot;cyl&quot;) 그림 9.61: 조건부 확률밀도함수 그래프 \\(\\bullet\\) 평균 막대그래프와 error bar에 의한 그룹 자료의 분포 비교 여러 분포의 평균값을 비교할 때 단순히 숫자만을 보여주는 것보다는 그래프로 바꿔서 보여 주는 것이 훨씬 효과적으로 정보를 전달하는 방법이 될 것이다. 그런 면에서 막대그래프는 그룹별 자료의 평균을 비교하는 그래프로서 상당히 효과적으로 사용할 수 있다. Error bar는 분포의 변동을 그래프로 나타내는 기법이다. 따라서 그룹별 평균을 막대그래프로 나타내고, 그 위에 error bar로 분포의 변동 혹은 신뢰구간을 함께 표시해 준다면 많은 정보를 매우 효과적으로 전달할 수 있을 것이다. 예제로 패키지 ggplot2의 데이터 프레임 mpg의 변수 cyl에 따른 hwy의 평균값을 막대그래프로 나타내고, 그 위에 95% 신뢰구간을 error bar의 형태로 추가해 보자. 변수 cyl이 5인 자료는 분석에서 제외하기로 하자. 그래프 작성은 함수 geom_col()과 geom_errorbar()를 사용하는 방법과 함수 stat_summary()에 의한 방법이 있다. 먼저 함수 geom_col()과 geom_errorbar()를 사용해서 작성해 보자. 두 함수로 그래프를 작성하려면, 그룹별 평균 및 신뢰구간의 계산 결과를 데이터 프레임으로 갖고 있어야 한다. 신뢰구간 계산은 함수 ggplot2::mean_cl_normal()로 할 수 있는데, 이 함수는 정규분포 가정에서 모평균의 신뢰구간을 계산하는 Hmisc::smean.cl.normal()을 불러와서 작업한다. mpg %&gt;% filter(cyl != 5) %&gt;% group_by(cyl) %&gt;% summarise(mean_cl_normal(hwy)) ## # A tibble: 3 × 4 ## cyl y ymin ymax ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 28.8 27.8 29.8 ## 2 6 22.8 22.0 23.6 ## 3 8 17.6 16.9 18.4 위의 계산 결과로 생성된 변수 y에는 표본평균, ymin에는 신뢰구간 하한, ymax에는 신뢰구간 상한이 각각 입력되었다. 평균막대그래프는 변수 y를 함수 geom_col()에 Y축 변수로 매핑하면 작성되고, Error bar는 함수 geom_errorbar()에는 변수 y, ymin, ymax를 같은 이름의 시각적 요소에 매핑하면 작성된다. mpg %&gt;% filter(cyl != 5) %&gt;% group_by(cyl) %&gt;% summarise(mean_cl_normal(hwy)) %&gt;% ggplot(aes(x = factor(cyl), y = y)) + geom_col(fill = &quot;skyblue&quot;, width = 0.5) + geom_errorbar(aes(ymin = ymin, ymax = ymax), width = 0.2) + labs(x = &quot;cyl&quot;, y = NULL) 그림 9.62: 평균 막대 그래프와 error bar 이번에는 함수 stat_summary()를 사용해서 작성해 보자. 막대그래프는 fun에 \"mean\"을, geom에 \"bar\" 각각 지정하면 작성되고, error bar는 fun.data에 \"mean_cl_normal\"을, geom에 \"errorbar\"를 각각 지정하면 된다. fun.data에 지정되는 함수는 반드시 y, ymin, ymax를 계산 결과로 출력하는 함수를 지정해야 한다. mpg %&gt;% filter(cyl != 5) %&gt;% ggplot(aes(x = factor(cyl), y = hwy)) + stat_summary(fun = &quot;mean&quot;, geom = &quot;bar&quot;, fill = &quot;steelblue&quot;, width = 0.5) + stat_summary(fun.data = &quot;mean_cl_normal&quot;, geom = &quot;errorbar&quot;, width = 0.2, color = &quot;red&quot;, size = 1) + labs(x = &quot;cyl&quot;, y = NULL) 그림 9.63: 평균 막대 그래프와 error bar 9.4.2 연속형 변수의 관계 탐색을 위한 그래프 두 연속형 변수의 관계를 탐색할 때 가장 많이 사용되는 그래프는 산점도일 것이다. 산점도를 확인해 보면 두 변수의 관계를 시각적으로 파악할 수 있는데, 산점도에 두 변수의 회귀직선이나 비모수 회귀곡선 등을 추가하면 관계 파악에 더 도움이 된다. 대규모 자료의 산점도를 작성하면 점들이 서로 겹쳐서 관계 탐색이 어려울 때가 있다. 이런 경우 대안으로 X축 자료를 구간으로 구분하여 Y축 자료의 상자그림을 작성할 수 있다. 두 변수의 결합확률밀도함수를 추정하는 것도 두 변수 관계 파악에 유용하게 사용될 수 있다. 산점도행렬은 많은 연속형 변수들의 관계를 파악하는 데 도움이 많이 되는 그래프이다. 1) 다양한 유형의 산점도 작성 \\(\\bullet\\) 기본적인 형태의 산점도 산점도 작성의 예제 자료로 패키지 MASS의 데이터 프레임 Cars93을 사용해 보자. 먼저 변수 Weight와 MPG.highway의 산점도를 작성해 보자. data(Cars93, package=&quot;MASS&quot;) ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point() 그림 9.64: 기본적인 형태의 산점도 가장 기본적인 형태의 산점도에 어렵지 않게 변화를 줄 수 있다. 점의 모양(shape = 21)을 내부와 외곽선의 색을 다르게 줄 수 있는 형태로 바꾸고, 크기도 늘리고(size = 3), 점의 내부 색은 파란색(fill = \"blue\"), 점의 외곽선 색은 빨간색(color = \"red\"), 그리고 점의 외곽선 두께를 늘려서(stroke = 1.5) 산점도를 작성해 보자. 이 경우 시각적 요소 shape, size, fill, color 등에 특정 변수를 매핑하는 것이 아니고 사용자가 값을 지정하는 것이므로 함수 aes() 밖에서 시각적 요소에 값을 지정해야 한다. ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point(shape = 21, color = &quot;red&quot;, fill = &quot;blue&quot;, stroke = 1.5, size = 3) 그림 9.65: 기본적인 형태의 산점도 \\(\\bullet\\) 시각적 요소에 세 번째 변수 매핑 산점도는 두 변수 사이의 관계를 나타내는 그래프이지만, 세 변수 사이의 관계를 나타내는 것도 가능하다. 방법은 두 변수는 시각적 요소 x와 y에 매핑을 하고, 세 번째 변수는 점의 색이나 모양, 크기 등에 매핑을 하는 것이다. 시각적 요소인 점의 색(color)이나 모양(shape), 크기(size) 등을 함수 aes() 안에서 변수와 연결을 하면, 변수에 따라 점의 색이나 모양, 크기 등이 구분되어 산점도가 작성되기 때문에, 세 번째 변수가 두 변수의 관계에 미치는 영향력을 파악할 수 있다. 이 경우 color, shape, size와 같은 시각적 요소에 매핑을 할 변수가 요인인 경우와 숫자형 변수인 경우의 차이점을 살펴보는 것도 중요하다. 변수 Weight와 MPG.highway의 산점도를 작성하되 요인 Origin과 숫자형 변수 EngineSize를 color, shape, size에 각각 매핑한 그래프를 작성해 보자. 먼저 color는 요인과 숫자형 변수 모두 매핑이 가능한 시각적 요소임을 알 수 있다. 하지만 숫자형 변수의 매핑에 사용되는 디풀트 색은 좋은 선택이 아닌 것으로 보이며, 구분이 더 잘 되는 색을 사용할 필요가 있는 것으로 보인다. library(patchwork) p1 &lt;- ggplot(Cars93, aes(x = Weight, y = MPG.highway, color = Origin)) + geom_point() p2 &lt;- ggplot(Cars93, aes(x = Weight, y = MPG.highway, color = EngineSize)) + geom_point() p1 + p2 그림 9.66: color에 요인과 숫자형 변수를 각각 매핑한 산점도 이번에는 시각적 요소 shape에 요인과 숫자형 변수를 매핑해 보자. ggplot(Cars93, aes(x = Weight, y = MPG.highway, shape = Origin)) + geom_point() 그림 9.67: shape에 요인을 매핑한 산점도 shape에는 숫자형 변수를 매핑할 수 없다는 것을 알 수 있다. ggplot(Cars93, aes(x = Weight, y = MPG.highway, shape = EngineSize)) + geom_point() ## Error in `geom_point()`: ## ! Problem while computing aesthetics. ## ℹ Error occurred in the 1st layer. ## Caused by error in `scale_f()`: ## ! A continuous variable cannot be mapped to the shape aesthetic ## ℹ choose a different aesthetic or use `scale_shape_binned()` 이번에는 시각적 요소 size에 요인과 숫자형 변수를 매핑해 보자. size에 이산형 변수를 매핑하는 것은 잘못된 정보를 줄 가능성이 있기 때문에 좋은 선택은 아닌 것으로 보인다. 숫자형 변수의 경우에도 미세한 면적 차이를 구분하는 것이 어렵기 때문에 효과적인 정보를 전달하기 어려운 것으로 보인다. library(patchwork) p1 &lt;- ggplot(Cars93, aes(x = Weight, y = MPG.highway, size = Origin)) + geom_point() p2 &lt;- ggplot(Cars93, aes(x = Weight, y = MPG.highway, size = EngineSize)) + geom_point() p1 + p2 ## Warning: Using size for a discrete variable is not advised. 그림 9.68: size에 요인요인과 숫자형 변수를 각각 매핑한 산점도 \\(\\bullet\\) 산점도에 회귀직선 추가 산점도만으로 두 변수의 관계를 파악하는 것보다 회귀직선이나 비모수 회귀곡선 등을 추가하는 것이 훨씬 더 효과적일 수 있다. 회귀직선의 추가는 함수 geom_smooth()에 선형회귀모형을 의미하는 method = \"lm\"을 지정하면 된다. 추정된 회귀직선에 신뢰구간이 함께 표현되는 것이 디폴트인데, 회귀직선만 나타내려면 se = FALSE를 입력해야 한다. p &lt;- ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point() p1 &lt;- p + geom_smooth(method = &quot;lm&quot;) p2 &lt;- p + geom_smooth(method = &quot;lm&quot;, se = FALSE) p1 + p2 그림 9.69: 회귀직선을 산점도에 함께 표시 두 변수의 관계를 나타내는 회귀모형으로 가장 많이 사용되는 것이 loess(local regression)이라고 불리는 국소다항회귀모형이다. 비모수 회귀모형으로 분류되고 있으며, 자료의 개수가 너무 크지 않는 경우에 가장 무난하게 사용할 수 있는 분석 도구이다. 함수 geom_smooth()에서 디폴트로 적용되는 회귀모형이며, 신뢰구간을 포함하여 표시되는 것이 디폴트이다. p1 &lt;- p + geom_smooth() p2 &lt;- p + geom_smooth(se = FALSE) p1 + p2 그림 9.70: 국소회귀곡선을 산점도에 함께 표시 선형회귀모형은 두 변수 \\(X\\) 와 \\(Y\\) 의 관계를 \\(Y=\\beta_{0}+\\beta_{1}X+\\epsilon\\) 같이 미리 설정하고, 자료를 근거로 회귀함수의 계수 \\(\\beta_{0}\\) 와 \\(\\beta_{1}\\) 을 추정하여 \\(X\\) 변수의 전체 범위에서 두 변수의 관계를 수식으로 표현하는 방식이다. 회귀계수는 함수 lm()으로 추정된다. 이에 반하여 국소다항회귀모형은 두 변수의 관계를 미리 설정하지 않으면서 \\(X\\) 변수의 개별 값에 대하여 회귀함수의값을 각각 추정하는 방식이다. 개별 \\(X\\) 변수값에 대한 회귀함수의 추정은 가까운 자료만을 대상으로 가중 다항회귀모형을 적합함으로써 이루어지며, 함수 loess()로 추정된다 이번에는 선형회귀직선과 국소회귀곡선을 산점도에 함께 나타내 보자. 두 종류의 선을 다른 색으로 표시하고 범례를 추가해야 하는데, 그래프에 범례(legend)를 추가하는 방법은 5.4절에서 살펴보았다. 시각적 요소 color에 범례의 라벨로 사용할 문자열을 매핑해 보자. ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point() + geom_smooth(aes(color = &quot;lm&quot;), method = &quot;lm&quot;, se = FALSE) + geom_smooth(aes(color = &quot;loess&quot;), se = FALSE) + labs(color = &quot;Method&quot;) 그림 9.71: 선형회귀직선과 국소회귀곡선을 산점도에 함께 표시 \\(\\bullet\\) 산점도에 수평선, 수직선 추가 산점도에는 회귀직선뿐만 아니라 수평선과 수직선도 추가할 수 있다. 수평선의 추가와 수직선의 추가는 각각 함수 geom_hline(yintercept)와 함수 geom_vline(xintercept)으로 할 수 있으며, 직선의 추가는 함수 geom_abline(slope, intercept)으로 할 수 있다. 변수 Weight와 MPG.highway의 산점도에 두 변수의 선형회귀직선을 추가하고, 두 변수의 평균값에 해당하는 위치에 수직선과 수평선을 각각 추가해 보자. ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_vline(aes(xintercept = mean(Weight)), color = &quot;red&quot;) + geom_hline(aes(yintercept = mean(MPG.highway)), color = &quot;darkgreen&quot; ) 그림 9.72: 산점도에 수직선과 수평선 추가 \\(\\bullet\\) 산점도에 그룹별 회귀직선 추가 산점도의 점이 그룹변수의 값에 따라 색이나 모양이 구분되어 있는 경우, 각 그룹별 자료만을 대상으로 추정된 회귀직선을 추가해 보자. 변수 Weight와 MPG.highway의 산점도를 요인 Origin에 따라 점의 색을 구분하고, 각 그룹별 회귀직선을 추정하여 추가해 보자. ggplot(Cars93, aes(x = Weight, y = MPG.highway, color = Origin)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) 그림 9.73: 그룹별 회귀직선의 추가 \\(\\bullet\\) 산점도의 점에 라벨 추가 산점도에서 특정 조건을 만족하는 점에 라벨을 붙이게 되면 자료의 특성을 파악하는 데 중요한 그래프가 될 수 있다. 산점도의 점에 라벨을 붙이는 작업은 5.4절에서 살펴보았듯이 함수 geom_text()로 할 수 있는데, 시각적 요소 label에 라벨의 내용이 되는 문자형 변수를 매핑하면 된다. 변수 Weight와 MPG.highway의 산점도에서 변수 MPG.highway가 40을 초과하는 점에 라벨을 붙여 보자. 라벨의 내용은 변수 Manufacturer와 Model의 값을 결합한 것으로 하자. p &lt;- ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point() p + geom_text(data = filter(Cars93, MPG.highway &gt; 40), aes(label = paste(Manufacturer, Model))) 그림 9.74: 산점도의 점에 라벨 추가 추가한 라벨이 점과 겹쳐 있으며, 가장 위에 있는 점의 라벨은 첫 글자가 가려져 있는 것을 볼 수 있다. 라벨의 위치를 조정하는 작업은 vjust와 hjust, nudge_x와 nudge_y로 할 수 있다. 세밀한 조정이 필요한 경우에는 nudge_x와 nudge_y가 더 좋은 방법이 될 수 있다. p + geom_text(data = filter(Cars93, MPG.highway &gt; 40), aes(label = paste(Manufacturer, Model)), nudge_y = 1, nudge_x = 100) 그림 9.75: 산점도의 점에 라벨 추가 및 위치 조정 위의 예제는 geom 함수마다 서로 다른 데이터 프레임을 사용할 수 있음을 보여주고 있다. 함수 geom_point()에서는 자료를 모두 사용하여 산점도를 작성했지만, 함수 geom_text()에서는 함수 filter()로 축소된 데이터 프레임을 사용하여 라벨을 붙이는 작업을 진행했다. \\(\\bullet\\) 산점도에 주석 추가 산점도의 점에 대한 라벨이 아닌 그래프 자체에 주석을 추가하는 것도 함수 geom_text()로 할 수 있다. 만일 R의 수학기호 표현식을 사용하여 주석을 달고 싶다면 옵션 parse = TRUE를 추가해야 한다. 변수 Weight와 MPG.highway의 산점도에 회귀직선을 그리고, 결정계수를 주석으로 추가해 보자. 결정계수는 함수 lm()으로 생성된 객체를 다시 함수 summary()에 입력하여 생성된 객체 중 이름이 r.squared인 객체에 입력되어 있다. 반올림한 결과가 객체 r2에 입력되었다. fit &lt;- lm(MPG.highway ~ Weight, Cars93) |&gt; summary() r2 &lt;- fit$r.squared |&gt; round(2) 그래프 작성 및 주석의 추가는 다음과 같이 할 수 있다. ggplot(Cars93, aes(x = Weight, y = MPG.highway)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_text(x = 3500, y = 45, size = 7, label = paste(&quot;R^2==&quot;, r2), parse = TRUE) 그림 9.76: 산점도에 수학기호 주석 추가 2) 산점도에서 점이 겹쳐지는 문제 산점도의 점들이 서로 겹쳐지면 자료의 분포나 관계 등을 확인하는 것이 어렵게 된다. 대규모의 자료를 대상으로 산점도를 작성하는 경우 종종 일어나는 현상이며, 두 변수 중 한 변수가 이산형인 경우에도 흔히 볼 수 있는 현상이다. 원자료를 반올림하여 정수로 만들었다면 이산형 자료가 아니어도 겹치는 현상이 발생할 수 있다. 점이 겹쳐지는 문제의 해결 방안은 상황에 따라 달라질 수 밖에 없으며, 마땅한 해결 방안이 없는 상황도 있을 수 있다. 데이터 프레임 ChickWeight는 578마리의 병아리를 대상으로 측정한 몸무게(weight)와 몸무게 측정이 생후 며칠에 이루어졌는지(Time)를 조사한 자료이다. 두 변수의 산점도를 작성해 보자. ChickWeight %&gt;% ggplot(aes(x = Time, y = weight)) + geom_point() 그림 9.77: 산점도의 점 겹치는 문제 변수 Time은 12개의 값만을 갖고 있는 변수이기 때문에 많은 점들이 겹치게 될 수밖에 없다. 이런 경우에는 함수 geom_jitter()을 사용하여 점을 약간 흩트리면 점이 겹치는 정도를 약간 완화할 수 있다. 다른 방법으로 변수 Time이 이산형 변수의 특성을 지니고 있기 때문에 나란히 서 있는 상자그림을 산점도 대신 작성하는 것도 두 변수의 관계 탐색에 도움이 될 수 있다. 함수 geom_boxplot()으로 그룹별 상자그림을 작성할 때 그룹 변수는 반드시 요인 또는 문자형 변수가 되어야 한다. 따라서 숫자형 변수인 Time을 요인으로 전환하여 그룹변수로 매핑하였다. p1 &lt;- ChickWeight %&gt;% ggplot(aes(x = Time, y = weight)) + geom_jitter(width = 0.2, height = 0) p2 &lt;- ChickWeight %&gt;% ggplot(aes(x = as.factor(Time), y = weight)) + geom_boxplot() + xlab(&quot;Time&quot;) p1 + p2 그림 9.78: 산점도 점 겹치는 문제 해결 방안: 점 흩트리기 이번에는 대규모 자료를 대상으로 작성된 산점도에서 발생하는 점이 겹쳐지는 현상을 살펴보자. 패키지 ggplot2의 데이터 프레임 diamonds는 53,940개 다이아몬드를 대상으로 가격(price), 무게(carat), 컷의 등급(cut), 색상(color), 투명도(clarity) 등을 조사한 자료이다. 변수 carat과 price의 산점도를 작성해 보자. ggplot(diamonds, aes(x = carat, y = price)) + geom_point() 그림 9.79: 대규모 자료의 산점도에서 점 겹치는 문제 점들이 너무 심하게 겹쳐져서 자료의 분포를 알아보기 어려운 상황이다. 변수 carat이 3을 초과하는 자료가 많지 않으므로, carat &lt; 3인 자료만을 대상으로 산점도를 작성해 보자. p2 &lt;- filter(diamonds, carat &lt; 3) %&gt;% ggplot(aes(x = carat, y = price)) p2 + geom_point() 그림 9.80: 대규모 자료의 산점도에서 점 겹치는 문제 대규모 자료를 대상으로 작성된 산점도에서 흔히 발생할 수 있는 문제라고 할 수 있다. 자료의 분포를 확인할 수 있는 첫 번째 방법으로 점의 크기를 줄이고 투명도를 높이는 것을 생각해 볼 수 있다. 함수 geom_point()에서 점 모양은 shape = 16이 디폴트인데, shape = 20을 사용하면 점의 크기가 조금 줄어든다. alpha를 0에 가까운 값을 지정하면 투명도를 높일 수 있다. p2 + geom_point(alpha = 0.1, shape = 20) 그림 9.81: 대규모 자료의 산점도에서 점 겹치는 문제 해결 방안: 점의 크기 줄이고 투명도 높이기 점의 크기를 줄이고 투명도를 높이는 것으로는 문제가 해결되지 않는 것으로 보인다. 다만, 특정 carat의 값에서 점들이 수직의 띠를 형성하는 것이 보인다. 이것은 carat의 값이 같더라도 price에는 큰 차이가 있다는 것이며, 따라서 price의 변동을 설명하기 위해서는 다른 변수가 더 있어야 한다는 것을 보이는 것이다. 두 번째 방법으로는 함수 geom_bin2d()로 2차원 히스토그램을 작성하는 것이다. 이것은 XY축으로 형성된 2차원 공간을 직사각형의 영역(2D bin)으로 나누고, 각 영역에 속한 자료의 개수를 색으로 나타내는 그래프를 작성하는 것이다. 히스토그램을 2차원으로 확장한 그래프라고 할 수 있다. X축과 Y축을 30개의 구간으로 나누어 전체 공간을 900개의 직사각형으로 나누는 것이 디폴트이다. p2 + geom_bin2d() 그림 9.82: 대규모 자료의 산점도에서 점 겹치는 문제 해결 방안: 2차원 히스토그램 빈도수를 나타내는 색깔에 큰 변화가 없어서 구분이 잘 안 되고 있고, 구간의 개수를 더 늘릴 필요가 있는 것으로 보인다. 디폴트 구간 개수인 30개를 원하는 개수로 조정하는 옵션은 bins이다. 색깔의 조정은 함수 scale_fill_gradient()에서 원하는 색깔을 low와 high에 각각 지정하면 된다. 대부분의 다이아몬드가 작고 가격이 상대적으로 싼 편이라는 것을 알 수 있다. p2 + geom_bin2d(bins = 100) + scale_fill_gradient(low = &quot;skyblue&quot;, high = &quot;red&quot;) 그림 9.83: 대규모 자료의 산점도에서 점 겹치는 문제 해결 방안: 2차원 히스토그램 세 번째 방법은 X축 변수인 carat이 이산형 변수가 아니지만, 이것을 구간으로 구분하여 나란히 서 있는 상자그림을 작성하는 것이다. 숫자형 변수를 구간으로 구분하는 데 유용한 함수가 cut_width()와 cut_number(), cut_interval()이다. 구간의 간격을 동일하게 한다면 cut_width(x,width, boundary)를 사용하면 된다. 옵션 boundary는 구간의 시작점을 지정할 때 사용한다. 반면에 자료를 n개 구간으로 구분하되, 각 구간에 속한 자료의 개수를 동일하게 한다면 cut_number(x, n)을 사용하면 되고, 간격이 length인 n개 그룹으로 구분한다면 cut_interval(x, n, length)를 사용하면 된다. 이 함수들을 실행시키면 각 구간을 수준으로 갖는 요인이 생성된다. 변수 carat을 0을 시작점으로 0.1의 간격을 갖는 구간으로 구분하고, 각 구간의 자료들을 대상으로 상자그림을 작성해 보자. 또한 변수 carat을 20개 구간으로 구분하되 각 구간에 속한 자료의 개수를 가능한 동일하도록 하고 상자그림을 작성해 보자. bp1 &lt;- p2 + geom_boxplot(aes(group = cut_width(carat, width = 0.1, boundary = 0))) bp2 &lt;- p2 + geom_boxplot(aes(group = cut_number(carat, n = 20))) bp1 + bp2 그림 9.84: 대규모 자료의 산점도에서 점 겹치는 문제 해결 방안: 그룹별 상자그림 3) 이차원 결합확률밀도 그래프 두 연속형 변수의 관계를 탐색할 때 두 변수의 결합확률밀도를 추정한 그래프가 큰 역할을 할 수 있다. 데이터 프레임 faithful의 두 변수 eruptions와 waiting의 결합확률밀도를 추정하여 그래프로 작성해 보자. 기본적인 그래프는 함수 geom_density_2d()로 작성할 수 있는데, 등고선 그래프가 작성된다. p3 &lt;- ggplot(faithful, aes(x = eruptions, y = waiting)) + xlim(1, 6) + ylim(35, 100) p3 + geom_density2d() 그림 9.85: 결합확률밀도 등고선 그래프 등고선 그래프는 3차원 자료를 2차원 공간에 표시한 것으로 확률밀도가 같은 영역을 선으로 연결하여 그린 그래프다. 각 등고선에 적절한 라벨이 붙어 있어야 확률밀도가 높은 지역과 낮은 지역을 구분할 수 있지만, 라벨을 일일이 확인하여 높이를 구분하는 작업은 매우 번거롭고 부정확할 수밖에 없다. 대안으로 제시되는 방법은 등고선의 높이를 색으로 구분하는 것이다. 시각적 요소 color를 함수 stat_density_2d()에서 계산된 변수 after_stat(level)에 매핑하여 선의 색깔을 구분시켜 보자. 함수 scale_color_gradient()를 사용하여 색깔의 변화를 조정하였다. 두 변수의 산점도를 함께 작성하는 것도 좋을 것이다. bp1 &lt;- p3 + geom_density_2d(aes(color = after_stat(level))) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) bp2 &lt;- bp1 + geom_point(shape = 20) bp1 + bp2 그림 9.86: 결합확률밀도 등고선 그래프 등고선만을 색으로 구분하는 것보다는 높이가 같은 영역을 구분된 색으로 채우는 것이 더 효율적인 그래프가 될 것이다. 작성 방법은 함수 stat_density_2d()를 사용하여 geom에 \"polygon\"을 지정하고, 시각적 요소 fill에 after_stat(level)을 매핑하는 것이다. p3 + stat_density_2d(aes(fill = after_stat(level)), geom = &quot;polygon&quot;) 그림 9.87: 색을 이용한 결합확률밀도 그래프 등고선내부 영역만을 색으로 채우기보다 그래프 전체 영역을 타일로 구분하고, 확률밀도의 높이에 따라 타일의 색을 다르게 하는 것이 훨씬 안정적인 느낌의 그래프를 작성하는 방법이 된다. 직사각형의 타일을 만드는 작업은 함수 geom_tile() 또는 geom_raster()를 사용해야 하는데, 두 변수에 대한 반응표면을 작성하는 경우에는 함수 geom_raster()를 사용하는 것이 좋다. 두 변수의 결합확률밀도 그래프도 일종의 반응표면을 작성하는 것이므로 geom_raster()를 사용해 보자. 타일의 색을 구분하기 위한 결합확률밀도의 추정 결과는 함수 stat_density_2d()에서 after_stat(density)에 입력되어 있으며, 이것을 시각적 요소 fill에 매핑하면 된다. 이때 옵션 contour은 반드시 FALSE로 지정해야 한다. p3 + stat_density_2d(aes(fill = after_stat(density)),geom = &quot;raster&quot;, contour = FALSE) + scale_fill_gradient(low = &quot;skyblue&quot;, high = &quot;red&quot;) ## Warning: Removed 396 rows containing missing values (`geom_raster()`). 그림 9.88: 색을 이용한 결합확률밀도 그래프 패키지 ggplot2에는 데이터 프레임 faithful의 두 변수인 eruptions와 waiting의 결합확률밀도 추정 결과가 변수(density)로 포함된 데이터 프레임 faithfuld가 있다. 변수 density에 할당된 결합확률밀도의 추정은 XY축에 75개의 격자점을 각각 구성하여 형성된 75×75=5625의 점에서 이루어졌다. 이와 같이 결합확률밀도의 높이가 데이터 프레임의 변수로 주어진 경우에는 함수 geom_raster()로 간단하게 그래프를 작성할 수 있다. 다만 이 경우에는 옵션 interpolate에 TRUE를 지정하는 것이 훨씬 안정적인 그래프를 작성하는 방법이다. ggplot(faithfuld, aes(x = eruptions, y = waiting)) + geom_raster(aes(fill = density), interpolate = TRUE) + scale_fill_gradient(low = &quot;skyblue&quot;, high = &quot;red&quot;) 그림 9.89: 결합확률밀도 그래프 4) 산점도행렬(scatter plot matrix) 산점도행렬은 여러 변수로 이루어진 자료에서 두 변수끼리 짝을 지어 작성된 산점도를 행렬의 행태로 배열하여 하나의 그래프로 함께 나타낸 그래프이다. 복잡하고 어려운 문제를 간단하고 명확하게 해결할 수 있도록 도와주는 뛰어난 그래프라고 할 수 있다. 패키지 ggplot2에는 산점도행렬을 작성하는 함수가 없지만, 패키지 GGally의 함수 ggpairs()로 작성할 수 있다. 패키지 GGally는 ggplot2의 확장이라고 할 수 있는데, 산점도행렬, 평행좌표 그래프, 생존 그래프와 네트워크를 나타내는 그래프, 모형 검진을 위한 그래프 등등 유용한 그래프를 작성할 수 있다. 예제로 데이터 프레임 mtcars에서 변수 mpg, wt, disp, cyl, am의 산점도행렬을 작성해 보자. 함수 ggpairs()에는 산점도행렬 작성에 사용될 변수만으로 이루어진 데이터 프레임을 입력하는 것이 좋다. mtcars_1 &lt;- mtcars %&gt;% select(mpg, wt, disp, cyl, am) library(GGally) ggpairs(mtcars_1) 그림 9.90: 숫자형 변수에 대한 함수 ggpairs()의 산점도행렬 데이터 프레임 mtcars의 모든 변수는 숫자형 변수로 선언되어 있다. 변수 am과 cyl을 요인으로 전환시키고 다시 산점도행렬을 작성해 보자. mtcars_2 &lt;- mtcars_1 %&gt;% mutate(am = factor(am), cyl = factor(cyl)) ggpairs(mtcars_2) 그림 9.91: 숫자형 변수와 요인이 있는 자료에 대한 함수 ggpairs()의 산점도행렬 함수 ggpairs()로 작성된 산점도행렬은 단순히 두 변수의 산점도만을 작성하는 것이 아니라 변수의 유형에 따라 적절한 형태의 그래프를 각 패널에 작성한다. 변수의 유형은 두 변수가 모두 양적 변수 또는 질적 변수인 경우와 두 유형이 섞여 있는 경우로 구분된다. 또한 패널의 위치가 대각선인지, 혹은 대각선 위쪽인지, 혹은 대각선 아래쪽인지에 따라 다른 유형의 그래프가 작성되는 것이 디폴트이다. 각 패널에 작성되는 디폴트 그래프를 살펴보자. 대각선 패널의 경우, 양적변수는 확률밀도그래프가 작성되고 질적 변수는 막대그래프가 작성된다. 대각선 위쪽 패널의 경우, 두 변수가 모두 양적 변수이면 상관계수가 계산되고, 하나는 양적 변수, 다른 하나는 질적 변수이면 상자그림이 작성되며, 둘다 질적 변수이면 facet 막대그래프가 작성된다. 대각선 아래쪽 패널의 경우, 둘 다 양적 변수이면 산점도, 둘 다 질적 변수이면 facet 막대그래프, 섞여 있으면 facet 히스토그램이 각각 작성된다. 각 패널에 작성되는 그래프를 바꾸는 방법을 살펴보자. 대각선 위 아래 패널의 경우에는 upper 혹은 lower를 이용해야 한다. 두 옵션은 요소 continuous와 combo, discrete로 이루어진 리스트로써 원하는 그래프에 해당하는 키워드를 각 요소에 지정하면 된다. 양적 변수(continuous)에 사용할 수 있는 키워드는 \"points\", \"smooth\", \"smooth_loess\", \"density\",\"cor\", \"blank\"가 있고, 질적 변수(discrete)에 사용할 수 있는 키워드는 \"facetbar\", \"ratio\", \"blank\"가 있으며, 섞여 있는 경우(combo)에는 \"box\", \"box_no_facet\", \"dot\", \"dot_no_facet\", \"facethist\", \"facetdensity\", \"denstrip\", \"blank\"가 있다. 대각선 패널의 경우에는 옵션 diag에 continuous와 discrete로 이루어진 리스트에 원하는 그래프에 해당하는 키워드를 지정해야 한다. 사용 가능한 키워드로 continuous에는 \"densityDiag\", \"barDiag\", \"blankDiag\"가 있고, discrete에는 \"barDiag\", \"blankDiag\"가 있다. 각 그래프를 작성할 때 디폴트로 주어진 변수가 있다. 예를 들어 히스토그램을 작성할 때 구간은 bins = 30으로 설정되는 것이 디폴트이다. 이러한 디폴트 값을 변경하고자 한다면 함수 wrap()을 사용하여 필요한 변수 값을 지정하면 된다. 이제 mtcars_2를 대상으로 다음의 조건으로 수정된 형태의 산점도행렬을 작성하자. 대각선 아래쪽 패널의 continuous에는 \"smooth\"를 지정해서 회귀직선을 추가하되, se = FALSE를 추가해서 신뢰구간은 제거하고, combo의 경우에는 \"facethist\"를 지정해서 facet 히스토그램을 작성하되, bins = 10으로 구간의 개수를 10개로 지정하자. 대각선 위쪽 패널의 continuous에는 \"density\"를 지정해서 결합확률밀도그래프를 작성해 보자. 또한 모든 패널의 그래프를 요인 am에 의한 두 그룹으로 구분해서 작성하는데, 이것은 시각적 요소 color에 요인 am을 매핑하면 된다. ggpairs(mtcars_2, aes(color = am), upper = list(continuous = &quot;density&quot;), lower = list(continuous = wrap(&quot;smooth&quot;, se = FALSE), combo = wrap(&quot;facethist&quot;, bins = 10))) 그림 9.92: 숫자형 변수와 요인이 있는 자료에 대한 함수 ggpairs()의 산점도행렬 9.5 연습문제 "],["참고-문헌.html", "참고 문헌", " 참고 문헌 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

[["index.html", "R과 통계분석 소개하기", " R과 통계분석 박동련 2022-02-11 소개하기 "],["r-시작하기.html", "Chapter 1 R 시작하기 1.1 R의 소개 1.2 R의 설치 1.3 RStudio의 설치 및 R의 실행 1.4 작업공간 1.5 스크립트 파일의 활용 1.6 일괄처리 1.7 R의 확장: 패키지", " Chapter 1 R 시작하기 1.1 R의 소개 R은 다양한 통계분석과 그래프 작성 등을 위한 프로그래밍 언어이자 개발 환경이다. 뉴질 랜드 오클랜드 대학의 Ross Ihaka와 Robert Gentleman에 의해 개발된 오픈 소스 소프트 웨어로서 현재는 통계학 및 컴퓨터 분야 등의 쟁쟁한 학자들로 이루어진 R Development Core Team에 의하여 유지 관리되고 있으며 세계 곳곳의 다양한 R 사용자들의 활발한 활 동으로 꾸준히 발전되고 있다. 최근 들어 R은 기존 분석 시장의 강자였던 SAS를 능가하 며 분석시장의 판도를 이끌고 있다. 빅데이터 시대를 맞이하여 이미 구글과 같은 인터넷 기업에서 통계자료분석 엔진으로 R이 사용되고 있다는 사실 등은 우리에게 시사하는 바가 크다고 할 것이다. 그럼 무엇 때문에 R이 이와 같이 큰 주목을 받는 것일까? 그것은 다른 통계 소프트웨어들에서는 볼 수 없는 차별화된 장점이 있기 때문일 것이다. 우선 R은 무료로 사용할 수 있다. 이것은 대학뿐만이 아니라 일반 기업에서도 대단히 매력적인 측면이라 할 수 있다. 또한 다양한 형태의 데이터를 이용하여 거의 모든 분야의 통계분석이 가능한 매우 포괄적인 통계 소프트웨어이며, 기존의 어떤 통계 소프트웨어에서 도 볼 수 없었던 완벽한 그래프를 간편하게 작성할 수 있다. 더욱이 오픈 소스 소프트웨어 이기 때문에 수많은 R 사용자들이 활발하게 분석기법 등을 추가하고 있는데 이것은 다른 통계 소프트웨어에서는 사용할 수 없는 최첨단 분석기법들을 R에서는 사용할 수 있다는 것을 의미한다. 이외에도 다양한 장점을 지니고 있는 R은 앞으로 계속 발전할 것이며 통계 분석에 관한 기존의 패러다임을 바꾸어 놓을 것이다. R이 다른 통계 소프트웨어와 차별화되는 다양한 장점을 갖고 있는 것은 사실이나 몇 가 지 아쉬운 점이 있는 것 또한 사실이다. 오픈 소스 소프트웨어라는 것은 동전의 양면과 같 아서 누릴 수 있는 많은 장점들이 있는 동시에 감내해야 될 어려움 또한 존재하는데, R에 서 사용할 수 있는 대부분의 분석기법들이 여러 분야의 수많은 사용자들에 의해서 각각 작 성되어 올려진다는 것이 바로 그것이다. 다양한 분석기법이 있다는 것은 더할 나위 없이 좋은 점이나 현재 R에서 어떤 분석기법이 사용 가능하며 그 사용법이 무엇인지를 알아내 는 것이 상당히 번거로운 일이 된다. 이 문제에 대한 이해는 R 패키지에 대한 소개가 이루 어지면 명확하게 될 것이다. 이 책에서 우리는 R의 다양한 특징에 대하여 알아보고자 한다. 여러 형태의 데이터 입 력과 변환 방법, 다양한 분석기법, 그리고 뛰어난 그래프 작성방법 등을 살펴볼 것이다. R 은 Windows와 Linux 그리고 Mac OS X에서 설치가 가능한데 이 책에서는 Windows를 기반으로 하는 PC에서 운영하는 방법만을 다루고자 한다. 1.2 R의 설치 R은 크게 base 시스템과 패키지로 구분되며 R의 설치는 base 시스템의 설치를 의미한다. 설 치 파일은 Comprehensive R Archive Network(CRAN)에 방문하면 얻을 수 있다. 원활한 다운로드를 위해서는 미러(Mirror) 사이트 중 한 곳을 선택하여 방문하는 것이 좋다. 사이트에 설명된 방법에 따라 Windows용 설치파일을 다운로드하고 설치하면 기본적인 R 사용 준비는 끝나게 된다. R의 업데이트 주기는 매우 짧아서 일 년에도 여러 번 업데이트 버전이 출시된다. 이 책은 R version 4.1.2 (2021-11-01)을 기반으로 하여 작성되었고 따라서 더 최근 버전을 사용하는 경 우에는 책의 내용과 약간 다른 점들을 볼 수 있을 것이나 큰 문제는 없을 것으로 생각한다. 다양한 분석기법들을 사용하기 위해서는 해당되는 패키지를 설치해야 하는데 패키지의 설치도 CRAN 사이트에 방문하면 할 수 있다. 자세한 내용은 1.7에서 찾아볼 수 있다. 1.3 RStudio의 설치 및 R의 실행 모든 R 작업은 RStudio에서 진행하는 것이 바람직하다. RStudio는 R을 위한 통합 개발 환경으로서 프로그램의 작성과 실행, 디버깅, 그래프 작성 및 작업공간의 관리, 보고서 작 성 등 R과 관련된 모든 작업을 편리하게 수행할 수 있게 한다. R을 설치한 후에는 RStudio에 방문하여 오픈 소스 버 전의 설치파일을 다운로드 받아 RStudio를 설치한다. RStudio도 일년에 몇 차례 업데이트 버전이 출시되는데, 이 책에서는 버전 2021.09.0을 사용하고 있다. RStudio를 설치하고 바탕화 면에 생성된 아이콘을 더블 클릭하면 Figure 1.1과 같은 초기화면이 나타난다. Figure 1.1: RStudio의 초기화면 열린 세 개의 창 중 왼쪽에 있는 Console이라는 이름의 창을 보면, &gt; 기호가 나타나는 데 이것이 R의 프롬프트이다. 프롬프트 다음에 명령문을 입력하고 Enter 키를 치면 입력된 명령문이 실행되고 그 실행결과가 바로 다음 줄에 나오게 된다.즉 R은 기본적으로 대화형 처리방식(interactive mode)으로 작업을 수행한다. SAS 등에서 사용되는 일괄처리방식 (batch mode)에 익숙한 사용자들에게는 무척 생소하고 불편한 방식으로 느껴지겠지만 최근에 우리가 접하는 데이터가 대부분 매우 복잡한 구조를 갖고 있으며 이러한 데이터는 반 드시 여러 단계의 중간분석을 거쳐야 한다는 점을 고려할 때 매우 효율적인 작업방식이라 고 하겠다. 물론 동일한 작업이 계속 반복되는 경우라면 일괄처리방식이 훨씬 더 편리하다 고 할 수 있을 것이다. 따라서 두 가지 처리방식이 모두 가능하다면 상당히 융통성이 있는 작업수행을 할 수 있게 되는데, R에서는 이 두 가지 처리방식이 모두 가능하다. 일괄처리 방식에 대한 자세한 내용은 1.6절에서 찾아볼 수 있다. R의 작업환경을 이해하기 위해 간단한 예제 프로그램을 실행해 보자. Table 1.1의 데이터 세트는 자동차의 주행속도(speed)와 그 속도에서 차를 완전히 멈추는 데 필요한 거리 (dist)를 알아보는 실험 데이터의 일부분이다. 두 변수의 관계를 알아보자. Table 1.1: 예제 데이터 speed dist 4 2 7 4 8 16 9 10 10 18 11 17 12 24 13 34 13 26 14 26 R에서 사용되는 명령문이란 대부분 내장함수 혹은 사용자 정의 함수로 이루어지며 자료 의 입력이란 특정 객체에 데이터를 할당하는 것을 의미한다. 간단한 데이터의 입력은 함수 c()를 이용할 수 있는데, 할당은 &lt;- 기호 또는 = 기호로 이루어진다. 예를 들어 x라는 이름을 가진 벡터 객체에 숫자 10과 11을 할당하는 작업은 다음의 두 명령문 중 어느 하 나를 사용하면 된다. 이 책에서 &lt;- 기호를 할당 기호로 사용할 것이며, RStudio에서 할당 기호 &lt;-은 Alt 키와 마이너스(-) 키를 함께 치면 나타난다. &gt; x &lt;- c(10,11) &gt; x = c(10,11) Table 1.1에 주어진 데이터의 분석으로 우선 함수 c()를 이용하여 두 변수 speed와 dist를 각각 생성하고, 두 변수의 기술통계량을 함수 summary()와 mean(), sd()를 이용하여 각각 계산해 보자. 이어서 두 변수의 산점도를 함수 plot()으로 작성하고, 상관계수를 함수 cor()로 구해 보자. Figure 1.2는 RStudio에서 실행한 결과를 보여주고 있다. &gt; speed &lt;- c(4,7,8,9,10,11,12,13,13,14) &gt; dist &lt;- c(2,4,16,10,18,17,24,34,26,26) &gt; summary(speed) Min. 1st Qu. Median Mean 3rd Qu. Max. 4.00 8.25 10.50 10.10 12.75 14.00 &gt; mean(dist) [1] 17.7 &gt; sd(dist) [1] 10.22035 &gt; cor(speed, dist) [1] 0.9176971 &gt; plot(speed, dist) Figure 1.2에서 볼 수 있듯이 실행결과는 Console 창에 바로 나타난다. 작성된 그래프의 경우에는 Plots 창에 나타나며, 생성된 객체에 대한 정보는 Environment 창에 표시되는 것 을 알 수 있다. Figure 1.2: 예제 프로그램 실행 결과 R에서 프로그램을 실행하면서 주의할 점이 있는데, 우선 R에서는 영문자의 대문자와 소문자를 서로 다른 문자로 인식한다. &gt; mean(speed) [1] 10.1 &gt; Mean(speed) Error in Mean(speed): 함수 &quot;Mean&quot;를 찾을 수 없습니다 또한 명령문이 완성되지 않은 상태에서 Enter 키를 치면 프롬프트가 &gt; 기호에서 + 기호로 바뀐다. 이 연결 프롬프트는 명령문이 완성될 때까지 계속해서 나오는데, 만일 무엇이 문제인지 알 수 없는 경우에는 Esc 키로 명령문 실행을 취소시켜야 프롬프트가 &gt; 기호로 다시 바뀌게 된다. &gt; cor(dist, + speed) [1] 0.9176971 R에서는 # 기호 이후의 명령문은 무시되어 처리되지 않는다. 따라서 명령문에 대한 부가설명을 붙이고자 한다면 # 기호 후에 입력하면 된다. &gt; sd(dist) # standard deviation of dist [1] 10.22035 1.4 작업공간 작업공간이란 R의 실행 과정에서 생성되는 모든 객체 및 입력된 명령문 등이 보관되어 있는 공간을 의미하는 것으로 현재의 작업 디렉터리에 임시로 보관되어 있다. 현재의 작업 디렉터리는 함수 getwd()를 실행하면 알 수 있다. 작업공간에 임시 보관되어 있는 객체들은 Figure 1.2에서와 같이 Environment 창에서 상세하게 그 내용을 확인할 수 있다. Console 창에서도 함수 ls()를 실행시키면 임시 저장된 객체들의 목록을 얻을 수 있다. 앞서 실행시킨 명령문들은 Console 창에서 ↑ 또는 ↓의 화살표 키를 이용하여 확인하거나, History 창에서 확인할 수 있다. 디폴트로 지정된 작업 디렉터리는 사용자의 필요에 따라 바꿀 수 있는데, Console 창에서 함수 setwd()를 실행하거나, 메인 메뉴 Session &gt; Set Working Directory &gt; Choose Directory…을 선택하여 변경할 수 있다. 함수 setwd()를 이용하는 경우에는 작업 디렉터리로 사용할 폴더를 미리 생성한 후 그 폴더를 지정해야 하고, 메인 메뉴를 이용하는 경우에는 작업 도중에 폴더를 생성할 수 있다. 현재 작업 디렉터리에 임시로 보관되어 있는 객체들을 저장하면 .RData라는 이름의 파일로 저장된다. 저장 방법은 함수 save.image()를 실행하거나, R을 종료할 때 저장하는 방법이 있다. R의 종료는 함수 q()로 할 수 있는데 종료 직전에 현재 작업공간을 저장할 것인지를 묻게 된다. 실행시킨 명령문들은 .Rhistory라는 이름의 파일로 작업 디렉터리에 저장되는 것이 디폴트이다. 디폴트 작업 디렉터리에 저장된 작업공간은 R이 다시 시작되면 자동으로 올라오지만 변경된 작업 디렉터리에 저장된 작업공간은 함수 load()를 실행하거나 메인 메뉴 바에서 Session &gt; Load Workspace……를 이용하여 사용자 스스로 불러와야 한다. 여기서 주의해야 할 사항은 작업 디렉터리의 경로를 나타내는 데 사용되는 슬래시의 방향이 Windows에서와 다르다는 점이다. Windows에서의 올바른 경로 표시는 C:\\Users\\Park\\Documents이지만 R에서는 슬래시의 방향이 반대이다. 만일 Windows에서 사용되는 방향의 슬래시를 사용하고자 한다면, 두 개를 겹쳐서 C:\\\\Users\\\\Park\\\\Documents로 하면 된다. 지금까지 작업공간의 저장 및 디폴트 작업 디렉터리의 변경 방법에 대해서 살펴보았으나, 실제 분석 과정에서는 가급적 사용하지 않는 것이 좋을 것이다. 특히 세션마다 생성되는 객체를 저장하는 것은 차후 분석에 혼선을 줄 가능성이 있기 때문에 반드시 금해야 할 사항이라고 본다. R 종료 시에 작업공간의 저장 여부를 묻는 과정을 생략하려면, RStudio의 메인 메뉴 바에서 Tools &gt; Global options...를 선택하고 나타나는 대화 창에서 Save workspace to .RData on exit을 [Never]로 선택하면 된다. 또한 작업별로 자료, 프로그램, 결과물 등을 분리해서 저장하려면 작업 디렉터리의 변경보다는 RStudio에서 project를 이용하는 것이 더 효과적이다. Project의 사용법에 대한 자세한 내용은 RStudio support 사이트를 참조하기 바란다. 1.5 스크립트 파일의 활용 지금까지의 R 작업은 Console 창에 명령문을 하나하나 입력하고 실행하여 이루어졌다. 하 지만 일일이 명령문을 Console 창에 입력하는 것은 상당히 번거로운 작업이고 오류를 범 할 가능성이 많은 방법이다. 비록 이미 실행된 명령문을 자판의 화살표 키를 이용하여 다 시 불러내어 수정하는 것이 가능하지만 여전히 불편한 점이 많은 것은 사실이다. 특히 동 일한 작업이 반복되는 경우라면 SAS에서와 같이 프로그램 편집기에서 프로그램을 작성한 후 프로그램의 전체 혹은 일부분을 실행시키는 것이 훨씬 더 편리하다고 하겠다. RStudio의 스크립트 편집기는 SAS의 확장 편집기보다 훨씬 다양한 기능을 갖고 있다. 따라서 R 작업을 가장 효과적으로 수행하는 방법은 RStudio의 스크립트 편집기를 이용하 는 것이다. 스크립트 창을 여는 방법은 메인 메뉴 바에서 File &gt; New File &gt; R Script를 선택하거나, 단축키 Ctrl+Shift+N 키를 누르는 것이다. 스크립트 창은 일반적인 문서 편집 기와 동일하게 복사 및 붙여 넣기 등의 편집기능을 갖고 있어서 일련의 명령문 입력 및 수 정 등을 훨씬 간편하게 할 수 있다. 또한 구문오류가 있으면 알려주는 기능이 있고, 프로그 램의 문제점을 확인해 주기도 한다. 스크립트 창에 입력된 명령문의 실행방식은 상황에 따라 다음 세 가지로 나뉘어진다. 한 명령문씩 차례로 실행해야 하는 경우: 커서를 실행하고자 하는 명령문에 옮겨놓고 Ctrl+Enter 키를 누른다. 해당 명령문이 실행되고 커서는 자동으로 다음 명령문으로 옮겨간다. 몇 개의 명령문을 한꺼번에 실행해야 하는 경우: 마우스를 이용하여 해당되는 명령문들을 선택하고 하이라이트를 시킨 후 Ctrl+Enter 키를 누른다. 선택된 몇 줄의 명령문들이 모두 실행된다. 스크립트 창의 모든 명령문들을 한꺼번에 실행해야 하는 경우: 해당 스크립트 창을 선택하고 Ctrl+Alt+R 키를 누른다. Figure 1.3: 스크립트 창을 활용한 작업수행 예 Figure 1.3은 RStudio 스크립트 창을 이용한 작업수행의 예를 보여주고 있다. 스크립트 창 을 이용하여 작성된 스크립트 파일의 저장은 Ctrl+S 키를 누르거나, 메뉴 바에서 File &gt; Save 혹은 File &gt; Save As...을 선택하여 폴더와 파일이름을 지정하면 된다. 저장된 스크립트 파일은 다음 작업 때 불러올 수 있는데 Ctrl+O 키를 누르거나, 메뉴 바 에서 File &gt; Open File...를 선택한 후 파일이 저장된 폴더로 이동하여 파일 열기를 선택 하면 된다. 작성된 스크립트 파일을 함수 source()를 이용하여 실행시키는 방법이 있다. 이 방법은 실행되는 스크립트 파일의 내용 및 그 처리 결과를 굳이 Console 창에 출력할 필요가 없 는 경우에 적합한 방법이 된다. Figure 1.4: 파일 ex1.R의 내용 예를 들어 C:\\Users\\Park\\Documents\\My R Files 폴더에 있는 파일 Ex1.R에 Figure 1.4와 같은 내용의 명령문이 입력되어 있다고 하자. 벡터 speed를 생성하고 평균 및 표준편차를 계산하는 내용이다. 명령문 sd(speed)에 함수 print()가 적용된 것을 볼 수 있다. 파일 ex1.R의 내용을 함수 source()로 실행시켜 보자. 첫 번째 경우에는 함수 print() 가 적용된 sd(speed)의 결과만이 출력되었고, echo=TRUE라는 옵션이 포함된 두 번째 경 우에는 입력된 명령문 및 그 결과도 모두 출력되었음을 알 수 있다. &gt; source(&#39;~/My R Files/Ex1.R&#39;) [1] 3.142893 &gt; source(&#39;~/My R Files/Ex1.R&#39;, echo = TRUE) &gt; speed &lt;- c(4, 7, 8, 9, 10, 11, 12, 13, 13, 14) &gt; mean(speed) [1] 10.1 &gt; print(sd(speed)) [1] 3.142893 작업 과정 중에 Plots 창에 생성된 그래프는 간단하게 외부 파일로 저장할 수 있다. 이 작업은 상당히 자주 사용될 것인데, 그것은 R에서 생성된 매우 뛰어난 품질의 그래프를 다 른 보고서 등에 인용해야 하는 경우가 많이 있기 때문이다. 생성된 그래프를 MS Word와 같은 워드프로세스에 삽입하는 것은 그래프를 복사하는 것으로 충분하겠지만 Latex에서 이용하기 위해서는 파일로 저장해야 할 것이다. Figure 1.5: 그래프의 복사 및 저장 이미 작성된 그래프의 복사 및 저장 작업은 Figure 1.5에서와 같이 Plots 창의 Export 버 튼을 클릭하면 나타나는 메뉴에서 선택하면 된다. 또는 메인 메뉴 바에서 Plots &gt; Copy to Clipboard ... 혹은 Plots &gt; Save as Image ...를 선택하면 된다. 그래프의 복사는 metafile과 bitmap 형식으로 가능하며 파일로의 저장은 PNG, JPEG, metafile 등 여러 형태로 가능하다. 그래프를 파일로 저장하는 두 번째 방법은 함수 pdf(), postscript(), bmp(), jpeg() 등을 이용하는 것이다. 그래프를 작성하기 전 원하는 파일 형태에 해당되는 함수를 실행시키고 이어서 그래프를 작성한 후 함수 dev.off()를 실행시키면 작성된 그래프가 파일로 저장된다. &gt; speed &lt;- c(4,7,8,9,10,11,12,13,13,14) &gt; dist &lt;- c(2,4,16,10,18,17,24,34,26,26) &gt; pdf(&quot;plot1.pdf&quot;) &gt; plot(dist, speed) &gt; dev.off() png 2 1.6 일괄처리 앞 절에서는 RStudio에서 R 스크립트 파일을 실행하는 방법에 대해서 알아보았다. 이 방 법은 대부분의 경우에 적용되는 방법이다. 그러나 경우에 따라서는 스크립트 파일을 일괄 처리방식으로 실행해야 할 수도 있다. 일괄처리는 윈도우 명령 프롬프트 창에서 실행해야 되는 것이므로 RStudio 외부에서만 가능한 것이었으나, RStudio의 최근 버전부터는 내부 에서도 가능하게 되었다. 일괄처리방식의 작업이 필요하지 않은 사용자들은 이 절의 내용 을 생략해도 무관하다고 본다. RStudio 내부에서 일괄처리방식의 실행은 Console 탭 옆에 있는 Terminal 탭을 누르면 열리는 Terminal 창에서 할 수 있다. Terminal 창은 윈도우 명령 프롬프트 창을 RStudio 내부로 옮겨 놓은 것으로 간주하면 된다. R 스크립트 파일을 일괄처리방식으로 실행시키는 명령문의 기본 형식은 다음과 같다. R CMD BATCH infile outfile Rscript infile 여기서 infile은 스크립트 파일이다. R CMD를 사용하는 경우에는 실행결과가 outfile에 저장되고, Rscript를 사용하는 경우에는 결과가 Terminal 창에 출력된다. 예를 들어 실행시킬 스크립트 파일이 Figure 1.4에서 보았던 C:\\Users\\Park\\Documents\\My R Files에 있는 Ex1.R이라고 하자. Terminal 창이 열리면 처음 위치는 현재의 작업 디렉터리가 된다. 따라서 명령문 cd를 이용하여 스크립트 파일이 있는 폴더로 이동한다. Terminal 창에서 사용되는 윈도우 명령 프롬프트 명령문들은 예전에는 DOS 명령문으로 불리던 것으로 매우 생소하게 느껴질 것이다. 실행 과정 및 결과는 Figure 1.6과 같다. Figure 1.6: Terminal 창에서 일괄처리 R 외부에서 스크립트 파일을 일괄처리방식으로 실행시키기 위해서는 R 실행 파일이 있 는 폴더를 기존의 path에 추가해야 하고, 윈도우 명령 프롬프트 창을 열어야 한다. 먼저 R 실행 파일이 있는 폴더인 C:\\Program Files\\R\\R-4.1.2\\bin\\x64를 Windows 10에서 기존 의 path에 추가하는 방법은 다음과 같다. Windows 시작 버튼 &gt; 설정 &gt; [설정 찾기]에서 ‘고급 시스템 설정’ 입력 &gt; ’고급 시 스템 설정 보기’를 클릭 [시스템 속성] 창이 열리면 [고급] 탭 하단에 있는 [환경 변수]를 클릭 [환경 변수] 창 하단의 [시스템 변수]에서 Path를 선택하고 [편집]을 클릭 [환경 변수 편집] 창에서 [찾아보기]를 클릭한 후 R 실행 파일이 있는 폴더를 선택하 여 Figure 1.7과 같이 path에 추가 Figure 1.7: R 실행 폴더를 path에 추가 이어서 Windows 명령 프롬프트 창을 연다. 몇 가지 방법이 있으나, 그 중 한 방법은 자 판에서 윈도우 키를 찾아 윈도우+R 키를 누르면 나타나는 [실행] 창에 cmd라고 입력하고 [확인] 키를 누르는 것이다. 이후의 작업은 RStudio 내부에서의 작업과 동일하다. 즉, 실행시킬 스크립트 파일이 있 는 폴더로 이동하여 실행한다. 1.7 R의 확장: 패키지 R의 막강한 파워는 다양한 패키지에서 온다고 할 수 있다. 패키지란 사용자가 작성한 R 함수, 데이터 및 컴파일된 코드 등을 모아 놓은 것으로, 다양한 분야의 분석도구를 제공하 고 있다. 2022년 2월 현재 18,800개가 넘는 패키지가 CRAN 사이트에 올라와 있으며, 그 수가 꾸준히 증가하고 있다. 다양한 패키지를 사용할 수 있다는 것은 분석자의 입장에서는 큰 축복이라고 할 수 있으나 너무 많은 수의 패키지가 있기 때문에 각 패키지의 특성을 모 두 파악하는 것이 실질적으로 거의 불가능하며, 따라서 사용자가 필요한 특정 분석기법이 어떤 패키지에 있는지를 알아내는 것이 어렵다는 측면도 있다. 또한 개별 사용자들이 직접 작성해서 올린 것이기 때문에 간혹 문제가 있는 패키지가 있을 수도 있다는 점을 항상 유 의해야 한다. 1.7.1 패키지의 종류 몇몇 패키지들은 R을 설치할 때(즉, R의 base 시스템을 PC에 설치할 때) 자동으로 설치된 다. 이것들 중 실질적으로 base 시스템의 일부분처럼 작동되는 것이 있는데 여기에는 base, datasets, graphics, grid, methods, stats, utils 등이 포함되며, 이것을 ’base 패키지’라고 한 다. 또한 자동적으로 설치는 되지만 사용하기 위해서는 R 세션으로 따로 불러들여야 하는 패키지들도 있는데 여기에는 KernSmooth, MASS, foreign, lattice 등이 포함되며, 이것을 recommended 패키지’라고 한다. 이 두 부류에 포함되지 않는 다른 패키지들은 모두 개별 적으로 설치하고 R 세션으로 불러들여야 사용할 수 있다. 설치된 패키지의 목록은 RStudio의 Packages 창에서 확인할 수 있는데, 사용자가 개별 적으로 설치한 패키지는 User Library라는 제목 밑에 정렬되어 있고, base 패키지와 recommended 패키지는 System Library라는 제목 밑에 정렬되어 있다. 설치된 패키지가 PC 안에 저장된 위치는 base 패키지와 recommended 패키지는 C:\\Program Files\\R\\R-4.1.2\\library라는 폴더이고, 사용자가 개별적으로 설치한 패키지는 디폴트 작업 디렉터리 밑에 있는 R\\win-library\\4.1라는 폴더에 저장되는 것이 디폴트이다. 1.7.2 패키지의 설치 및 사용 패키지를 설치하기 위해서는 함수 install.packages()를 이용하거나, RStudio의 Packages 창에 있는 Install 버튼을 클릭하면 된다. 패키지가 설치되는 디렉터리는 함수 .libPaths()를 실행하면 나타나는 첫 번째 경로에 설치되는 것이 디폴트이다. &gt; .libPaths() [1] &quot;C:/Users/Park/Documents/R/win-library/4.1&quot; [2] &quot;C:/Program Files/R/R-4.1.2/library&quot; 예를 들어 John Verzani의 “Using R for Introductory Statistics”라는 책에 있는 여러 가지 함수 및 데이터가 들어 있는 패키지 UsingR을 설치해 보자. Packages 창의 Install 버튼 을 클릭하면 나타나는 창에 Figure 1.8와 같이 UsingR을 입력하고, [Install]을 클릭하자. Console 창에 install.packages(\"UsingR\")이 실행되는 것을 확인할 수 있다. Figure 1.8: 패키지 설치 과정 설치된 패키지는 R 세션으로 불러와야 사용할 수 있는데 이 작업은 함수 require() 또는 library()로 하게 된다. 예를 들어 설치된 패키지 UsingR를 R 세션으로 불러오기 위해서는 require(UsingR) 혹은 library(UsingR)를 실행시키면 된다. 이때에는 패키지의 이름에 인용부호를 붙이지 않아야 한다. 두 함수 require()와 library()의 기능에는 미묘한 차이가 있는데, 설치되어 있지 않은 패키지를 불러오면 함수 library()는 오류가 발생되지만, 함수 require()는 단순 경고 메시지를 보여준다. 또한 함수 require()는 패키지를 불러오는데 성공하면 TRUE 값을, 실패하면 FALSE 값을 발생시킨다. 이미 설치된 패키지들의 버전 등을 포함한 대략적인 정보는 함수 installed.packages() 로 확인할 수 있으며, 설치된 패키지들을 업데이트시키기 위해서는 함수 update.packages()를 실행시키거나, Packages 창의 Update 버튼을 클릭하면 된다. 특정 패키지에 대한 자세한 도움이 필요한 경우에 help(package=\"패키지 이름\")을 실행 시키면 해당 패키지에 있는 함수와 데이터 등에 대한 설명을 볼 수 있다. 예컨대 help(package=\"MASS\")을 실행시키면, 패키지 MASS에 대한 도움 문서들을 Help 창에서 볼 수 있다. 또한 현재 R 세션에 불러들여져 있는 패키지에 있는 함수나 데이터에 대한 도움은 help(함수 이름)로 얻을 수 있다. 즉, 함수 plot()에 대한 도움은 help(plot) 혹은 help 대신 물음표 기호를 사용하여 ?plot으로 얻을 수 있다. 조금 더 포괄적인 도움이 필요한 경우에 함수 help.search()를 이용하면 매우 유용한 정보를 얻을 수 있다. 예를 들어 문자열 plot이 포함된 여러 다른 패키지에 있는 다양한 함 수들에 대한 도움이 필요한 경우 help.search(\"plot\") 혹은 물음표 기호를 중복시켜 ??plot을 실행시키면 매우 유용한 도움을 받을 수 있다. R은 일 년에도 여러 번 업데이트 버전이 출시된다. 새로운 버전의 R을 다시 설치하기 위해 매번 CRAN 사이트를 방문할 수도 있겠지만, 패키지 installr의 함수 updateR()을 사용하는 것도 좋은 방법이 된다. RGui에서 함수 updateR()을 실행하면, 새로운 버전의 R 출시 여부를 먼저 확인한다. 이어서 나타나는 대화상자에서 설치를 선택하면 새로운 버 전의 R이 설치된다. 새로운 버전의 R이 설치되면 이전 버전에서 설치했던 패키지를 다시 설치해야 하는 경 우가 있다. 함수 updateR()에서 패키지 이전 작업이 잘 수행되지 않는 경우에는 다음과 같이 실행해 보자. 버전 4.0.2에서 버전 4.1.2로 업데이트한 후, 이전에 설치했던 모든 패키 지를 다시 설치하는 작업 내용이다. &gt; old.lib &lt;- &quot;C:/Users/PARK/Documents/R/win-library/4.0&quot; &gt; install.packages(pkgs=as.data.frame(installed.packages(old.lib))$Package) R은 잠시도 정체되어 있지 않고 끊임없이 진화하고 있다. 이것은 수많은 패키지들이 새 로이 나타나고 업데이트되고 있기 때문에 가능한 일이다. 이렇듯 지속적으로 변화하고 있 는 R을 제대로 따라가며 이해하는 것은 말 그대로 큰 도전이라고 하겠다. 하지만 다행스러 운 일은 세계 곳곳에 활발하게 활동하고 있는 수많은 R 사용자 모임이 있고 그들이 운영하는 많은 웹사이트가 있다는 것이다. 이들 웹사이트를 잘 활용하면 내가 필요한 분석절차 가 어떤 패키지에 있는지를 알 수 있으며, 새로운 분석기법에 대한 소개 및 적절한 도움도 받을 수 있을 것이다. 1.7.3 패키지 tidyverse의 소개 Tidyverse는 data science를 위해 개발된 패키지들의 묶음이라고 할 수 있다. 여기에 속한 패키지들은 모두 공통된 분석 방식을 공유하고 있으며, 자료분석에 필요한 모든 과정을 망라하고 있다. 패키지 tidyverse에 속한 많은 패키지들은 개별적으로 하나하나 설치할 필요 없이 install.packages(\"tidyverse\")를 실행하면 모든 패키지들이 설치된다. 하지만 이 패키지들을 사용하기 위하여 library(tidyverse)를 실행하면 설치 때와는 다르게 몇몇 패키지들만 R 세션에 올라오는데, 이 몇몇 패키지들을 core tidyverse라고 부른다. 여기에 속하지 않는 다른 많은 패키지들은 모두 개별적으로 함수 library()로 불러와야 한다. Tidyverse 버전 1.3.1의 상황에서 core tidyverse에 속하는 패키지는 다음과 같다. readr: 자료 불러오기 tibble: 개선된 형태의 데이터 프레임 tidyr: 분석이 편리한 형태인 tidy 자료 생성 dplyr: 데이터 프레임 다루기 stringr: 문자열 다루기 forcats: 요인 다루기 ggplot2: 자료의 시각화 purrr: 함수형 프로그래밍 자료분석 내용을 과정별로 나누어 살펴보면, 먼저 분석 대상이 되는 외부 자료를 R로 불러와야 한다. R로 불러온 자료는 대부분의 경우 바로 분석이 가능한 형태를 띠고 있지 않다. 따라서 불러온 자료를 분석이 가능한 형태로 다듬어야 하며, 이어서 분석에 필요한 자료를 생성하는 등의 변형 과정을 거쳐서 자료의 시각화와 모형화 과정을 통해 자료를 분 석하게 된다. 이러한 각각의 분석 과정을 담당할 수 있는 패키지가 tidyverse에는 모두 포함되어 있다. 사실 tidyverse로 인하여 R은 완전히 새로 태어났다고 할 수 있는데, 상당히 효율적인 작업이 가능해졌으며, 사용 방식에 일관성이 확립되었고 어렵지 않게 확장할 수 있는 체계가 구성되었기 때문이다. 따라서 데이터를 다듬고 그래프를 작성하는 작업은 이제 base 패키지를 이용하는 것보다 tidyverse의 일원인 dplyr이나 ggplot2 등을 이용하는 것이 훨씬 더 바람직하다고 할 수 있다. "],["data-structure.html", "Chapter 2 R 데이터 구조 2.1 벡터 2.2 요인 2.3 날짜 2.4 행렬 및 배열 2.5 데이터 프레임 2.6 Tibble: 개선된 형태의 데이터 프레임 2.7 리스트 2.8 연습문제", " Chapter 2 R 데이터 구조 통계학에서 데이터는 양적 데이터와 질적 데이터로 구분된다. 양적 데이터는 숫자형 데이터를 의미하는 것으로서 연속형과 이산형 데이터로 구분할 수 있다. 질적 데이터는 범주형 데이터라고도 하며, 다시 명목형과 순서형으로 구분된다. 또한 통계 데이터 세트란 데이터들이 행과 열의 2차원 형태로 배열된 상태를 의미한다. 열은 변수를 나타내며 하나의 열에는 같은 유형의 데이터만이 올 수 있고, 행은 동일 대상에 대한 여러 변수들의 관찰값을 나타낸다. 이렇듯 분석 대상이 되는 통계 데이터는 다양한 유형과 구조를 가지고 있다. 데이터의 다양한 구조를 표현하기 위해 R에서는 벡터, 요인, 행렬, 배열, 데이터 프레임 그리고 리스트라는 이름의 데이터 객체가 있다. 벡터는 하나의 변수를 나타내기 위한 1차원 구조이고, 요인은 범주형 자료를 나타내기 위한 구조이며, 행렬과 데이터 프레임은 2차원 구조, 배열은 2차원 이상의 구조를 가진 데이터 형태이다. 리스트는 가장 포괄적인 형태의 구조로서 여러 유형, 여러 형태의 데이터를 한데 묶은 형태를 취하고 있다. 이 장에서는 다양한 데이터 객체를 생성하는 방법 및 각 객체들의 중요한 특성들을 살펴보고자 한다. 2.1 벡터 벡터는 하나의 변수를 나타내기 위한 것으로써 1차원으로 배열된 데이터 구조를 갖고 있다. 한 변수를 나타내는 것이므로, 벡터를 구성하고 있는 자료는 모두 동일한 유형이어야 하며, 그 유형에 따라 논리형(logical), 숫자형(numeric), 문자형(character)으로 구분된다. 숫자형 벡터는 다시 정수형(integer)과 실수형(double)으로 세분된다. 2.1.1 벡터의 기본 특성 벡터의 생성 벡터는 함수 c()로 만들 수 있다. &gt; x &lt;- c(TRUE, FALSE, TRUE) &gt; y1 &lt;- c(1L, 3L, 5L) &gt; y2 &lt;- c(1.1, 3.5, 10.4) &gt; z &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) x는 논리형, y1은 정수형, y2는 실수형, z는 문자형 벡터이다. 논리형 벡터는 TRUE 혹은 FALSE로 이루어진 가장 단순한 형태를 갖고 있으며, 벡터의 비교 결과로 주로 생성된다. 정수형 벡터 y1을 만들 때 사용된 숫자 뒤에 붙는 기호 L은 숫자를 정수로 지정하는 효과가 있다. 정수형 벡터와 실수형 벡터는 합쳐서 숫자형 벡터로 분류되며, 문자형 벡터의 구성인자들은 모두 인용부호 \" \" 혹은 ' ' 안에 있어야 한다. 벡터의 특성 벡터의 유형 확인은 함수 typeof()로 할 수 있다. &gt; typeof(x) [1] &quot;logical&quot; &gt; typeof(y1) [1] &quot;integer&quot; &gt; typeof(y2) [1] &quot;double&quot; &gt; typeof(z) [1] &quot;character&quot; 벡터를 구성하고 있는 요소의 개수, 즉 벡터의 길이 확인은 함수 length()로 할 수 있다. 예를 들어 length(y2)는 벡터 y2가 몇 개의 숫자로 구성되어 있는지를 확인하는 것으로 결과는 3이 된다. 구성요소가 하나인 벡터를 스칼라(scalar)라고 하는데, 스칼라를 만들 때에는 함수 c()를 사용하지 않아도 된다. 즉, a &lt;- 1 혹은 a &lt;- c(1) 모두 숫자형 벡터 a를 생성한다. 벡터는 동일한 유형의 데이터만으로 구성할 수 있는데, 만일 다른 유형의 데이터가 뒤섞여서 있다면 어떤 일이 벌어지겠는가? 아래의 예에서 그 답을 찾을 수 있다. &gt; c(1, &quot;1&quot;, TRUE) [1] &quot;1&quot; &quot;1&quot; &quot;TRUE&quot; &gt; c(3, TRUE, FALSE) [1] 3 1 0 첫 번째 예에서 1은 숫자형, \"1\"은 문자형, TRUE는 논리형 데이터이다. 이 데이터를 뒤섞어 입력하면 그 결과는 모두 문자형 데이터로 통일된다. 이것은 문자형이 가장 복잡한 형태의 유형이기 때문이다. 두 번째 예는 숫자형과 논리형 데이터를 함께 입력한 경우이다. 이런 경우에는 논리형 데이터가 숫자형으로 변환되는데, TRUE는 1로, FALSE는 0으로 변환된다. 이것 또한 숫자형이 논리형보다 더 복잡한 유형의 구조이기 때문이다. 벡터 구성요소에 이름 붙이기 모든 벡터는 각 개별 자료에 이름을 붙일 수 있다. 예를 들어 서울, 부산, 인천, 수원의 인구(천 명 단위)를 숫자형 벡터로 입력하면서 각 숫자에 도시 이름을 붙일 수 있다. &gt; c(Seoul=9930, Busan=3497, Inchon=2944, Suwon=1194) Seoul Busan Inchon Suwon 9930 3497 2944 1194 이미 생성된 벡터의 각 개별자료에 이름을 붙이는 것은 함수 names()로 할 수 있다. &gt; pop &lt;- c(9930,3497,2944,1194) &gt; names(pop) &lt;- c(&quot;Seoul&quot;, &quot;Busan&quot;, &quot;Inchon&quot;, &quot;Suwon&quot;) &gt; pop Seoul Busan Inchon Suwon 9930 3497 2944 1194 함수 scan()에 의한 벡터 생성 함수 scan()은 다양한 기능을 지니고 있는 함수로서 직접 벡터를 생성할 수도 있고 외부 데이터 파일을 불러와서 벡터에 할당할 수도 있다. 직접 벡터를 생성하기 위해서는 함수 scan()을 그냥 실행하면 된다. 그러면 Console의 프롬프트가 &gt; 기호에서 1: 기호로 바뀌는데, 이것은 첫 번째 자료의 입력을 기다리고 있다는 것을 의미한다. 이어서 데이터를 직접 입력하거나 또는 복사하고 붙여넣기를 할 수 있으며, 한 줄에 여러 개의 숫자를 빈 칸으로 구분하여 입력할 수도 있다. 아래의 예에서 4개 숫자의 입력이 끝나고 나타나는 5: 프롬프트에서 그냥 Enter 키를 치면 데이터의 입력이 종료된 것으로 인식한다. 문자형 벡터의 입력은 옵션 what=\"character\"를 포함해야 한다. 함수 c()의 경우와는 다르게 각각의 자료에 인용부호를 사용할 필요는 없으나, 만일 자료에 빈칸이 포함되어 있다면 그 자료를 인용부호로 감싸야 한다. 한 변수의 자료가 입력되어 있는 데이터 파일을 벡터로 불러오고자 하는 경우에도 함수 scan()을 사용할 수 있다. 텍스트 파일에 입력된 각 자료들은 반드시 한 칸 이상의 빈 칸으로 구분되어 있어야 한다. 예를 들어 D:\\Data 폴더에 있는 파일 data1.txt에 다음과 같이 데이터가 저장되어 있다고 하자. 이것을 벡터 z에 입력시키는 방법은 다음과 같이 scan()에 불러올 파일이 저장된 위치를 입력하면 된다. Figure 2.1: data1.txt &gt; z &lt;- scan(&quot;Data/data1.txt&quot;) &gt; z [1] 24 35 28 21 25 2.1.2 다양한 형태를 갖는 벡터의 생성 이 절에서는 기존의 벡터에 데이터를 추가하거나 여러 벡터들을 결합하여 하나의 벡터를 만드는 방법 및 일정한 구조를 갖는 벡터의 생성 방법을 살펴보겠다. 2.1.2.1 벡터에 데이터 추가 및 벡터들의 결합 기존의 벡터에 추가적으로 데이터를 덧붙이는 작업이나 벡터들을 결합하는 작업은 함수 c() 또는 함수 append()를 이용하여 할 수 있다. 우선 c()에 의한 결합 예를 살펴보자. &gt; x &lt;- c(11,12,13,14) &gt; c(x, 15) [1] 11 12 13 14 15 &gt; y &lt;- c(16,17,18) &gt; c(x, y) [1] 11 12 13 14 16 17 18 함수 append()는 추가되는 스칼라 혹은 벡터의 위치를 옵션 after로 지정할 수 있다. &gt; append(x, 15) [1] 11 12 13 14 15 &gt; append(x, 15, after=2) [1] 11 12 15 13 14 &gt; append(x, y) [1] 11 12 13 14 16 17 18 &gt; append(x, y, after=3) [1] 11 12 13 16 17 18 14 2.1.2.2 일정한 구조를 갖는 벡터의 생성 일정한 구조를 갖고 있는 벡터가 필요한 경우가 있다. 예를 들어 1부터 100까지의 정수로 이루어진 벡터를 만들어야 한다고 하자. 이러한 경우 c()에 숫자를 하나하나 입력해야 한다면 무척 한심스러운 일이 될 것이다. 콜론(:) 연산자 또는 seq()를 이용하면 일정한 간격이 있는 자료를 쉽게 만들 수 있으며, rep()를 이용하면 반복된 패턴이 있는 자료를 간편하게 만들 수 있다. 콜론 연산자 콜론 연산자는 연산자의 왼쪽 숫자에서 시작하여 오른쪽 숫자를 초과하지 않을 때까지 1씩 증가하는 수열을 만든다. 왼쪽의 숫자가 오른쪽의 숫자보다 크면 1씩 감소를 시킨다. &gt; 1:5 [1] 1 2 3 4 5 &gt; -3:3 [1] -3 -2 -1 0 1 2 3 &gt; 1.5:5.4 [1] 1.5 2.5 3.5 4.5 &gt; 5:0 [1] 5 4 3 2 1 0 함수 seq()에 의한 수열 생성 콜론 연산자는 만들고자 하는 수열의 증가 폭이 1인 경우에만 사용할 수 있다는 한계가 있다. 조금 더 일반적인 형태의 수열을 만드는 작업은 함수 seq()를 사용해야 한다. 가장 기본적인 형태는 옵션 from과 to가 있으면서 by와 length로 수열의 간격 또는 개수를 지정하는 것이다. 시작점(from)과 끝점(to)만이 있다면, 콜론 연산자의 경우와 같이 간격이 1이 된다. 옵션 by는 간격을 지정하는 것으로써 from에서 시작하여 by 만큼 증가(감소)를 시키되 to를 지나치지 않는 수열을 생성한다. 옵션 length는 수열의 개수를 지정하는 것으로써 from과 to를 포함하는 간격이 일정한 수열을 생성한다. 만일 옵션 to가 없다면, from에서 시작하여 by 만큼의 간격이 있는 length개의 수열을 구성한다. &gt; seq(from=0, to=5) [1] 0 1 2 3 4 5 &gt; seq(from=0, to=5, by=2) [1] 0 2 4 &gt; seq(from=0, to=5, length=3) [1] 0.0 2.5 5.0 &gt; seq(from=0, by=2, length=3) [1] 0 2 4 함수 seq()에 하나의 숫자만을 입력하면 1을 시작점으로 하여 1씩 증가(감소)하여 지정된 숫자를 끝점으로 하는 수열이 만들어진다. &gt; seq(3) [1] 1 2 3 &gt; seq(-3) [1] 1 0 -1 -2 -3 주어진 벡터와 길이가 같으면서, 1에서부터 시작하고 간격이 1인 수열이 필요한 경우가 있다. 이러한 경우에는 함수 seq()의 옵션 along에 해당되는 벡터를 지정하거나, 옵션 length에 해당 벡터의 길이를 지정하면 된다. 또는 함수 seq_along() 혹은 함수 seq_len()을 대신 사용해도 된다. &gt; x &lt;- c(24,31,29) &gt; seq(along=x) [1] 1 2 3 &gt; seq_along(x) [1] 1 2 3 &gt; seq(length=length(x)) [1] 1 2 3 &gt; seq_len(length(x)) [1] 1 2 3 함수 rep()에 의한 반복된 패턴이 있는 데이터 생성 함수 rep()는 옵션 times와 each, length를 이용하여 다양한 형태의 반복된 패턴이 있는 데이터를 만들 수 있다. 옵션 times는 반복 횟수를 지정하는 것으로써 하나의 정수를 지정할 때와 반복시키려는 벡터의 길이와 같은 정수형 벡터를 지정할 때에 다른 결과가 나온다. &gt; rep(1, times=3) [1] 1 1 1 &gt; rep(1:3, times=2) [1] 1 2 3 1 2 3 &gt; rep(c(&quot;M&quot;,&quot;F&quot;), times=c(2,3)) [1] &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; 옵션 times에 하나의 반복 횟수만 지정하면 데이터 전체를 지정된 횟수만큼 반복시킨다. 반복 대상이 c(\"M\",\"F\")이고 반복 횟수가 c(2,3)이 되어 일대일 대응이 되는 경우에는 M이 두 번 먼저 반복되고 이어서 F가 세 번 반복된다. 옵션 each에 반복 횟수를 지정하면, 데이터의 요소들이 각각 each번 반복한다. 이어서 옵션 times를 추가하면 각 요소의 each번 반복 과정 전체가 times만큼 반복된다. &gt; rep(1:3, each=2) [1] 1 1 2 2 3 3 &gt; rep(1:3, times=rep(2,3)) [1] 1 1 2 2 3 3 &gt; rep(1:3, each=2, times=2) [1] 1 1 2 2 3 3 1 1 2 2 3 3 옵션 length에 벡터의 길이를 지정하면, 길이가 length가 될 때까지 데이터 전체가 반복된다. 옵션 each를 함께 사용하면, 데이터 각 요소가 each번 반복되는 과정을 반복하여 결과 벡터의 길이가 length가 되도록 한다. &gt; rep(1:3, length=6) [1] 1 2 3 1 2 3 &gt; rep(1:3, each=2, length=8) [1] 1 1 2 2 3 3 1 1 2.1.3 문자열을 위한 함수 R에는 문자열을 다루기 위한 매우 유용한 함수들이 있다. 우리는 종종 문자형 벡터에서 특 정 정보를 얻거나 문자형 벡터의 내용을 수정해야 할 때가 있는데 이런 경우 유용하게 사 용할 수 있는 함수들이 Table 2.1에 있다. Table 2.1: 문자 함수 함수 기능 nchar(x) 문자열 x를 구성하는 문자의 개수 paste(…, sep=” “) 문자열의 결합 substr(x, start, stop) 문자열 일부분 선택 toupper(x) 영문자 대문자로 변환 tolower(x) 영문자 소문자로 변환 strsplit(x, split) 문자열의 분리 sub(old, new, x) 문자열 치환 gsub(old, new, x) 문자열 치환 함수 nchar(): 문자열을 구성하는 문자 개수 계산 함수 nchar()는 문자열을 구성하고 있는 문자의 개수를 센다. 다음에 주어진 문자형 벡터 x의 첫 문자열은 4개, 두 번째는 3개, 마지막 문자열은 4개의 문자로 이루어졌다는 것을 알 수 있다. 한글로 이루어진 문자열도 문제 없이 문자 개수를 셀 수 있다. &gt; x &lt;- c(&quot;Park&quot;,&quot;Lee&quot;,&quot;Kwon&quot;) &gt; nchar(x) [1] 4 3 4 &gt; nchar(&quot;응용통계학과&quot;) [1] 6 함수 paste(): 문자열의 결합 여러 개의 문자열들을 적절하게 결합시켜 새로운 문자열을 만들어야 하는 경우가 자주 있 다. 이런 경우에 함수 paste()가 매우 유용하게 사용된다. 함수 paste()의 기본적인 사용법은 결합시키고자 하는 문자열들을 차례로 입력하는 것이고, 옵션 sep에서 지정하는 문자 혹은 빈칸 등이 결합되는 문자열과 문자열 사이에 오게 된다. 5개의 문자열인 “모든,” “사람에게는,” “통계적,” “사고능력이” 그리고 “필요하다”를 결 합시켜 보자. 첫 번째는 옵션 sep의 디폴트 값인 sep=\" \"가 사용되어 결합되는 문자열들 사이에 하나의 빈칸이 생긴 것이고, 두 번째는 sep=\"-\"가 지정되어 문자열들이 대시(dash) 기호로 결합되었고, 세 번째에는 sep=\"\"이 사용되어 빈칸 없이 문자열들이 결합되었다. &gt; paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;) [1] &quot;모든 사람에게는 통계적 사고능력이 필요하다&quot; &gt; paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;, + sep=&quot;-&quot;) [1] &quot;모든-사람에게는-통계적-사고능력이-필요하다&quot; &gt; paste(&quot;모든&quot;, &quot;사람에게는&quot;, &quot;통계적&quot;, &quot;사고능력이&quot;, &quot;필요하다&quot;, + sep=&quot;&quot;) [1] &quot;모든사람에게는통계적사고능력이필요하다&quot; 함수 paste()에 입력된 숫자는 문자로 전환되어 문자열 결합에 사용된다. &gt; paste(&quot;원주율은&quot;, pi, &quot;이다&quot;) [1] &quot;원주율은 3.14159265358979 이다&quot; 함수 paste() 안에 문자형 벡터 몇 개가 함께 들어오면 벡터들의 대응되는 요소끼리의 결합이 이루어진다. 이때 벡터의 길이가 서로 다르면, 순환법칙이 적용된다. 즉, 문자열 \"Stat\"과 벡터 1:3을 함께 입력하면 실제로는 c(\"Stat\",\"Stat\",\"Stat\")과 1:3이 결합이 되는 것이고, c(\"Stat\",\"Math\")와 1:3을 함께 입력하면, c(\"Stat\",\"Math\", \"Stat\")과 1:3이 결합되는 것이다. &gt; paste(c(&quot;Stat&quot;, &quot;Math&quot;), 1:2, sep = &quot;&quot;) [1] &quot;Stat1&quot; &quot;Math2&quot; &gt; paste(&quot;Stat&quot;, 1:3, sep=&quot;&quot;) [1] &quot;Stat1&quot; &quot;Stat2&quot; &quot;Stat3&quot; &gt; paste(c(&quot;Stat&quot;,&quot;Math&quot;), 1:3, sep=&quot;-&quot;) [1] &quot;Stat-1&quot; &quot;Math-2&quot; &quot;Stat-3&quot; 빈칸 없이 문자열을 결합시킬 때에는 함수 paste()에 옵션 sep=\"\"을 추가하는 것보다 그냥 함수 paste0()을 사용하는 것이 더 편리하다. &gt; paste0(&quot;stat&quot;, 1:3) [1] &quot;stat1&quot; &quot;stat2&quot; &quot;stat3&quot; 한 개의 문자형 벡터를 구성하고 있는 모든 문자열을 묶어서 하나의 문자열로 나타내는 작업이 필요한 경우가 있다. 이때는 옵션 collapse를 사용하면 된다. 영문자 소문자와 대문자로 구성된 문자형 벡터 letters와 LETTERS를 각각 하나의 문자열로 합쳐보자. &gt; letters [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; &gt; paste0(letters, collapse=&quot;&quot;) [1] &quot;abcdefghijklmnopqrstuvwxyz&quot; &gt; paste(LETTERS, collapse=&quot;,&quot;) [1] &quot;A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z&quot; 하나의 문자열로 합쳐질 때 옵션 collapse에 지정한 문자가 일종의 구분자 역할을 하고 있다. 함수 paste()에 두 개의 문자형 벡터를 입력하고, 이어서 옵션 collapse를 사용하면 입력된 두 문자형 벡터를 하나의 문자형 벡터로 결합시키고, 이어서 모든 문자열을 묶어서 하나의 문자열로 나타낸다. &gt; paste0(letters, LETTERS, collapse = &quot;,&quot;) [1] &quot;aA,bB,cC,dD,eE,fF,gG,hH,iI,jJ,kK,lL,mM,nN,oO,pP,qQ,rR,sS,tT,uU,vV,wW,xX,yY,zZ&quot; &gt; paste(letters, LETTERS, sep = &quot;-&quot;, collapse = &quot;,&quot;) [1] &quot;a-A,b-B,c-C,d-D,e-E,f-F,g-G,h-H,i-I,j-J,k-K,l-L,m-M,n-N,o-O,p-P,q-Q,r-R,s-S,t-T,u-U,v-V,w-W,x-X,y-Y,z-Z&quot; 함수 substr(): 문자열에서 일부분 선택 주어진 문자열에서 일부분을 선택해야 하는 작업도 빈번히 일어나는 중요한 작업 중 하나 이다. 함수 substr()에는 문자형 벡터, 시작점, 끝점이 차례로 입력된다. 시작점과 끝점은 각각 정수형 스칼라 혹은 벡터가 된다. 시작점과 끝점이 벡터가 되면, 대응되는 숫자끼리 시작점과 끝점을 구성하며 필요하다면 순환법칙도 적용된다. 아래 예의 첫 번째 결과는 문자형 벡터 x를 구성하고 있는 세 문자에 대하여 동일하게 시작점과 끝점을 하나의 숫자로 지정하여 추출한 것이다. 두 번째 결과는 시작점과 끝점이 벡터로 지정된 것으로 첫 번째 문자열에는 (시작점=1, 끝점=2), 두 번째 문자열에는 (시작 점=3, 끝점=6), 그리고 세 번째 문자열에는 다시 (시작점=1, 끝점=2)가 적용된 결과이다. &gt; substr(&quot;Statistics&quot;, 1, 4) [1] &quot;Stat&quot; &gt; x &lt;- c(&quot;응용통계학과&quot;, &quot;정보통계학과&quot;, &quot;학생회장&quot;) &gt; substr(x, 3, 6) [1] &quot;통계학과&quot; &quot;통계학과&quot; &quot;회장&quot; &gt; substr(x, c(1,3), c(2,6)) [1] &quot;응용&quot; &quot;통계학과&quot; &quot;학생&quot; 미국의 세 도시와 그 도시가 속한 주 이름이 입력된 문자형 벡터 x에서 세 도시가 속한 주 이름만을 선택하여 출력해 보자. 비록 세 문자열의 길이가 서로 다르지만 주의 이름은 각 문자열의 마지막 두 칸에 있다는 점에 착안하여 함수 nchar()로 시작점과 끝점을 지정할 수 있다. &gt; x &lt;- c(&quot;New York, NY&quot;,&quot;Ann Arbor, MI&quot;,&quot;Chicago, IL&quot;) &gt; substr(x, start=nchar(x)-1, stop=nchar(x)) [1] &quot;NY&quot; &quot;MI&quot; &quot;IL&quot; 패키지 ggplot2에 있는 데이터 프레임 mpg는 자동차의 연비와 관련된 자료이다. 11개의 변수 중 trans는 변속기 종류를 나타내는 변수이다. 변수 trans가 갖는 값을 살펴보자. 함수 library()로 패키지를 로딩하지 않은 상태에서 해당 패키지의 데이터를 불러오려면 패키지::데이터의 형식을 사용하면 된다. mpg$trans는 데이터 프레임 mpg의 변수 trans를 벡터 형태로 선택한 것이며 자세한 설명은 2.5절에서 찾아볼 수 있다. 또한 함수 table()로 문자형 벡터를 구성하고 있는 각 문자열의 빈도를 계산할 수 있다. &gt; x &lt;- ggplot2::mpg$trans &gt; table(x) x auto(av) auto(l3) auto(l4) auto(l5) auto(l6) auto(s4) auto(s5) 5 2 83 39 6 3 3 auto(s6) manual(m5) manual(m6) 16 58 19 auto(av)부터 auto(s6)까지를 auto로 통합하고 manual(m5)와 manual(m6)를 manual 로 통합하는 작업은 시작점을 1, 끝점을 nchar(x)-4로 지정함으로써 가능하다. &gt; y &lt;- substr(x, start=1, stop=nchar(x)-4) &gt; table(y) y auto manual 157 77 함수 strsplit(): 문자열의 분할 여러 문자열들을 서로 결합하는 것도 중요한 작업이지만 하나의 문자열을 몇 개로 분리하 는 것도 매우 중요한 작업이다. 함수 strsplit()는 주어진 문자열을 옵션 split에 지정된 기준에 의하여 분리시킨다. 문자형 벡터 x에 입력된 세 도시의 이름과 주 이름을 분리해 보자. 도시 이름과 주 이름 이 콤마로 구분되어 있기 때문에 분리기준으로 옵션 split=\",\"을 지정하였다. 결과는 리스트로 출력된다. R 데이터 구조 중 하나인 리스트에 대한 소개는 2.7절에 있다. &gt; x &lt;- c(&quot;New York, NY&quot;,&quot;Ann Arbor, MI&quot;,&quot;Chicago, IL&quot;) &gt; (y &lt;- strsplit(x,split=&quot;,&quot;)) [[1]] [1] &quot;New York&quot; &quot; NY&quot; [[2]] [1] &quot;Ann Arbor&quot; &quot; MI&quot; [[3]] [1] &quot;Chicago&quot; &quot; IL&quot; &gt; unlist(y) [1] &quot;New York&quot; &quot; NY&quot; &quot;Ann Arbor&quot; &quot; MI&quot; &quot;Chicago&quot; &quot; IL&quot; 리스트 y를 생성하는 할당문 전체가 괄호로 감싸여 있는데, 이렇게 할당문을 괄호로 감싸면 할당된 객체의 값이 출력됨을 볼 수 있다. 또한 리스트 객체를 함수 unlist()에 입력하면, 리스트의 모든 구성요소들로 이루어진 벡터가 만들어진다. 문자열을 구성하는 개별 문자들을 모두 분리시키는 작업도 가능한데, 이 경우에는 분리 기준이 옵션 split = \"\"이 되어야 한다. &gt; unlist(strsplit(&quot;PARK&quot;,split=&quot;&quot;)) [1] &quot;P&quot; &quot;A&quot; &quot;R&quot; &quot;K&quot; 점(.)이 포함된 문자열에서 점을 기준으로 분리하고자 하는 경우에 옵션 split=\".\"을 지정하는 것으로는 원하는 결과를 얻을 수 없다. 옵션 split에는 정규 표현식(regular expression)이 사용되는데, 정규 표현식에서 점은 다른 의미를 갖고 있는 특수 기호로 사용된다. 이러한 경우에는 또 다른 기호인 대괄호를 함께 사용하면 원하는 결과를 얻을 수 있다. 정규 표현식에 대한 대략적인 소개는 ??장에서 볼 수 있다. &gt; unlist(strsplit(&quot;a.b.c&quot;,split=&quot;.&quot;)) [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &gt; unlist(strsplit(&quot;a.b.c&quot;,split=&quot;[.]&quot;)) [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 함수 toupper()와 tolower() 가끔 주어진 문자형 벡터를 구성하는 영문자들의 대문자 혹은 소문자를 서로 바꿔야 하는 경우가 생긴다. 이러한 경우에 유용하게 사용할 수 있는 함수가 toupper()와 tolower() 이다. &gt; x &lt;- c(&quot;park&quot;,&quot;lee&quot;,&quot;kwon&quot;) &gt; (y &lt;- toupper(x)) [1] &quot;PARK&quot; &quot;LEE&quot; &quot;KWON&quot; &gt; tolower(y) [1] &quot;park&quot; &quot;lee&quot; &quot;kwon&quot; 문자열 전체를 바꾸는 것이 아닌 특정 위치에 있는 것만 바꿔야 할 경우가 있다. 문자형 벡터 x를 구성하고 있는 세 문자열의 첫 글자만 대문자로 바꿔보자. 이 경우 우선 함수 substr()로 첫 글자를 추출하고, 그것을 함수 toupper()로 대문자로 변환시킨 후, 그 결 과를 다시 함수 substr()로 추출한 첫 글자를 치환하면 된다. &gt; x [1] &quot;park&quot; &quot;lee&quot; &quot;kwon&quot; &gt; substr(x,1,1) &lt;- toupper(substr(x,1,1)) &gt; x [1] &quot;Park&quot; &quot;Lee&quot; &quot;Kwon&quot; 함수 sub()와 gsub(): 문자열의 치환 문자열의 일부를 수정하는 작업은 매우 중요한 작업이라 하겠다. 두 함수의 일반적인 사용 법은 sub(old, new, x)과 gsub(old, new, x)이 되는데, 문자형 벡터 x를 구성하고 있는 각 문자열 중 old를 new로 치환하는 것이다. 두 함수의 차이점으로 함수 sub()는 각 문자열 중 첫 번째 old만을 new로 치환하지만, 함수 gsub()는 각 문자열의 모든 old를 new로 치환한다는 것이다. &gt; x &lt;- &quot;Park hates stats. He hates math, too.&quot; &gt; sub(&quot;hat&quot;,&quot;lov&quot;,x) [1] &quot;Park loves stats. He hates math, too.&quot; &gt; gsub(&quot;hat&quot;,&quot;lov&quot;,x) [1] &quot;Park loves stats. He loves math, too.&quot; 문자형 벡터를 구성하고 있는 각 원소의 치환도 가능하다. &gt; (y &lt;- paste0(&quot;banana&quot;,1:3)) [1] &quot;banana1&quot; &quot;banana2&quot; &quot;banana3&quot; &gt; sub(&quot;a&quot;,&quot;A&quot;,y) [1] &quot;bAnana1&quot; &quot;bAnana2&quot; &quot;bAnana3&quot; &gt; gsub(&quot;a&quot;,&quot;A&quot;,y) [1] &quot;bAnAnA1&quot; &quot;bAnAnA2&quot; &quot;bAnAnA3&quot; 문자열의 일부를 삭제하고자 한다면 new에 \"\"을 입력하면 된다. &gt; z &lt;- &quot;Everybody cannot do it&quot; &gt; sub(&quot;not&quot;,&quot;&quot;,z) [1] &quot;Everybody can do it&quot; 2.1.4 벡터의 연산 벡터와 벡터의 연산은 대응되는 각 구성요소끼리의 연산, 즉 벡터 단위로 이루어진다. 이것의 의미는 다음의 예에서 확인할 수 있다. &gt; x &lt;- c(7,8,9,10) &gt; y &lt;- c(1,2,3,4) &gt; x+y [1] 8 10 12 14 &gt; x-y [1] 6 6 6 6 &gt; x*y [1] 7 16 27 40 &gt; x/y [1] 7.0 4.0 3.0 2.5 &gt; x^y [1] 7 64 729 10000 두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산, 즉 첫 번째 숫자끼리 연산, 두 번째 숫자끼리 연산 등등으로 이루어진다. 벡터와 스칼라의 연산도 동일한 개념으로 수행 되어 벡터의 모든 구성요소와 스칼라와의 연산이 이루어진다. &gt; x [1] 7 8 9 10 &gt; x+3 [1] 10 11 12 13 &gt; x/4 [1] 1.75 2.00 2.25 2.50 &gt; 2^x [1] 128 256 512 1024 벡터 연산은 R의 가장 큰 강점 중 하나이다. 벡터 단위의 연산이 가능하지 않은 다른 소프 트웨어에서 R의 벡터 연산과 동일한 작업을 수행하기 위해서는 루프(loop)에 의한 반복 작업이 이루어져야 하며 이것은 프로그램의 복잡성뿐만이 아니라 처리속도에도 악영향을 미치게 된다. 벡터의 연산 결과로 나타날 수 있는 특수 기호에는 Inf, -Inf, NaN 등이 있다. Inf와 –Inf는 무한대와 마이너스 무한대를 나타내는 것이고 NaN은 ’Not a Number’를 나타내는 기호이다. &gt; c(-1,0,1)/0 [1] -Inf NaN Inf NaN은 0/0 외에도 계산을 할 수 없는 몇몇 상황에서 발생한다. &gt; sqrt(-1) Warning in sqrt(-1): NaN이 생성되었습니다 [1] NaN &gt; Inf-Inf [1] NaN &gt; Inf/Inf [1] NaN 벡터 연산의 순환법칙 R에서 두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산으로 이루어지는데, 만 일 두 벡터의 길이가 달라 일대일 대응이 되지 않는다면 어떤 일이 벌어지겠는가? 이런 경 우에는 길이가 짧은 벡터의 구성요소를 순환 반복시켜 길이가 긴 벡터의 구성요소와 짝을 짓게 된다. 예를 들어 1:6 + 1:3의 경우에는 길이가 3인 1:3을 한 번 반복시켜서 길이가 6인 c(1,2,3,1,2,3)을 만든 후 벡터 연산을 수행하게 된다. &gt; 1:6 + 1:3 [1] 2 4 6 5 7 9 &gt; 1:6 + rep(1:3,2) [1] 2 4 6 5 7 9 이와 같은 연산의 순환법칙은 비단 벡터 연산의 경우에만 국한되는 것은 아니고, 여러 다 양한 함수의 적용 과정에서도 이 순환법칙이 사용되고 있다. 앞으로 많은 경우에 있어서 순환법칙이 적용되는 상황을 보게 될 것이다. 사실 벡터와 스칼라의 연산도 순환법칙이 적 용된 결과로서 c(7,8,9,10)과 3의 덧셈은 3이 4번 반복되어 c(3,3,3,3)이 된 후 덧셈이 이루어지는 것이다. 이러한 순환법칙이 실행될 때 긴 벡터의 길이가 짧은 벡터 길이의 배수가 아니라면 짧은 벡터를 순환 반복시키더라도 긴 벡터와 길이를 동일하게 만들 수 없게 되다. 이런 경우 R은 경고 문구를 내보낸다. &gt; 1:4 + 1:3 Warning in 1:4 + 1:3: 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] 2 4 6 5 의도적으로 순환법칙을 사용하지 않은 경우에 이와 같은 경고 문구를 보게 되면 무엇이 문제인지를 면밀히 검토해보는 것이 좋을 것이다. 대부분의 경우 잘못된 연산이 수행되었을 것이다. 수학 계산 관련 함수 R에는 숫자형 벡터를 위한 다양한 함수가 있다. 먼저 기본적인 수학계산과 관련된 함수들 을 살펴보자. Table 2.2에 있는 함수들의 사용 예는 다음과 같다. Table 2.2: 수학 계산과 관련된 함수 함수 설명 abs(x) 절댓값 계산 sqrt(x) 제곱근 계산 ceiling(x) x보다 작지 않은 가장 작은 정수 floor(x) x보다 크지 않은 가장 큰 정수 trunc(x) x의 소수점 이하 버림 round(x, n) x를 소수 n자리로 반올림 signif(x, n) x를 유효수 n자리로 반올림 log(x) x의 자연로그 값 log10(x) x의 사용로그 값 exp(x) x의 지수 함수 값 &gt; abs(-2) [1] 2 &gt; sqrt(25) [1] 5 &gt; ceiling(3.475) [1] 4 &gt; floor(3.475) [1] 3 &gt; trunc(5.99) [1] 5 &gt; round(3.475,2) [1] 3.48 &gt; signif(0.00347, 2) [1] 0.0035 &gt; sin(1); cos(1); tan(1) [1] 0.841471 [1] 0.5403023 [1] 1.557408 &gt; asin(sin(1)); acos(cos(1)); atan(tan(1)) [1] 1 [1] 1 [1] 1 &gt; log(2,base=2) [1] 1 &gt; log(10) [1] 2.302585 &gt; log10(10) [1] 1 &gt; exp(log(10)) [1] 10 기초 통계 관련 함수 많이 사용되는 기초적인 통계 계산과 관련된 함수를 살펴보자. Table 2.3에 있는 함수들의 사용 예는 다음과 같다. Table 2.3: 통계 관련 함수 함수 설명 mean(x) 산술 평균값 median(x) 중앙값 range(x) 최솟값과 최댓값 IQR(x) 사분위범위 sum(x) 합 diff(x, n) 차분: x[i + n] - x[i], 시차 n의 디폴트 값은 1 min(x) 최솟값 max(x) 최댓값 &gt; x &lt;- c(1,2,3,4,50) &gt; mean(x) [1] 12 &gt; median(x) [1] 3 &gt; range(x) [1] 1 50 &gt; IQR(x) [1] 2 &gt; sd(x) [1] 21.27205 &gt; var(x) [1] 452.5 &gt; sum(x) [1] 60 &gt; min(x) [1] 1 &gt; max(x) [1] 50 &gt; diff(c(1,2,4,7,11)) [1] 1 2 3 4 결측값 데이터에는 그 규모에 관계없이 결측값이 있을 수 있다. R에서는 결측값을 기호 NA (not available)로 표시한다. 주어진 데이터에 결측값의 포함 여부를 파악하는 것은 모든 분석의 시작이라고 할 수 있으며, 함수 is.na()로 그러한 작업을 할 수 있다. &gt; x &lt;- c(1,0,3,5,NA) &gt; is.na(x) [1] FALSE FALSE FALSE FALSE TRUE 자료에 포함된 결측값의 개수는 함수 is.na()로 생성된 논리형 벡터를 함수 sum()에 입 력하면 계산할 수 있다. &gt; sum(is.na(x)) [1] 1 결측값의 포함여부를 비교 연산자를 이용하여 x == NA로 파악할 수 있을 것이라고 생각할 수도 있겠으나 결측값은 자기 자신을 포함한 어느 대상과도 비교되지 않는다. 따라서 x == NA의 결과는 모두 NA가 된다. 여기서 두 개의 등호를 연속해서 사용한 기호 ==는 벡터의 비교에 사용되는 비교 연산자로써 자세한 설명은 2.1.5절에서 찾아볼 수 있다. NA가 포함된 벡터를 수학 및 통계 관련 함수들에 적용시키면 많은 경우에 그 결과가 NA 로 출력되며 어떤 경우에는 함수의 실행이 중단되기도 한다. 이것은 R에서 NA를 중요한 요소로 인식하고 있다는 증거가 된다. 몇몇 함수의 경우 계산 과정에서 NA를 제외하고자 한다면 옵션 na.rm=TRUE를 사용해야 한다. &gt; mean(x) [1] NA &gt; max(x) [1] NA &gt; mean(x,na.rm=TRUE) [1] 2.25 &gt; max(x,na.rm=TRUE) [1] 5 2.1.5 벡터의 비교 두 벡터의 구성요소끼리 크기를 비교하거나, 혹은 벡터와 스칼라를 비교하는 작업 등은 그 자체로도 의미가 있지만 벡터의 인덱싱이나 벡터의 변환 등에서 필수적인 요소가 된다. 어느 경우든 적절한 비교를 위해서는 비교 연산자와 논리 연산자가 필요하다. Table 2.4: 비교/논리 연산자 연산자 기능 &lt; 작다 &lt;= 작거나 같다 &gt; 크다 &gt;= 크거나 같다 == 같다 != 같지 않다 !x x가 아니다 (NOT) x | y x 또는 y (OR) x &amp; y x 그리고 y (AND) R의 큰 강점 중 하나가 벡터 연산이 가능하다는 것인데 두 벡터의 비교도 벡터 연산으 로 이루어진다. 즉, 두 벡터 사이에 대응되는 구성요소끼리의 비교가 이루어지는 것이다. 따라서 3개의 숫자로 구성된 두 벡터를 비교하면 그 구성요소 각각을 비교한 3개의 TRUE 또는 FALSE가 결과로 출력된다. &gt; x &lt;- c(3,8,2) &gt; y &lt;- c(5,4,2) &gt; x &gt; y [1] FALSE TRUE FALSE &gt; x &gt;= y [1] FALSE TRUE TRUE &gt; x &lt; y [1] TRUE FALSE FALSE &gt; x &lt;= y [1] TRUE FALSE TRUE &gt; x == y [1] FALSE FALSE TRUE &gt; x != y [1] TRUE TRUE FALSE 벡터와 스칼라의 비교는 숫자 하나를 벡터의 모든 구성요소와 비교하게 되는 것으로 연산의 순환법칙이 적용된 것이다. &gt; x &lt;- 1:3 &gt; x &gt; 2 [1] FALSE FALSE TRUE &gt; x &lt; 2 [1] TRUE FALSE FALSE &gt; x &lt;= 2 | x &gt;= 3 [1] TRUE TRUE TRUE &gt; x &lt;= 2 &amp; x &gt;= 1 [1] TRUE TRUE FALSE 벡터의 비교가 이루어지면 벡터의 길이만큼의 논리형 벡터가 결과로 출력된다. 이때 만일 각 구성요소 차원의 세세한 결과보다 전체 비교 중 한 번이라도 사실이 있는지, 혹은 모든 비교가 사실인지가 중요한 결과인 경우에는 함수 any()와 all()이 유용하게 사용될 수 있다. &gt; x &lt;- 1:5 &gt; any(x&gt;=4) [1] TRUE &gt; all(x&gt;=4) [1] FALSE 주어진 벡터의 구성요소 중 특정 조건을 만족시키는 요소의 개수 혹은 비율을 알고자 하는 경우에도 논리형 벡터는 매우 유용하게 사용된다. 예를 들어 주어진 숫자형 벡터 x 중 4보다 크거나 같은 숫자의 개수와 비율은 다음과 같이 논리형 벡터를 함수 sum() 또는 mean()에 적용시켜 구할 수 있다. &gt; x &lt;- 1:5 &gt; x &gt;= 4 [1] FALSE FALSE FALSE TRUE TRUE &gt; sum(x&gt;=4) [1] 2 &gt; mean(x&gt;=4) [1] 0.4 주어진 벡터의 구성요소 중 특정한 값이 포함되어 있는지를 확인해야 하는 경우에는 %in% 연산자가 매우 유용하게 사용된다. &gt; x &lt;- 1:5 &gt; x %in% c(2,4) [1] FALSE TRUE FALSE TRUE FALSE 벡터 x의 구성요소 하나하나와 %in% 연산자 오른쪽에 주어진 값을 비교하여 같은 값이 면 TRUE, 아니면 FALSE가 생성된다. 만일 벡터 x에 c(2,4)가 포함되어 있는지 여부를 x == c(2,4)로 확인하려고 한다면 어 떤 결과가 나오는지 살펴보자. &gt; x == c(2,4) Warning in x == c(2, 4): 두 객체의 길이가 서로 배수관계에 있지 않습니다 [1] FALSE FALSE FALSE TRUE FALSE 여기에서 이루어진 작업은 길이가 다른 벡터 x와 c(2,4)에 대한 비교이다. 따라서 길이 가 짧은 벡터 c(2,4)를 순환 반복시켜서 실질적으로는 x == c(2,4,2,4,2)가 실행된 것이므로, 원하는 작업을 수행한 것이 아니다. 2.1.6 벡터의 인덱싱 벡터의 인덱싱(indexing)이란 벡터의 일부분만을 선택하는 것을 의미하는 것으로, 하나의 대괄호를 인덱싱 기호로 사용한다. 즉, x[a]의 형태가 되는데, 여기서 a는 정수형 벡터와 논리형 벡터가 사용되며, 이름이 있는 벡터의 경우에는 문자형 벡터도 가능하다. 정수형 벡터가 모두 양수인 경우에는 지정된 위치의 자료를 선택하는 것이고, 모두 음수 인 경우에는 지정된 위치의 자료를 제외하는 것이다. 양수와 음수를 혼합하여 지정할 수는 없다. &gt; y &lt;- c(2,4,6,8,10) &gt; y[c(1,3,5)] [1] 2 6 10 &gt; y[c(-2,-4)] [1] 2 6 10 같은 위치를 반복해서 지정할 수 있으며, 지정한 위치가 벡터의 길이보다 크면 지정할 자료가 없기 때문에 결측값인 NA가 출력된다. &gt; y[c(2,2,2)] [1] 4 4 4 &gt; y[0] numeric(0) &gt; y[6] [1] NA 이름이 있는 벡터의 경우에는 문자형 벡터를 사용하여 인덱싱을 할 수 있다. 벡터 pop에서 Seoul과 Suwon의 인구만을 선택해 보자. &gt; pop &lt;- c(Seoul=9930, Busan=3497, Inchon=2944, Suwon=1194) &gt; pop[c(&quot;Seoul&quot;, &quot;Suwon&quot;)] Seoul Suwon 9930 1194 논리형 벡터를 사용하는 경우에는 TRUE가 있는 위치의 자료만 선택되는데, 이러한 인덱 싱은 벡터의 비교에 따른 자료 선택에서 유용하게 사용된다. &gt; y [1] 2 4 6 8 10 &gt; y[c(TRUE,TRUE,FALSE,FALSE,TRUE)] [1] 2 4 10 &gt; y&gt;3 [1] FALSE TRUE TRUE TRUE TRUE &gt; y[y&gt;3] [1] 4 6 8 10 조건에 의한 인덱싱 논리형 벡터에 의한 인덱싱의 경우에는 TRUE인 위치의 자료가 선택된다고 하였는데, 이러한 논리형 벡터는 주로 벡터의 비교결과로 생성된다. 이것은 곧 주어진 조건을 만족시키는 요소만을 선택할 수 있다는 것을 의미한다. 벡터 x의 각 개별 값 중 벡터 x의 평균값보다 큰 값을 선택해 보자. 우선 벡터 x의 개별값과 평균값의 크기를 비교해 보자. &gt; x &lt;- c(80,88,90,93,95,94,99,78,101) &gt; x &gt;= mean(x) [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE TRUE FALSE는 작은 경우를, TRUE는 크거나 같은 경우를 나타내고 있다. 이 결과를 대괄호에 입력시키면 평균값보다 큰 개별 값들만이 선택된다. &gt; x[x &gt;= mean(x)] [1] 93 95 94 99 101 위에서 소개된 방법을 이용하여 다음의 조건을 만족시키는 개별 관찰값을 각각 선택해 보자. 평균으로부터 ±1 표준편차 안에 있는 관찰값 평균으로부터 ±1 표준편차와 ±2 표준편차 사이에 있는 관찰값 평균으로부터 ±2 표준편차를 벗어나는 관찰값 진행 절차는 우선 벡터 x를 표준화시켜 그것을 벡터 z에 할당하고 이어서 벡터 z로 각 조건을 나타내는 비교를 실시하여 그 결과를 벡터 x의 대괄호에 입력하면 된다. 평균으로 부터 ±2 표준편차를 벗어나는 관찰값은 없는 것으로 나타났다. &gt; z &lt;- (x-mean(x))/sd(x) &gt; x[abs(z) &lt;= 1] # 1 [1] 88 90 93 95 94 &gt; x[abs(z) &gt; 1 &amp; abs(z) &lt;= 2] # 2 [1] 80 99 78 101 &gt; x[abs(z) &gt; 2] # 3 numeric(0) 2.2 요인 명목형 혹은 순서형 데이터와 같은 범주형 데이터를 나타내기 위한 구조를 요인(factor)이 라고 한다. 1차원 구조를 갖고 있는 요인이 취하는 값을 수준(level)이라고 하는데, 따라서 요인은 level 속성을 가진 벡터라 할 수 있으며 데이터 분석에서 매우 중요한 역할을 하고 있다. 2.2.1 요인의 기본 특성 명목형 요인의 생성 주어진 벡터를 요인으로 변환시키는 작업은 함수 as.factor() 또는 factor()로 할 수 있다. &gt; gender &lt;- c(&quot;Male&quot;,&quot;Female&quot;,&quot;Female&quot;) &gt; gender_f &lt;- as.factor(gender) &gt; gender_f [1] Male Female Female Levels: Female Male 함수 as.factor()는 수준의 개수나 이름 등의 변화 없이 벡터를 요인으로 변환하는 작업을 수행한다. 문자형 벡터에서 요인으로 변환된 gender_f의 개별자료에는 인용부호가 없어지고 대신 level이 다음 줄에 나타나는데, 알파벳순으로 Female이 첫 번째, Male이 두 번째가 되었다. 요인이 갖고 있는 수준의 이름 등을 바꾸고자 하는 경우에는 함수 factor()을 사용해야 한다. 옵션 labels에 수준의 개수와 길이가 같은 문자형 벡터를 지정해 주면 수준의 이름이 변경된다. 예를 들어 다음의 숫자형 벡터 x를 요인으로 변환하면 숫자가 수준이 되는데, 이것에 다른 이름을 주는 방법은 다음과 같다. &gt; x &lt;- c(1, 3, 2, 2, 1, 4) &gt; factor(x) [1] 1 3 2 2 1 4 Levels: 1 2 3 4 &gt; x1 &lt;- factor(x, labels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;)) &gt; x1 [1] A C B B A D Levels: A B C D 옵션 labels에 수준의 개수만큼의 문자를 지정하였다. 만일 labels에 같은 문자를 반복해서 입력하면 요인의 수준이 합쳐지게 된다. 예를 들어 벡터 x의 네 개 수준에서 (1, 2)를 A로 합치고 (3, 4)를 B로 합쳐서 두 개 수준으로 병합하고자 한다면 다음과 같이하면 된다. &gt; x2 &lt;- factor(x, labels = c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;)) &gt; x2 [1] A B A A A B Levels: A B 함수 nlevels()과 levels()를 사용하면 요인의 수준 개수와 이름을 확인할 수 있다. &gt; levels(x1) [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &gt; levels(x2) [1] &quot;A&quot; &quot;B&quot; &gt; nlevels(x1) [1] 4 &gt; nlevels(x2) [1] 2 요인의 유형 및 속성 요인의 유형 및 속성을 확인하기 위하여 함수 typeof()와 class()를 사용해 보자. &gt; typeof(gender_f) [1] &quot;integer&quot; &gt; class(gender_f) [1] &quot;factor&quot; 함수 typeof()로 확인한 요인의 유형은 정수형 벡터이다. R 내부에서는 첫 번째 수준인 Female이 1로, 두 번째 수준인 Male이 2로 저장된다. 함수 class()는 객체가 가진 부가적인 속성 중 class 속성을 확인하는 함수인데, 이 속성은 객체 지향 프로그램에서 매우 중요한 역할을 하는 속성이다. 예를 들어 함수 summary()는 입력되는 객체의 class 속성에 따라 다른 분석을 실시하는 generic 함수 중 하나이다. 함수 summary()에 문자형 벡터 gender와 요인 gender_f를 입력시키면 각 속성에 적합한 다른 분석 결과가 출력됨을 알 수 있다. &gt; summary(gender) Length Class Mode 3 character character &gt; summary(gender_f) Female Male 2 1 순서형 요인의 생성 순서형 요인을 만들기 위해서는 함수 factor()에 order=TRUE를 포함시켜야 하고, 원하는 수준의 순서가 알파벳 순서와 다른 경우에는 옵션 level에서 사용자가 직접 지정해야 한다. &gt; income &lt;- c(&quot;Low&quot;,&quot;Medium&quot;,&quot;High&quot;,&quot;Medium&quot;) &gt; factor(income, order = TRUE) [1] Low Medium High Medium Levels: High &lt; Low &lt; Medium &gt; factor(income, order = TRUE, level = c(&quot;Low&quot;,&quot;Medium&quot;,&quot;High&quot;)) [1] Low Medium High Medium Levels: Low &lt; Medium &lt; High 2.2.2 숫자형 벡터를 요인으로 변환 통계분석과정에서 기존의 숫자형 변수를 범주형 변수로 변환시켜야 하는 경우가 종종 있는데, 시험점수(숫자형 변수)를 기반으로 특정 기준에 따라 학점(범주형 변수)을 부여하는 경우가 여기에 해당된다고 하겠다. 이러한 경우 숫자형 변수가 취할 수 있는 값의 전체 범위를 특정 기준에 따라 일정구간으로 나누고 각 구간에 개별 값이 속하면 해당 범주의 값을 갖게하면 된다. 논리형 벡터에 의한 변수 변환 예를 들어 0에서 100 사이의 값을 갖는 숫자형 벡터 x를 ‘90 이상,’ ‘90 미만 80 이상,’ ’80 미만’의 세 등분으로 구분하여 각각 A, B, C의 값을 갖는 요인 cat.x로 변환해 보자. 변환방법으로 우선 논리형 벡터를 사용하는 방법을 생각해 볼 수 있다. 조금씩 다른 세 가지 방법을 살펴보자. 각 방법 모두 세 번의 벡터 비교가 이루어졌는데, 각 괄호 안에는 비교 결과인 TRUE와 FALSE로 이루어진 논리형 벡터가 생성되며, 이 논리형 벡터들이 사칙연산에 적용되면 TRUE는 1, FALSE는 0으로 전환되는 것을 이용하였다. 첫 번째 방법에서는 90 이상의 값들이 세 번의 비교에서 모두 1의 값을 갖게 되지만 80 이상 90 미만의 값들은 두 번의 비교에서만 1의 값을 갖게 되고, 80 미만의 값들은 한 번의 비교에서만 1의 값을 갖게 되는 구조가 된다. 숫자형 벡터를 요인으로 전환하는 작업은 함 수 factor()로 수행하였다. 옵션 labels를 사용하여 1은 C, 2는 B, 3은 A로 나타내었다. &gt; x &lt;- c(80,88,90,93,95,94,100,78,65) &gt; x_1 &lt;- (x &gt;= 0) + (x &gt;= 80) + (x &gt;= 90) &gt; cat.x &lt;- factor(x_1, labels = c(&quot;C&quot;,&quot;B&quot;,&quot;A&quot;)) &gt; cat.x [1] B B A A A A A C C Levels: C B A 두 번째 방법은 첫 번째 방법과 반대 방향으로 비교가 이루어지는 것으로 80 미만은 3, 80 이상 90 미만은 2, 그리고 90 이상은 1의 값을 갖게 된다. 생성된 벡터 x_2에 대해서는 옵션 labels에 지정된 문자의 방향이 첫 번째 방법과는 반대로 되어 있다. &gt; x_2 &lt;- (x &lt;= 100) + (x &lt; 90) + (x &lt; 80) &gt; cat.x &lt;- factor(x_2, labels = c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)) &gt; cat.x [1] B B A A A A A C C Levels: A B C 세 번째 방법은 세 번의 비교가 서로 배타적인 관계가 되도록 설정한 것이다. &gt; x_3 &lt;- 1*(x &gt;= 0 &amp; x &lt; 80) + 2*(x &gt;= 80 &amp; x &lt; 90) + 3*(x &gt;= 90) &gt; cat.x &lt;- factor(x_3, labels = c(&quot;C&quot;,&quot;B&quot;,&quot;A&quot;)) &gt; cat.x [1] B B A A A A A C C Levels: C B A 함수 cut()에 의한 변수 변환 연속형 벡터를 요인으로 전환하는 작업은 함수 cut()을 사용하면 비교적 간단하게 할 수 있다. 함수 cut()의 옵션으로 breaks에는 최솟값과 최댓값을 포함하여 전체 구간을 원하는 그룹으로 구분하는 벡터가 입력되며, right에는 설정된 구간이 오른쪽으로 닫힌 것이면 (a &lt; x ≤ b) TRUE, 왼쪽으로 닫힌 것이면 (a ≤ x &lt; b) FALSE가 입력되고, include.lowest에는 개별 값이 전체 구간의 최솟값(또는 최댓값, right=FALSE의 경우)과 같아도 변환에 포함시 킬 것(TRUE)인지 아닌지(FALSE)를 지정하게 된다. 옵션 right의 디폴트는 TRUE이고, 옵션 include.lowest의 디폴트는 FALSE이다. 요인 수준의 라벨은 옵션 labels로 지정할 수 있다. &gt; cat.x &lt;- cut(x, breaks=c(0,80,90,100), include.lowest=TRUE, + right=FALSE, labels=c(&quot;C&quot;,&quot;B&quot;,&quot;A&quot;)) &gt; cat.x [1] B B A A A A A C C Levels: C B A 옵션 include.lowest를 따로 지정하지 않고 디폴트 값을 그대로 사용하고자 한다면 옵션 break에 최솟값은 -Inf로, 최댓값은 Inf로 지정하면 된다. &gt; cut(x, breaks=c(-Inf,80,90,Inf), + right=FALSE, labels=c(&quot;C&quot;,&quot;B&quot;,&quot;A&quot;)) [1] B B A A A A A C C Levels: C B A 순서형 요인을 원한다면 옵션 ordered_result=TRUE를 입력해야 한다. &gt; cut(x, breaks=c(-Inf,80,90,Inf), + right=FALSE, labels=c(&quot;C&quot;,&quot;B&quot;,&quot;A&quot;), + ordered_result=TRUE) [1] B B A A A A A C C Levels: C &lt; B &lt; A 2.3 날짜 시간의 흐름에 따라 데이터를 얻는 경우, 날짜는 중요한 변수가 된다. 날짜를 만드는 방법 은 문자형 벡터에 함수 as.Date()를 적용하면 된다. 입력되는 문자형 벡터의 디폴트 형태는 yyyy-mm-dd가 된다. &gt; x &lt;- as.Date(c(&quot;2017-01-01&quot;,&quot;2018-01-01&quot;)) &gt; x [1] &quot;2017-01-01&quot; &quot;2018-01-01&quot; 출력된 날짜는 문자형 벡터로 보이지만, 사실은 숫자형 벡터로 1970년 1월 1일부터의 날수로 저장되며, 따라서 날짜를 대상으로 사칙연산을 할 수 있다. &gt; typeof(x) [1] &quot;double&quot; &gt; x[2]-x[1] Time difference of 365 days 날짜의 class 속성은 Date이다. &gt; class(x) [1] &quot;Date&quot; 일정한 간격의 날짜를 만들고자 한다면 함수 seq()를 사용하는 것이 좋다. 예를 들어 2018년 3월 1일부터 3월 31까지의 기간 동안 7일 간격의 날짜를 구해 보자. &gt; s1 &lt;- as.Date(&quot;2018-03-01&quot;) &gt; e1 &lt;- as.Date(&quot;2018-03-31&quot;) &gt; seq(from = s1, to = e1, by = 7) [1] &quot;2018-03-01&quot; &quot;2018-03-08&quot; &quot;2018-03-15&quot; &quot;2018-03-22&quot; &quot;2018-03-29&quot; 증가 폭을 일 단위가 아닌 주 단위 혹은 월 단위로 하는 것도 가능하다. &gt; seq(from = s1, by = &quot;week&quot;, length = 5) [1] &quot;2018-03-01&quot; &quot;2018-03-08&quot; &quot;2018-03-15&quot; &quot;2018-03-22&quot; &quot;2018-03-29&quot; &gt; seq(from = s1, by = &quot;month&quot;, length = 5) [1] &quot;2018-03-01&quot; &quot;2018-04-01&quot; &quot;2018-05-01&quot; &quot;2018-06-01&quot; &quot;2018-07-01&quot; &gt; seq(from = s1, by = &quot;year&quot;, length = 5) [1] &quot;2018-03-01&quot; &quot;2019-03-01&quot; &quot;2020-03-01&quot; &quot;2021-03-01&quot; &quot;2022-03-01&quot; 2.4 행렬 및 배열 1차원 구조인 벡터에 부가적인 속성 중 하나인 dim이 추가되면 이차원 구조인 행렬이나, 다차원 구조인 배열이 된다. 따라서 행렬과 배열도 구성요소는 모든 동일한 유형(논리형, 숫자형, 문자형)이어야 한다 2.4.1 행렬과 배열의 기본 특성 행렬의 생성 행렬은 함수 matrix()로 만들 수 있다. 행렬로 전환될 벡터를 먼저 입력하고 이어서 행과 열의 개수를 nrow=와 ncol=로 지정할 수 있다. 벡터가 먼저 입력되어 행렬을 구성하 는 요소의 전체 개수가 주어진 상태이므로, nrow 혹은 ncol 둘 중 하나만 사용해도 된다. &gt; x &lt;- matrix(1:12, nrow = 3) &gt; x [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 위의 예에서 자료는 열 단위로 채워졌는데, 이것을 행 단위로 채우려면 byrow=TRUE를 지정하면 된다 &gt; y &lt;- matrix(1:12, nrow = 3, byrow = TRUE) &gt; y [,1] [,2] [,3] [,4] [1,] 1 2 3 4 [2,] 5 6 7 8 [3,] 9 10 11 12 행렬의 생성에 유용하게 사용되는 또 다른 함수로 cbind()와 rbind()가 있다. 함수 cbind()는 기존의 벡터들을 열 단위로 묶어서 행렬을 만들 때 사용할 수 있고, 함수 rbind()는 벡터들을 행 단위로 묶어서 행렬을 구성할 때 사용할 수 있다. &gt; x1 &lt;- 1:3 &gt; x2 &lt;- 4:6 &gt; (A &lt;- cbind(x1,x2)) x1 x2 [1,] 1 4 [2,] 2 5 [3,] 3 6 &gt; (B &lt;- rbind(x1,x2)) [,1] [,2] [,3] x1 1 2 3 x2 4 5 6 기존의 행렬에 열 또는 행을 추가하는 경우에도 함수 cbind()와 rbind()를 사용할 수 있다. &gt; cbind(A, x3 = 7:9) x1 x2 x3 [1,] 1 4 7 [2,] 2 5 8 [3,] 3 6 9 &gt; rbind(A, 7:8) x1 x2 [1,] 1 4 [2,] 2 5 [3,] 3 6 [4,] 7 8 함수 cbind()와 rbind()를 사용할 때 결합 대상이 되는 벡터들의 길이가 서로 다르면 순환법칙이 적용된다. 다음 예에서 벡터 x2는 한 번, x3는 세 번 반복되어 x1과 길이를 맞춘 후 결합이 진행된다. &gt; x1 &lt;- 1:4 &gt; x2 &lt;- 5:6 &gt; x3 &lt;- 7 &gt; cbind(x1,x2,x3) x1 x2 x3 [1,] 1 5 7 [2,] 2 6 7 [3,] 3 5 7 [4,] 4 6 7 또한 벡터에 함수 dim()으로 dim 속성을 부가하면, 벡터가 행렬이나 배열로 변환된다. &gt; x &lt;- 1:12 &gt; dim(x) &lt;- c(3,4) &gt; x [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 행렬의 행과 열에 이름을 붙일 수 있는데, 이것은 함수 rownames()와 colnames()로 할 수 있다. &gt; rownames(x) &lt;- c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;) &gt; colnames(x) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) &gt; x a b c d one 1 4 7 10 two 2 5 8 11 three 3 6 9 12 행렬의 경우에는 자료 전체의 개수보다는 행 또는 열의 개수가 더 중요한 정보가 된다. 따라서 함수 length()보다는 함수 nrow(), ncol() 혹은 dim()의 사용이 더 적절할 것이다. &gt; length(x) [1] 12 &gt; nrow(x) [1] 3 &gt; ncol(x) [1] 4 &gt; dim(x) [1] 3 4 배열의 생성 배열은 함수 array()로 만들 수 있다. 배열은 다차원 구조이므로 각 차원에 대한 정의가 함수 array() 안에 포함되어야 한다. &gt; y &lt;- array(1:24, c(4,3,2)) &gt; y , , 1 [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 10 [3,] 3 7 11 [4,] 4 8 12 , , 2 [,1] [,2] [,3] [1,] 13 17 21 [2,] 14 18 22 [3,] 15 19 23 [4,] 16 20 24 각 차원에 대한 이름은 함수 dimnames()로 붙일 수 있는데, 문자형 벡터들로 이루어진 리스트를 할당해야 한다. &gt; dimnames(y) &lt;- list(X=c(&quot;x1&quot;,&quot;x2&quot;,&quot;x3&quot;,&quot;x4&quot;),Y=c(&quot;y1&quot;,&quot;y2&quot;,&quot;y3&quot;), + Z=c(&quot;z1&quot;,&quot;z2&quot;)) &gt; y , , Z = z1 Y X y1 y2 y3 x1 1 5 9 x2 2 6 10 x3 3 7 11 x4 4 8 12 , , Z = z2 Y X y1 y2 y3 x1 13 17 21 x2 14 18 22 x3 15 19 23 x4 16 20 24 행렬과 배열의 인덱싱 벡터의 경우와 동일하게 행렬에서도 자료의 일부분을 선택하는 인덱싱은 매우 중요한 작업이다. 이 경우에도 대괄호가 사용되는데 행렬 x의 i번째 행, j번째 열에 있는 값은 x[i,j]로, i번째 행은 x[i,]로, j번째 열은 x[,j]로 나타낸다. &gt; x &lt;- matrix(1:12, nrow = 3) &gt; x [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 [3,] 3 6 9 12 &gt; x[2,3] [1] 8 &gt; x[1,] [1] 1 4 7 10 &gt; x[,2] [1] 4 5 6 &gt; x[1:2,] [,1] [,2] [,3] [,4] [1,] 1 4 7 10 [2,] 2 5 8 11 &gt; x[1:2, 3:4] [,1] [,2] [1,] 7 10 [2,] 8 11 배열의 인덱싱도 대괄호가 사용되며, 차원 수만큼의 첨자가 필요하다. 다음은 3차원 배열에 대한 인덱싱 예제이다. &gt; y &lt;- array(1:24, c(4,3,2)) &gt; y[,1,1] [1] 1 2 3 4 &gt; y[,,1] [,1] [,2] [,3] [1,] 1 5 9 [2,] 2 6 10 [3,] 3 7 11 [4,] 4 8 12 2.4.2 행렬의 연산 행렬의 연산은 선형대수 문제뿐만이 아니라 다양한 통계분석을 진행하는 과정에서 종종 사용된다. Table 2.5에는 행렬의 연산에서 중요하게 사용되는 함수 및 연산자들이 정리되어있다. 표에서 A와 B는 행렬을, x와 b는 벡터를, 그리고 k는 스칼라를 의미한다. Table 2.5: 행렬의 연산에 유용하게 사용되는 함수 및 연산자 연산자 및 함수 기능 + - * / ^ 행렬을 구성하는 숫자 각각에 적용 A %*% B 행렬 A와 B의 곱하기 colMeans(A) 행렬 A 각 열의 평균값으로 구성된 벡터 colSums(A) 행렬 A 각 열의 합으로 구성된 벡터 diag(A) 행렬 A의 대각선 원소로 구성된 벡터 diag(x) 벡터 x를 대각선 원소로 하는 대각행렬 diag(k) k * k 단위행렬 eigen(A) 행렬 A의 고유값과 고유벡터로 구성된 리스트 rowMeans(A) 행렬 A 각 행의 평균값으로 구성된 벡터 rowSums(A) 행렬 A 각 행의 합으로 구성된 벡터 solve(A) 행렬 A의 역행렬 solve(A, b) 연립방정식 Ax=b의 해 t(A) 행렬 A의 전치 다음은 행렬 연산에 대한 이해를 돕기 위해 몇몇 함수 및 연산자들에 대한 간단한 사용 예를 보인 것이다. &gt; (A &lt;- matrix(1:4, 2, byrow = TRUE)) [,1] [,2] [1,] 1 2 [2,] 3 4 &gt; (B &lt;- matrix(5:8, 2, byrow = TRUE)) [,1] [,2] [1,] 5 6 [2,] 7 8 &gt; A * B [,1] [,2] [1,] 5 12 [2,] 21 32 &gt; A %*% B [,1] [,2] [1,] 19 22 [2,] 43 50 &gt; t(A) [,1] [,2] [1,] 1 3 [2,] 2 4 &gt; cbind(A,B) [,1] [,2] [,3] [,4] [1,] 1 2 5 6 [2,] 3 4 7 8 &gt; rbind(A,B) [,1] [,2] [1,] 1 2 [2,] 3 4 [3,] 5 6 [4,] 7 8 &gt; colMeans(A) [1] 2 3 &gt; rowSums(A) [1] 3 7 &gt; diag(A) [1] 1 4 &gt; x &lt;- c(10,20) &gt; diag(x) [,1] [,2] [1,] 10 0 [2,] 0 20 &gt; diag(2) [,1] [,2] [1,] 1 0 [2,] 0 1 &gt; solve(A) [,1] [,2] [1,] -2.0 1.0 [2,] 1.5 -0.5 &gt; solve(A)%*%A [,1] [,2] [1,] 1 4.440892e-16 [2,] 0 1.000000e+00 &gt; b &lt;- c(5,6) &gt; solve(A,b) [1] -4.0 4.5 2.5 데이터 프레임 데이터 세트는 행과 열의 2차원 구조를 갖고 있으며, 하나의 열에는 같은 유형의 자료만이 올 수 있으나, 각각의 열은 서로 다른 유형의 자료를 가질 수 있는 구조이다. 이러한 통계 데이터 세트를 위한 데이터 객체가 바로 데이터 프레임이다. 따라서 가장 빈번하게 사용되는 데이터 객체가 된다. 2.5.1 데이터 프레임의 생성 함수 data.frame()에 이름을 붙인 벡터를 차례로 입력함으로써 데이터 프레임을 만들 수 있다. 벡터 x와 y가 데이터 프레임 df1의 열(변수)이 되었고, 행 번호가 자동으로 붙은 것을 알 수 있다. &gt; df1 &lt;- data.frame(x = c(2,4,6), y = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) &gt; df1 x y 1 2 a 2 4 b 3 6 c 이 때 입력하는 벡터의 길이는 반드시 같아야 한다. &gt; data.frame(x = c(2,4), y = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) Error in data.frame(x = c(2, 4), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): arguments imply differing number of rows: 2, 3 길이가 1인 벡터의 경우에는 순환 법칙이 적용되어 길이가 긴 벡터의 길이만큼 반복되어 입력된다. &gt; data.frame(x = 1, y = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)) x y 1 1 a 2 1 b 3 1 c 함수 str()은 데이터 객체의 특성을 살펴볼 수 있는 함수이다. 함수 str()을 이용하여 데이터 프레임 df1의 특성을 살펴보자. 관찰값(행)과 변수(열)의 개수가 표시되고 각 변수의 이름과 유형 및 자료의 처음 몇 개의 값이 출력된다. &gt; str(df1) &#39;data.frame&#39;: 3 obs. of 2 variables: $ x: num 2 4 6 $ y: chr &quot;a&quot; &quot;b&quot; &quot;c&quot; 데이터 프레임은 행렬과 같이 2차원 구조여서 함수 rownames()와 colnames()의 역할은 행렬과 동일하다. 다만 데이터 프레임에서는 함수 names()가 함수 colnames()와 같은 역할을 하고 있으며, 함수 length()도 전체 데이터의 개수가 아닌 열의 개수, 즉 변수의 개수를 구한다. &gt; colnames(df1) [1] &quot;x&quot; &quot;y&quot; &gt; names(df1) [1] &quot;x&quot; &quot;y&quot; &gt; rownames(df1) [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &gt; length(df1) [1] 2 2.5.2 데이터 프레임의 인덱싱 함수 typeof()로 확인할 수 있는 데이터 프레임의 유형은 리스트이다. &gt; typeof(df1) [1] &quot;list&quot; 따라서 리스트에 적용되는 인덱싱 방법을 사용할 수 있다. 또한 데이터 프레임은 행렬과 같이 2차원 구조를 갖고 있기 때문에 행렬에 적용되는 인덱싱 방법도 사용할 수도 있다. 리스트에서는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호를 인덱싱 기호로 사용하고 있다. 즉, df1[a] 또는 df1[[a]]의 형태가 된다. 데이터 프레임에 이 방식을 적용하면, 데이터 프레임을 구성하고 있는 열, 즉 변수 중 일부분을 선택할 수 있다. 대괄호 안에 들어가는 벡터 a는 숫자형 또는 문자형이 되는데, 숫자형인 경우에는 선택할 열의 위치를, 문자형인 경우에는 선택할 열의 이름을 지정하면 된다. 하나의 대괄호 기호와 겹쳐진 두 개의 대괄호 기호의 차이는 선택된 객체의 구조인데, 하나의 대괄호 기호로 선택한 결과는 항상 데이터 프레임이 되고, 겹쳐진 두 개의 대괄호 기호로 선택한 결과는 항상 벡터가 된다. 따라서 여러 변수를 선택할 때에는 하나의 대괄호 기호를 사용해야 한다. &gt; df1[1] x 1 2 2 4 3 6 &gt; df1[[1]] [1] 2 4 6 &gt; df1[&quot;x&quot;] x 1 2 2 4 3 6 &gt; df1[[&quot;x&quot;]] [1] 2 4 6 데이터 프레임을 대상으로 통계분석을 할 때에는 분석 대상이 되는 개별 변수를 벡터 형태로 선택하는 경우가 많다. 따라서 df1[[“x”]]의 형태가 자주 사용되는데, 이것을 조금 더 편리하게 하는 방식이 $ 기호의 사용이다. 즉 df1[[“x”]]은 df1$x와 동일하다. &gt; df1$x [1] 2 4 6 데이터 프레임도 행렬과 같은 2차원 구조이므로 행렬의 인덱싱 방법을 동일하게 적용할 수 있다. 이 경우에는 선택한 변수의 개수에 따라 결과 객체의 구조가 결정되는데, 선택한 변수가 하나이면 벡터가 되고 두 개 이상이면 데이터 프레임이 된다. &gt; df1[,1] [1] 2 4 6 &gt; df1[1,] x y 1 2 a &gt; df1[c(1,2),] x y 1 2 a 2 4 b 2.5.3 함수 with() 데이터 프레임의 개별 변수를 벡터 형태로 선택할 때 겹쳐진 두 개의 대괄호 기호 또는 $ 기호를 사용하여 개별 변수를 선택할 수 있다. 그러나 이러한 방법은 변수를 선택할 때 마다 데이터 프레임의 이름을 함께 입력해야 하는 번거로운 방법이기도 하다. 데이터 프레임이라는 것이 가장 빈번하게 사용되는 구조의 데이터 객체이기 때문에 조금 더 편하게 변수에 접근할 수 있는 방법이 필요한데, 이러한 경우에 사용할 수 있는 함수가 바로 with() 이다. 함수 with()의 일반적인 사용 형태는 with(데이터 프레임, R 명령문)으로, 함수 with() 안에서는 지정된 데이터 프레임에 속한 변수를 인덱싱 기법 없이 그냥 사용할 수 있다. 데이터 프레임 airquality는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의 질과 관련된 몇몇 변수들로 이루어진 데이터 프레임이다. 처음 3개 케이스를 출력해 보자. &gt; head(airquality, n = 3) Ozone Solar.R Wind Temp Month Day 1 41 190 7.4 67 5 1 2 36 118 8.0 72 5 2 3 12 149 12.6 74 5 3 데이터 프레임 airquality에 있는 변수 Temp를 표준화시켜보자. 변수 Temp는 데이터 프레임 airquality의 열 벡터이기 때문에 인덱싱 기법을 사용하지 않은 상태에서는 R이 변수 Temp를 찾지 못한다. 따라서 다음에 주어진 첫 번째 문장에서 오류가 발생한 것이다. 두 번째 문장이 데이터 프레임의 인덱싱이 사용된 방법인데, 데이터 프레임의 이름을 여러 번 입력해야 한다는 것이 번거로운 작업이 될 수 있다. 세 번째에서는 함수 with() 안에 airquality를 한 번만 선언하고 이어지는 R 명령문에서는 변수 이름만을 사용하여 표준화 과정을 실행시켰다. 두 번째와 세 번째 명령문의 실행 결과는 당연히 동일하며, 더 간편한 방법을 선택하는 것이 좋을 것이다. &gt; z.Temp &lt;- (Temp - mean(Temp))/sd(Temp) Error in eval(expr, envir, enclos): 객체 &#39;Temp&#39;를 찾을 수 없습니다 &gt; z.Temp &lt;- (airquality$Temp - mean(airquality$Temp))/sd(airquality$Temp) &gt; z.Temp &lt;- with(airquality, (Temp - mean(Temp))/sd(Temp)) 2.6 Tibble: 개선된 형태의 데이터 프레임 Tibble은 tidyverse에 속한 패키지들이 공통적으로 사용하는 개선된 형태의 데이터 프레임이다. 기존의 데이터 프레임에 몇 가지 기능을 추가함으로써 조금 더 사용하기 편리한 형태를 취하고 있다. Tibble과 관련된 작업을 하기 위해서는 패키지 tibble을 불러와야 하는데, Core tidyverse에 속한 패키지이므로 library(tidyverse)를 실행하면 다른 core tidyverse패키지들과 함께 세션에 올라오게 된다. &gt; library(tidyverse) -- Attaching packages --------------------------------------- tidyverse 1.3.1 -- v ggplot2 3.3.5 v purrr 0.3.4 v tibble 3.1.6 v stringr 1.4.0 v tidyr 1.1.4 v forcats 0.5.1 v readr 2.1.1 -- Conflicts ------------------------------------------ tidyverse_conflicts() -- x dplyr::filter() masks stats::filter() x dplyr::lag() masks stats::lag() 2.6.1 Tibble 생성 기존의 전통적인 데이터 프레임을 tibble로 전환하기 위해서는 함수 as_tibble()을 사용하면 된다. &gt; as_tibble(cars) # A tibble: 50 x 2 speed dist &lt;dbl&gt; &lt;dbl&gt; 1 4 2 2 4 10 3 7 4 4 7 22 5 8 16 6 9 10 7 10 18 8 10 26 9 10 34 10 11 17 # ... with 40 more rows 앞 절에서 살펴보았던 전통적인 데이터 프레임의 출력 형태와는 많이 다른 모습을 보이고있다. 개별 벡터를 이용한 tibble의 생성은 함수 tibble()로 할 수 있다. 길이가 1인 스칼라는 순환법칙이 적용되며, 함께 입력된 변수를 이용하여 다른 변수를 만들 수 있다. &gt; tibble(x = 1:3, y = x + 1, z = 1) # A tibble: 3 x 3 x y z &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; 1 1 2 1 2 2 3 1 3 3 4 1 함께 입력되는 변수를 이용하여 다른 변수를 만들 수 있는 기능은 매우 유용하게 사용될 수 있는데, 함수 data.frame()에서는 가능하지 않던 것이다. &gt; data.frame(x = 1:3, y = x+1) Error in data.frame(x = 1:3, y = x + 1): arguments imply differing number of rows: 3, 2 함수 tibble()에서는 열(변수) 단위로 자료를 입력해야 했는데, 경우에 따라서 행 단위로 입력하는 것이 더 편리할 때가 있다. 이런 경우에는 함수 tribble()을 사용해야 한다. 첫 줄의 변수 이름은 기호 ~으로 시작되는 공식으로 정의되며, 각 자료는 콤마로 구분된다. &gt; tibble(x = 1:3, y = letters[1:3]) # A tibble: 3 x 2 x y &lt;int&gt; &lt;chr&gt; 1 1 a 2 2 b 3 3 c 2.6.2 Tibble과 전통적인 데이터 프레임의 차이 Tibble과 전통적인 데이터 프레임은 출력 방식과 자료의 부분을 선택하는 인덱싱 방식에서 차이가 있으며 행 이름(row name)를 다루는 방식에서도 차이가 있다. 출력 방식의 차이 먼저 출력 방식에서 보면 전통적인 데이터 프레임은 대규모 데이터를 대상으로 하는 경우에 불편한 측면이 있다. 전통적 데이터 프레임은 가능한 모든 자료를 화면에 출력하게 되어 있는데, 이런 출력 방식은 대규모 자료의 경우 내용을 확인하기 매우 어려운 측면이 있다. 이에 반하여 tibble은 처음 10개 케이스만을 출력하며, 변수도 화면의 크기에 따라 출력되 는 개수를 조절하여, 한 화면에서 자료의 특성을 비교적 편하게 확인할 수 있다. &gt; as_tibble(MASS::Cars93) # A tibble: 93 x 27 Manufacturer Model Type Min.Price Price Max.Price MPG.city MPG.highway &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; 1 Acura Integra Small 12.9 15.9 18.8 25 31 2 Acura Legend Midsi~ 29.2 33.9 38.7 18 25 3 Audi 90 Compa~ 25.9 29.1 32.3 20 26 4 Audi 100 Midsi~ 30.8 37.7 44.6 19 26 5 BMW 535i Midsi~ 23.7 30 36.2 22 30 6 Buick Century Midsi~ 14.2 15.7 17.3 22 31 7 Buick LeSabre Large 19.9 20.8 21.7 19 28 8 Buick Roadmaster Large 22.6 23.7 24.9 16 25 9 Buick Riviera Midsi~ 26.3 26.3 26.3 19 27 10 Cadillac DeVille Large 33 34.7 36.3 16 25 # ... with 83 more rows, and 19 more variables: AirBags &lt;fct&gt;, # DriveTrain &lt;fct&gt;, Cylinders &lt;fct&gt;, EngineSize &lt;dbl&gt;, Horsepower &lt;int&gt;, # RPM &lt;int&gt;, Rev.per.mile &lt;int&gt;, Man.trans.avail &lt;fct&gt;, # Fuel.tank.capacity &lt;dbl&gt;, Passengers &lt;int&gt;, Length &lt;int&gt;, Wheelbase &lt;int&gt;, # Width &lt;int&gt;, Turn.circle &lt;int&gt;, Rear.seat.room &lt;dbl&gt;, Luggage.room &lt;int&gt;, # Weight &lt;int&gt;, Origin &lt;fct&gt;, Make &lt;fct&gt; 변수 이름과 더불어 변수의 유형을 바로 밑 줄에 표시하고 있으며, 화면 크기 때문에 자료가 출력되지 않은 변수는 이름과 유형을 가장 밑에 나열해 두었다. 만일 조금 더 많은 자료를 확인하고자 한다면 함수 print()를 옵션과 함께 사용하면 된다. 예를 들어 처음 20개 케이스와 모든 변수를 다 출력하고자 한다면 다음과 같이 옵션 n = 20과 width = Inf를 사용한다. &gt; print(as_tibble(MASS::Cars93), n = 20, width = Inf) 행 이름 처리 방식의 차이 자료가 출력될 때 전통적인 데이터 프레임의 경우에는 행 이름이 함께 출력되지만, tibble에서는 생략이 된다. 데이터 프레임 mtcars를 출력해 보자. &gt; head(mtcars) mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 &gt; mtcars_t &lt;- as_tibble(mtcars) &gt; print(mtcars_t, n = 6) # A tibble: 32 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 # ... with 26 more rows 생략된 행 이름은 함수 rownames_to_column()을 사용하면 변수로 전환할 수 있다. &gt; mtcars_d &lt;- rownames_to_column(mtcars, var=&quot;rowname&quot;) &gt; mtcars_t &lt;- as_tibble(mtcars_d) &gt; mtcars_t # A tibble: 32 x 12 rowname mpg cyl disp hp drat wt qsec vs am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 ~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 Hornet 4 D~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 Hornet Spo~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # ... with 22 more rows 인덱싱 방법의 차이 데이터 프레임의 일부분을 선택하는 인덱싱 기법은 tibble에서도 동일하게 적용된다. 한 가지 차이점은 기호 $을 이용하는 경우인데, 데이터 프레임에서는 변수이름이 부분 매칭만 되어도 선택되지만, tibble에서는 엄격한 기준이 적용되어 변수의 전체 이름을 다 사용해야 선택된다. &gt; df1 &lt;- data.frame(xyz = 1:3, abc = letters[1:3]) &gt; df1$x [1] 1 2 3 &gt; &gt; tb1 &lt;- as_tibble(df1) &gt; tb1$x Warning: Unknown or uninitialised column: `x`. NULL &gt; tb1$xyz [1] 1 2 3 흔한 상황은 아니지만, 만일 tibble을 입력했을 때 처리를 못하는 함수가 있다면, tibble을 전통적인 데이터 프레임으로 전환해야 한다. 데이터 프레임으로의 전환은 함수 as.data.frame()을 사용하면 된다. 이러한 전환이 필요한 상황 중 하나는 대괄호를 이용하여 행렬 방식으로 인덱싱을 실시하는 경우이다. 전통적 데이터 프레임의 경우 행렬 방식으로 자료를 부분 선택할 때 선택된 변수가 두 개 이상이면 데이터 프레임이 유지되지만, 선택된 변수가 한 개라면 벡터가 된다. 즉, mtcars[,1:2]는 데이터 프레임이지만 mtcars[,1]은 벡터가 된다는 것이다. 반면에 tibble의 경우에는 선택되는 변수의 개수와 관계 없이 그대로 tibble 속성이 유지가 된다. 따라서 mtcars_t[,1:2]와 mtcars_t[,1] 모두 tibble이며, mtcars_t[1,1]도 tibble 속성을 그대로 유지하고 있다. 따라서 데이터 프레임에서 행렬 방식으로 하나의 변수를 선택했을 때 벡터가 되어야 작동이 되는 경우라면 tibble을 사용해서는 안 되는 상황이 되는 것이다. 2.7 리스트 리스트는 R에서 가장 포괄적인 형태의 데이터 구조이다. 그 구성요소로서 벡터, 배열, 데이터 프레임, 함수, 다른 리스트 등이 될 수 있는, 한마디로 여러 다른 유형의 객체들을 하부 구조로 하여 한데 묶은 또 다른 객체라고 할 수 있다. 리스트의 생성 리스트는 함수 list()로 만들 수 있다. 문자형 벡터, 숫자형 벡터, 데이터 프레임과 다른 리스트로 이루어진, 리스트 x를 만들어보자. &gt; x &lt;- list(a = c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;), b = 1:3, c = list(-1,-5), + d = data.frame(x1 = c(&quot;s1&quot;,&quot;s2&quot;), x2 = 1:2)) &gt; x $a [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; $b [1] 1 2 3 $c $c[[1]] [1] -1 $c[[2]] [1] -5 $d x1 x2 1 s1 1 2 s2 2 리스트의 인덱싱 리스트의 인덱싱 기호는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호이다. 대괄호 하나를 사용하여 선택하면 원래의 구조가 그대로 유지되어 항상 리스트가 되고, 겹쳐진 두 개의 대괄호를 사용하면 해당되는 구성요소의 객체 구조가 된다. 즉, x[1]은 x의 첫 번째 구성 요소인 문자형 벡터 하나로만 이루어진 리스트가 되며, x[[1]]은 x의 첫 번째 구성요소인 문자형 벡터가 된다. &gt; x[1] $a [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &gt; x[[1]] [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &gt; str(x[1]) List of 1 $ a: chr [1:3] &quot;one&quot; &quot;two&quot; &quot;three&quot; &gt; str(x[[1]]) chr [1:3] &quot;one&quot; &quot;two&quot; &quot;three&quot; 따라서 x[[4]]는 네 번째 구성요소인 데이터 프레임이 되는 것이며, x[[4]][2]은 해당 데이터 프레임의 두 번째 열만으로 구성된 데이터 프레임이 되고, x[[4]][[2]]는 숫자형 벡터가 된다. &gt; x[[4]] x1 x2 1 s1 1 2 s2 2 &gt; x[[4]][2] x2 1 1 2 2 &gt; x[[4]][[2]] [1] 1 2 데이터 프레임의 경우와 같이 리스트에서도 $ 기호를 사용하여 인덱싱을 할 수 있다. 즉, x$a는 x[[\"a\"]]와 같은 것이며, 따라서 x$a[1:2]는 x[[\"a\"]][1:2]와 같은 것이다. &gt; x$a [1] &quot;one&quot; &quot;two&quot; &quot;three&quot; &gt; x$a[1:2] [1] &quot;one&quot; &quot;two&quot; 리스트는 매우 중요한 구조 형태인데, 그것은 산만하게 흩어져 있는 정보들을 간편하게 묶을 수 있다는 장점과 대부분의 R 함수들이 실행결과를 리스트의 형태로 생성하기 때문이다. 앞으로 많은 예제를 통하여 R 함수들의 실행결과로 생성되는 리스트를 볼 수 있을 것이다. 리스트로 생성된 결과물 중 우리가 원하는 결과는 대부분의 경우 그 일부분이 될 것이기 때문에 리스트의 인덱싱 기법을 사용하여 적절하게 선택해야 할 것이다. 2.8 연습문제 데이터 프레임 iris는 세 가지 종류 붓꽃 setosa , versicolor , virginica의 꽃잎과 꽃받침의 길이와 폭을 측정한 자료이다. 각 종류별로 50송이를 측정하여 처음 50개 행에는 setosa, 51부터 100번째 행에는 versicolor, 마지막 50개 행에는 viginica의 측정값이 입력되어 있다. iris의 1~3 행 51~53 행 101~103 행을 다음과 같이 출력해 보자. iris의 변수 Sepal.Length, Sepal.Width, Petal.Length, Petal.Width에는 꽃잎과 꽃받침의 길이와 폭을 측정한 결과가 입력되어 있다. 세 가지 붓꽃 종류별로 네 변수의 평균값을 각각 계산해 보자 150송이 중 Petal.Width의 값이 1 이하이고 Petal.Length가 4 이하인 붓꽃이 모두 몇 송이가 있는지 알아보자. 또한 세 종류의 붓꽃별로는 각각 몇 송이가 있는지 알아보자. 데이터 프레임 mtcars는 1974년에 발행된 어떤 잡지에 소개된 32대 자동차의 연비와 관련된 자료이다. 숫자형 변수 mpg에 대한 다음의 조건으로 요인 grade를 생성해 보자. 단, \\(\\bar{x}\\)와 \\(sd\\)는 변수 mpg의 평균 및 표준편차이다. mtcars의 행 이름을 데이터 프레임에 변수 이름 model로 추가해 보자 요인 grade가 Excellent인 자동차의 변수 model과 mpg의 값을 출력해 보자. 요인 grade가 Bad인 자동차들의 평균 mpg 값을 계산해 보자. "],["데이터-입력.html", "Chapter 3 데이터 입력 3.1 텍스트 파일 불러오기: 패키지 readr 함수의 활용 3.2 Excel 파일 불러오기 3.3 SAS 데이터 파일 불러오기 3.4 HTML 테이블 불러오기", " Chapter 3 데이터 입력 2장에서는 다양한 R 데이터 객체에 대해 살펴보았다. 지금부터는 모든 통계분석 및 그래프 작성의 첫 단계라고 할 수 있는 데이터 입력 방법에 대해 살펴보자. R은 텍스트 파일, 다른 통계 소프트웨어 전용 데이터 파일, Excel 파일 및 HTML 테이블 등 다양한 유형의 데이터 파일을 비교적 간단하게 불러올 수 있다. 3.1 텍스트 파일 불러오기: 패키지 readr 함수의 활용 많은 경우에 데이터 파일은 텍스트 파일의 형태로 저장되어 있다. 통계 데이터 세트는 행과 열의 2차원 형태로 구성되는데, 입력 형식은 매우 다양할 수 있다. 즉, 각각의 자료들이 빈칸으로 구분된 경우, 콤마로 구분된 경우, 고정 포맷 구조로 구성된 경우 등이 있게 된다. 따라서 이렇게 각기 다른 구성 형식의 텍스트 파일을 불러오는데 적합한 함수가 필요한 것이다. 외부 텍스트 파일을 불러오는 작업은 base R 함수인 read.table() 또는 read.csv()로도 할 수 있으나, 크기가 큰 텍스트 파일을 불러와야 하는 경우에는 시간이 많이 걸린다는 문제가 있다. 이 절에서는 tidyverse에 속한 패키지 readr의 함수를 사용하여 효율적으로 텍스트 파일을 불러오는 방법을 살펴보겠다. 패키지 readr에는 텍스트 파일의 구성 형식 에 맞추어 사용할 수 있는 다양한 함수가 마련되어 있다. 각각의 자료들이 하나 이상의 빈 칸으로 구분된 경우에는 read_table(), 콤마로 구분된 경우에는 함수 read_csv(), 탭으로 구분된 경우에는 함수 read_tsv(), 그 외 다른 형태의 구분자로 구분된 경우는 함수 read_delim()을 사용할 수 있으며, 고정된 포맷 구조를 갖는 경우에는 함수 read_fwf()을 사용하여 자료를 불러올 수 있다. 이 함수들은 불러올 파일의 경로를 포함한 파일 이름이 첫 번째 입력 요소가 된다. 파일 이름이 .gz 또는 .zip 등으로 끝나는 압축 파일은 자동으로 압축을 해제하고 자료를 불러온다. 또한 http://, https://, ftp://, ftps://로 시작되는 웹 서버에 있는 텍스트 파일도 불러올 수 있다. 3.1.1 함수 read_table()로 데이터 파일 불러오기 자료들이 하나 이상의 빈칸으로 구분된 경우에는 read_table()를 사용하여 파일을 불러올 수 있다. 데이터 파일의 첫 줄에 변수 이름이 입력되어 있는 경우 예를 들어 Data 폴더에 있는 파일 data2_1.txt에 세 변수의 자료가 다음과 같이 있다고 하자. 이런 경우에는 함수 read_table()에 파일의 위치와 함께 파일의 이름만 입력하면 된다. Figure 3.1: data2_1.txt &gt; library(tidyverse) &gt; read_table(&quot;Data/data2_1.txt&quot;) -- Column specification -------------------------------------------------------- cols( age = col_double(), gender = col_character(), income = col_double() ) # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 패키지 readr에 속한 함수들은 각 변수의 유형을 스스로 파악한다. 각 변수마다 처음 1000개의 자료를 읽고 정해진 규칙에 의하여 문자형, 정수형, 숫자형, 논리형 등으로 유형을 결정한다. 스스로 자료의 유형을 파악한 경우에는 각 변수별로 파악된 결과를 출력한다. 각 변수의 유형은 사용자가 직접 선언할 수도 있는데, 가장 간단한 방법은 입력 요소 col_types에 변수의 유형을 나타내는 문자를 변수가 입력된 순서대로 나열하여 지정하는 것이다. 자료의 유형을 나타내는 문자에는 c(문자형), i(정수형), d(실수형), n(숫자형), l (논리형), f(요인), D(날짜) 등이 있다. 예를 들어 파일 data2_1.txt의 경우에는 다음과 같이 자료의 유형을 선언하여 자료를 불러올 수 있다. &gt; read_table(&quot;Data/data2_1.txt&quot;, + col_types = &quot;dcd&quot;) # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 데이터만 파일에 입력되어 있는 경우 첫 줄에 변수 이름이 입력되어 있지 않은 데이터 파일도 많이 있다. 예를 들어 Data 폴더에 있는 파일 data2_2.txt에 세 변수에 대한 데이터가 다음과 같이 있다고 하자. data2_2.txt 이런 경우에는 입력 요소 col_names에 FALSE를 지정하거나 변수 이름을 나타내는 문자형 벡터를 지정해야 한다. 아무것도 지정하지 않으면 데이터 파일의 첫 줄에 입력된 자료가 각 변수의 이름으로 사용되는 오류가 발생한다. FALSE를 지정한 경우에 변수 이름은 X1, X2, X3 등이 된다. &gt; read_table(&quot;Data/data2_2.txt&quot;, + col_names = FALSE) -- Column specification -------------------------------------------------------- cols( X1 = col_double(), X2 = col_character(), X3 = col_double() ) # A tibble: 4 x 3 X1 X2 X3 &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 &gt; read_table(&quot;Data/data2_2.txt&quot;, + col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;)) -- Column specification -------------------------------------------------------- cols( age = col_double(), gender = col_character(), income = col_double() ) # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 데이터 파일에 주석이 입력된 경우 데이터 파일에 주석이 있는 경우, 해당 행을 무시하기 위해서는 주석이 시작됨을 나타내는 기호를 입력 요소 comment에 지정하면 된다. 만일 기호 #을 주석 기호로 사용했다면 comment=\"#\"을 입력하면 된다. 또한 만일 주석이 데이터 파일의 처음 몇 개 행에 입력되어 있다면, 입력 요소 skip을 사용하여 해당되는 처음 몇 개 행을 읽지 않고 그냥 넘기는 방법을 사용할 수도 있다. 예를 들어 Data 폴더에 있는 파일 data2_3.txt의 처음 세 줄이 다음과 같이 # 기호로 시작되는 주석이 입력되어 있다고 하자. 이 파일을 두 가지 방법을 각각 사용하여 불러와 보자. Figure 3.2: data2_3.txt &gt; read_table(&quot;Data/data2_3.txt&quot;, + comment = &quot;#&quot;) -- Column specification -------------------------------------------------------- cols( x1 = col_double(), x2 = col_double(), x3 = col_double() ) # A tibble: 4 x 3 x1 x2 x3 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 24 1 2000 2 35 0 3100 3 28 0 3800 4 21 0 2800 &gt; read_table(&quot;Data/data2_3.txt&quot;, + skip = 3) -- Column specification -------------------------------------------------------- cols( x1 = col_double(), x2 = col_double(), x3 = col_double() ) # A tibble: 4 x 3 x1 x2 x3 &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 24 1 2000 2 35 0 3100 3 28 0 3800 4 21 0 2800 데이터 파일에 결측값이 NA가 아닌 다른 기호로 입력된 경우 데이터에 결측값이 있는 것은 당연한 것으로 봐야 한다. R에서는 결측값을 NA로 표시하기 때문에 데이터에 결측값이 있다면 해당되는 자리에 NA를 입력해야 한다. 그러나 경우에 따라서 결측값이 다른 숫자나 문자 혹은 기호로 데이터 파일에 입력될 수도 있는데, 예를 들어 SAS의 경우 결측값은 점(.)으로 표시한다. 이렇듯 다른 기호로 결측값이 입력된 경우 에는 옵션 na에 해당 기호를 지정해 주어야 한다. 만일 결측값이 점(.)으로만 입력되어 있 다면 na = \".\"으로 지정하면 되지만 NA와 점(.)이 모두 결측값을 나타내는 기호로 사용되었 다면 na = c(\".\", \"NA\")로 두 기호를 모두 지정해야 한다. 예를 들어 Data 폴더에 있는 data2_4.txt에 다음과 같이 NA와 점(.)이 모두 결측값을 나타내는 기호로 사용되어 있다고 하자. 이 파일을 옵션 na를 사용해서 불러와 보자. Figure 3.3: data2_4.txt &gt; read_table(&quot;Data/data2_4.txt&quot;, + na = &quot;.&quot;) -- Column specification -------------------------------------------------------- cols( age = col_double(), gender = col_character(), income = col_character() ) # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 24 M 2000 2 NA F 3100 3 28 &lt;NA&gt; 3800 4 21 F NA &gt; read_table(&quot;Data/data2_4.txt&quot;, + na = c(&quot;.&quot;, &quot;NA&quot;)) -- Column specification -------------------------------------------------------- cols( age = col_double(), gender = col_character(), income = col_double() ) # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 NA F 3100 3 28 &lt;NA&gt; 3800 4 21 F NA 함수 file.choose() 외부 파일을 R로 불러오는 과정에서 파일이 저장되어 있는 폴더의 정확한 위치를 잊는 경우가 가끔 있다. 혹은 정확하다고 생각되는 파일의 경로를 입력했는데도 파일을 열 수 없다는 오류가 발생하는 경우도 있다. 이런 경우 굳이 윈도우 파일 탐색기를 이용하여 파일의 위치를 다시 확인하지 않고도 파일에 접근할 수 있는 방법이 있는데 그것은 file.choose()를 이용하는 것이다. 예를 들어 함수 read_table() 등에 파일의 위치와 더불어 파일 이름을 입력하는 대신 read_table(file.choose())를 실행하면 탐색기 창이 나타나서 접근하고자 하는 파일을 쉽게 찾을 수 있다. 3.1.2 함수 read_csv()로 CSV 데이터 파일 불러오기 CSV(Comma Separated Values) 파일이란 각 자료들이 콤마로 구분된 형식의 데이터 파일을 의미한다. Excel을 포함하는 많은 소프트웨어들이 CSV 형식의 데이터 파일을 읽어 올 수도 있고 작업결과를 CSV 형식으로 저장할 수도 있기 때문에 자주 사용되는 형식의 데이터 파일이라고 하겠다. 예들 들어 Data 폴더에 있는 파일 data3_1.txt에 자료들이 다음과 같이 콤마로 구분되어 있고, 첫 줄에는 변수 이름이 입력되어 있다고 하자. 이 경우에는 read_csv()에 파일의 위치를 포함한 이름을 입력하면 파일을 불러올 수 있다. Figure 3.4: data3_1.txt &gt; read_csv(&quot;Data/data3_1.txt&quot;) Rows: 4 Columns: 3 -- Column specification -------------------------------------------------------- Delimiter: &quot;,&quot; chr (1): var 2 dbl (2): var 1, var 3 i Use `spec()` to retrieve the full column specification for this data. i Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 4 x 3 `var 1` `var 2` `var 3` &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 함수 read_csv()로 생성된 tibble의 변수 이름이 var 1과 같이 backtick(`) 기호로 감싸져 있다. 이것은 문자로 시작하지 않거나 중간에 빈칸이 있는 등 R의 전통적인 변수 이름 규칙에 어긋나 변수 이름으로 사용할 수 없는 문자열을, tibble에서는 backtick 기호로 감싸서 정상적인 변수 이름으로 사용하고 있음을 보여주는 것이다. Backtick 기호는 키보드에서 tab 키 바로 위에 있는 것으로 인용부호와는 다른 기호이다. 함수 read_table()에서 살펴보았던 col_types, col_names, na, comment, skip은 read_csv()에서도 동일하게 작동되는 요소들이다. 예를 들어 Data 폴더에 있는 data3_2.txt에 다음과 같이 자료가 입력되어 있다고 하자. 첫 줄에 주석이 있고, 결측값이 기호 NA와 점(.)으로 표시되어 있으며, 변수 이름은 입력되지 않았다. Figure 3.5: data3_2.txt 이제 각 변수의 유형을 스스로 파악하게 해 보자. &gt; read_csv(&quot;Data/data3_2.txt&quot;, + col_names = FALSE, + comment = &quot;#&quot;, + na = c(&quot;.&quot;, &quot;NA&quot;)) Warning: One or more parsing issues, see `problems()` for details Rows: 4 Columns: 3 -- Column specification -------------------------------------------------------- Delimiter: &quot;,&quot; dbl (2): X1, X3 lgl (1): X2 i Use `spec()` to retrieve the full column specification for this data. i Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 4 x 3 X1 X2 X3 &lt;dbl&gt; &lt;lgl&gt; &lt;dbl&gt; 1 24 NA 2000 2 35 FALSE 3100 3 NA FALSE 3800 4 21 FALSE NA 위 실행결과에서 자세하게 살펴볼 두 가지 중요한 사항이 있다. 첫 번째 사항은 CSV 파일에서는 자료를 입력하지 않고 빈칸으로 남겨두면 결측값으로 자동 처리된다는 것이다. 이것은 빈칸으로 남겨져 있는 변수 X1의 세 번째 자료가 NA로 처리된 것으로 알 수 있다. 각 자료가 콤마로 구분되어 있다는 것은 곧 각 자료의 입력 영역이 확보되어 있다는 것을 의미하기 때문에 빈칸으로 남겨진 영역을 결측값으로 자연스럽게 처리할 수 있는 것이다. 두 번째 사항은 변수 유형 파악에 오류가 발생할 수도 있으니 반드시 결과를 확인해야 한다는 것이다. 위 실행 결과에서 문자형 변수 X2의 유형이 논리형으로 파악된 현상이 발생했는데, 이것은 변수 X2의 자료가 NA와 F로만 이루어져 있어서 F를 FALSE로 인식했기 때문이다. 이런 경우에는 변수 유형을 사용자가 직접 지정해야 한다. &gt; read_csv(&quot;Data/data3_2.txt&quot;, + col_names = FALSE, + col_types = &quot;dcd&quot;, + comment = &quot;#&quot;, + na = c(&quot;.&quot;, &quot;NA&quot;)) Warning: One or more parsing issues, see `problems()` for details # A tibble: 4 x 3 X1 X2 X3 &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 &lt;NA&gt; 2000 2 35 F 3100 3 NA F 3800 4 21 F NA 3.1.3 함수 read_fwf()로 고정 포맷 구조를 갖는 데이터 파일 불러오기 데이터 파일 중에는 각 자료의 입력 위치가 고정되어 있는 경우가 있다. 예를 들어 Data 폴더에 있는 파일 data4.txt에 다음과 같은 형식으로 세 변수의 데이터가 입력되어 있다고 하자. Figure 3.6: data4.txt 변수 age는 1-2열, gender는 3열, income은 4-7열에 각각 입력되어 있다. 이러한 경우 각 자료들이 빈칸이나 콤마 등으로 구분되어 있어야만 사용할 수 있는 함수 read_table() 또는 read_csv() 등은 그야말로 무용지물이 된다. 이러한 형식의 파일을 읽기 위해서는 각 자료의 고정된 위치를 지정할 수 있어야 하는데, 함수 read_fwf()에 바로 그러한 기능이 있다. 고정된 위치 지정은 입력 요소 col_positions에 함수 fwf_widths() 또는 fwf_positions()를 연결하는 것이다. 각 변수의 자료가 입력되는 영역의 폭으로 위치를 지정하는 것은 fwf_widths(widths, col_names)로 하면 되고, 각 변수의 시작 열과 끝 열을 지정해서 자료의 위치를 나타내기 위해서는 fwf_positions(start, end, col_names)로 하면 된다. 옵션 col_names를 생략하면 변수 이름은 X1, X2, X3 등으로 지정된다. 이제 data4.txt를 읽어보자. fwf_widths()에 widths=c(2,1,4)를 지정하면 첫 번째 변수 age는 두 개의 열, 두 번째 변수 gender는 한 개의 열, 마지막 변수 income은 네 개의 열을 차지하고 있다는 것이다. &gt; read_fwf(&quot;Data/data4.txt&quot;, + col_positions = fwf_widths(widths = c(2, 1, 4), + col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;))) Rows: 4 Columns: 3 -- Column specification -------------------------------------------------------- chr (1): gender dbl (2): age, income i Use `spec()` to retrieve the full column specification for this data. i Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 fwf_positions()에 start=c(1,3,4)와 end=c(2,3,7)을 지정하면 첫 번째 변수 age는 1~2열에, 두 번째 변수 gender는 3열에, 마지막 변수 income은 4~7열에 입력되어 있다는 것을 나타낸다. &gt; read_fwf(&quot;Data/data4.txt&quot;, + col_positions = fwf_positions(start = c(1, 3, 4), + end = c(2, 3, 7), + col_names = c(&quot;age&quot;, &quot;gender&quot;, &quot;income&quot;))) Rows: 4 Columns: 3 -- Column specification -------------------------------------------------------- chr (1): gender dbl (2): age, income i Use `spec()` to retrieve the full column specification for this data. i Specify the column types or set `show_col_types = FALSE` to quiet this message. # A tibble: 4 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 웹 서버에 저장된 2차원 형태의 데이터 파일 직접 불러오기 웹 서버에 저장된 텍스트 파일은 함수 read_table() 또는 read_csv() 등에 http:// 또는 https://로 시작하는 URL을 지정해서 불러올 수 있다. 예를 들어 UCI Machine Learning Repository라는 사이트가 있는데, 여기에는 Machine Learning으로 분석 가능한 대략 500개 이상의 데이터 세트가 있다. 그 중 Iris라는 데이터 세트를 R로 직접 불러와보자. 웹에 있는 데이터를 불러오기 위해서는 데이터 파일의 URL과 자료의 저장 형태를 파악해야 한다. Iris 데이터 세트의 URL은 https://archive. ics.uci.edu/ml/machine-learning-databases/iris/iris.data이며, 파일 형태는 자료들이 콤마로 구분된 CSV 파일이고, 변수 이름이 입력되어 있지 않은 상태이다. 이제 파악된 URL을 함수 read_csv()에 입력하여 웹 데이터를 직접 불러보자. &gt; iris.url &lt;- &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data&quot; &gt; read_csv(iris.url, + col_names=c(&quot;S.length&quot;,&quot;S.width&quot;,&quot;P.length&quot;,&quot;P.width&quot;,&quot;Species&quot;)) RStudio 메뉴에서 불러오기 외부 텍스트 파일을 불러오는 작업은 RStudio의 메뉴를 이용해서도 할 수 있다. 메인 메뉴 에서 File &gt; Import Dataset &gt; From Text (readr)… 을 선택하면 나타나는 별도의 창에서 필요한 사항을 선택하면 read_table() 혹은 read_csv() 등을 사용하여 파일을 불러오게 된다. 만일 base R 함수인 read.table() 혹은 read.csv() 등을 이용하고자 한다면 File &gt; Import Dataset &gt; From Text (base)…을 선택해서 불러올 수 있다. 또한 다음 절에서 살펴볼 Excel 파일이나, SAS 데이터 파일 등을 불러오는 작업도 File &gt; Import Dataset의 하부 메뉴를 이용해서 할 수 있다. 데이터 프레임을 외부 텍스트 파일로 저장하기 R에서 생성되고 수정된 데이터 프레임을 외부 텍스트 파일로 저장시켜 다른 소프트웨어에서도 사용할 수 있도록 하는 것도 중요한 작업이다. 데이터 프레임을 외부 텍스트 파일로 저장하는 작업은 자료들을 어떤 기호로 구분할 것인지에 따라 패키지 readr의 함수 write_delim(), write_csv() 또는 write_tsv() 등을 사용할 수 있다. 자료들을 빈칸으로 구분하려면 write_delim(), 콤마로 구분하려면 write_csv(), 탭으로 구분하려면 write_tsv()를 사용하면 된다. 데이터 프레임을 외부 텍스트 파일로 저장하는 작업은 write.csv()와 같은 base R 함수로도 할 수 있다. Base R의 함수들은 데이터 프레임의 행 이름을 텍스트 파일의 첫 번째 열에 배치하고, 모든 문자 및 변수 이름에 인용부호를 붙이는 것이 디폴트인 반면에 패키지 readr의 함수들은 데이터 프레임의 행 이름을 절대 저장하지 않으며 인용 부호는 필요한 경우에만 사용된다. 또한 패키지 readr의 함수들의 실행 속도가 2배 정도 빠른 것으로 되어 있다. Base 패키지인 datasets에 있는 데이터 프레임 women은 30대 미국 여성 15명의 몸무게와 키가 측정되어 있는 데이터 세트이다. 키는 인치 단위, 몸무게는 파운드 단위로 측정되었다. 데이터 프레임 women을 Data 폴더에 텍스트 파일로 저장하기 위해 다음 프로그램을 각각 실행해 보고 생성되는 텍스트 파일을 확인하기 바란다. &gt; write_delim(women, &quot;Data/women.txt&quot;) &gt; write_csv(women, &quot;Data/women.csv&quot;) &gt; write_tsv(women, &quot;Data/women.tsv&quot;) 3.2 Excel 파일 불러오기 Excel에서 데이터를 만들고 가공하는 경우가 많기 때문에 Excel 스프레드시트에 있는 데이터를 R로 불러오는 것은 상당히 중요한 작업이 된다. 이 절에서는 패키지 xlsx의 함수 read.xlsx()와 패키지 readxl의 함수 read_excel()을 사용하여, Excel 파일을 R로 불러오는 방법에 대하여 알아볼 것이다 예제 데이터로 Data 폴더에 있는 data5.xlsx에 다음과 같이 자료가 입력되어 있다고 하자. 자료는 첫 번째 시트에 입력되어 있다. Figure 3.7: data5.xlsx 패키지 xlsx의 함수 read.xlsx()로 Excel 파일 불러오기 함수 read.xlsx()에는 입력할 데이터가 있는 시트의 번호를 sheetIndex에 지정해야 한다. &gt; library(xlsx) &gt; read.xlsx(&quot;Data/data5.xlsx&quot;, sheetIndex = 1) age gender income 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 5 31 M 3500 함수 read.xlsx()는 tidyverse에 속한 함수가 아니어서, 이 함수로 생성된 객체는 전통적인 데이터 프레임이 됨을 알 수 있다. 만일 전체 스프레드시트 중 일부분만을 입력하고자 한다면 rowIndex와 colIndex에 입력할 행과 열의 번호를 지정하면 된다. &gt; read.xlsx(&quot;Data/data5.xlsx&quot;, sheetIndex = 1, + rowIndex = 1:5, colIndex = 1:2) age gender 1 24 M 2 35 F 3 28 F 4 21 F 패키지 readxl의 함수 read_excel()로 Excel 파일 불러오기 함수 read_excel()은 Excel 2003 이하 버전의 파일 형식인 xls 파일과 Excel 2007 이상 버전의 파일 형식인 xlsx 파일을 모두 불러올 수 있다. 또한 입력할 데이터가 있는 시트 번호를 지정하지 않으면, 디폴트로 첫 번째 시트의 데이터를 입력한다. 만일 다른 시트의 데이터를 입력하고자 한다면, 옵션 sheet에 시트 번호를 지정하면 된다. &gt; library(readxl) &gt; read_excel(&quot;Data/data5.xlsx&quot;) # A tibble: 5 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 2800 5 31 M 3500 시트의 전체 데이터 중 일부분만을 입력하고자 한다면, 옵션 range에 입력하고자 하는 데이터 범위 사각형의 왼쪽 위 모서리와 오른쪽 아래 모서리의 셀 번호를 지정하면 된다. &gt; read_excel(&quot;Data/data5.xlsx&quot;, range = &quot;A1:B5&quot;) # A tibble: 4 x 2 age gender &lt;dbl&gt; &lt;chr&gt; 1 24 M 2 35 F 3 28 F 4 21 F Excel 파일을 CSV 파일로 전환한 후 불러오기 앞에서 소개한 두 함수 중 어떤 함수를 사용하든지 Excel 파일을 R로 불러오는 데에는 큰 문제가 없겠지만, 어떤 이유로 해서 Excel 파일을 직접 R로 불러올 수 없는 경우에 대안으로 사용할 수 있는 방법이다. Excel 파일을 CSV 파일로 전환하여 저장하는 방법은 Excel의 메인 메뉴에서 파일 &gt; 다른 이름으로 저장을 선택한 후 CSV 파일 형식으로 저장하면 된다. 저장된 CSV 파일은 함수 read_csv()로 불러올 수 있다. 함수 write.xlsx()를 사용하여 데이터 프레임을 Excel 파일로 저장하기 데이터 프레임을 Excel 파일로 저장하는 것은 패키지 xlsx에 있는 함수 write.xlsx()를 사용하면 된다. 예를 들어 데이터 프레임 women을 Data 폴더에 women.xlsx로 저장해보자. &gt; library(xlsx) &gt; write.xlsx(women, &quot;Data/women.xlsx&quot;, row.names = FALSE) 3.3 SAS 데이터 파일 불러오기 SAS는 범용 통계 소프트웨어로서 매우 두터운 사용자 층을 형성하고 있다. 따라서 SAS 전용 데이터 파일을 R로 불러오는 것도 중요한 작업이다. SAS 전용 데이터 파일을 R로 직접 불러오는 방법을 알아보자. 패키지 haven의 함수 read_sas()로 SAS 전용 데이터 파일 불러오기 예를 들어 Data 폴더에 다음의 SAS 명령문으로 생성된 데이터 파일 data6.sas7bdat가 있다고 하자. LIBNAME mysas &#39;D:\\Data&#39;; DATA mysas.data6; INPUT age gender $ income; CARDS; 24 M 2000 35 F 3100 28 F 3800 21 F 3500 31 M 3500 RUN; 패키지 haven도 tidyverse 계열에 속하는 패키지이므로, 함수 read_sas()은 tibble을 생성한다. &gt; library(haven) &gt; read_sas(&quot;Data/data6.sas7bdat&quot;) # A tibble: 5 x 3 age gender income &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 1 24 M 2000 2 35 F 3100 3 28 F 3800 4 21 F 3500 5 31 M 3500 SAS 전용 데이터 파일을 CSV 파일로 전환한 후 불러오기 SAS 전용 데이터 파일은 SAS의 PROC EXPORT를 사용하여 CSV 파일로 전환하여 저장할 수 있다. Excel의 경우처럼 R로 직접 불러오는 방법에 대한 대안으로 사용할 수 있다. SAS 전용 데이터 파일인 data6.sas7bdat을 CSV 파일인 data6.csv로 출력하는 SAS 명령문은 다음과 같다. LIBNAME mysas &#39;D:\\Data&#39;; PROC EXPORT DATA=mysas.data6 OUTFILE=&#39;D:\\Data\\data6.csv&#39; DBMS=CSV; RUN; 패키지 haven에는 SPSS 데이터 파일과 Stata 데이터 파일을 불러올 수 있는 함수도 있다. SPSS 데이터 파일은 read_spss(), Stata DTA 파일은 read_stata()를 사용하면 어렵지 않게 불러올 수 있다. 3.4 HTML 테이블 불러오기 웹 페이지를 보다 보면 중요한 정보가 있는 HTML 테이블을 자주 만나게 되는데, 이 테이 블에 있는 데이터를 R로 바로 불러들일 수 있다면 분석 과정에 큰 도움이 될 것이다. 문제 는 웹 페이지에 있는 HTML 테이블이라는 것이 사람들에게 시각적으로 보여지는 측면이 강조되는 대상이어서 거기에 있는 정보를 ‘긁어모아’ 컴퓨터에 입력하는 것이 조금 복잡한 작업이 될 수 있다는 점이다. 그러나 패키지 rvest를 이용하면 비교적 간편하게 HTML 테이블의 데이터를 긁어모아 R에 입력시킬 수 있다. 패키지 rvest에서 HTML 테이블을 불러오는데 필요한 함수는 read_html()과 html_nodes(), html_table()이다. 함수 read_html()은 원하는 HTML 테이블이 있는 웹 페이지를 읽어오는 데 사용된다. HTML 테이블의 내용은 &lt;table&gt; 태그 사이에 존재하 기 때문에 &lt;table&gt; 노드(node)를 찾는 것이 다음 순서인데, 이 작업은 함수 html_nodes()로 할 수 있다. 이어서 선택된 노드의 HTML 테이블 데이터를 R로 불러오는 작업은 함수 html_table()로 하게 된다. 예제 1: Wikipedia 웹 페이지에 있는 HTML 테이블 데이터 불러오기 Figure 3.8은 Wikipedia에서 “World population”을 검색하면 열리는 웹 페이지에 있는 “10 most densely populated countries”라는 제목의 HTML 테이블을 보여주고 있다. 검색은 2022년 2월 9일에 실시된 것을 바탕으로 하고 있으며, 차후에 HTML 테이블의 배치가 변경되면 아래 예제 프로그램도 적절히 변경해야 할 것이다. Figure 3.8: 예제 1에서 사용된 HTML 테이블 원하는 웹 페이지의 URL을 함수 read_html()에 입력하여 얻은 결과에서 table 노드를 함수 html_nodes()로 찾아보자. 함수 html_nodes()는 결과를 리스트 형태로 출력한다. 모두 26개의 table 노드가 발견되었고, 그 중 처음 6개의 내용을 출력해 보자. &gt; library(rvest) 다음의 패키지를 부착합니다: &#39;rvest&#39; The following object is masked from &#39;package:readr&#39;: guess_encoding &gt; URL &lt;- &quot;https://en.wikipedia.org/wiki/World_population&quot; &gt; web &lt;- read_html(URL) &gt; tbl &lt;- html_nodes(web, &quot;table&quot;) &gt; length(tbl) [1] 26 &gt; head(tbl) {xml_nodeset (6)} [1] &lt;table class=&quot;infobox&quot; style=&quot;float: right; font-size:90%&quot;&gt;&lt;tbody&gt;\\n&lt;tr&gt;&lt; ... [2] &lt;table class=&quot;wikitable sortable&quot;&gt;\\n&lt;caption&gt;Population by region (2020 e ... [3] &lt;table class=&quot;wikitable&quot; style=&quot;text-align:center; float:right; clear:rig ... [4] &lt;table width=&quot;100%&quot;&gt;&lt;tbody&gt;&lt;tr&gt;\\n&lt;td valign=&quot;top&quot;&gt; &lt;style data-mw-dedupli ... [5] &lt;table class=&quot;wikitable sortable plainrowheaders&quot; style=&quot;text-align:right ... [6] &lt;table class=&quot;wikitable sortable&quot; style=&quot;text-align:right&quot;&gt;\\n&lt;caption&gt;10 ... 함수 html_nodes()의 결과로 생성된 리스트 객체인 tbl의 26개 구성요소 중 우리가 원하는 HTML 테이블에 해당되는 노드를 찾아서 함수 html_table()에 입력하면, 해당 테이블 데이터가 R로 입력된다. 문제는 몇 번째 노드가 우리가 원하는 테이블에 관한 것인지 알기가 어렵다는 점이다. 시행착오를 거치면, 원하는 테이블이 6번째 노드에 있다는 것을 알 수 있고, 따라서 html_table(tbl[6])을 실행하면 테이블의 데이터를 불러올 수 있다. 그러나 HTML 테이블이 많은 웹 페이지에서는 다른 체계적인 방법이 필요할 것이다. &gt; html_table(tbl[6]) [[1]] # A tibble: 10 x 5 Rank Country Population `Area(km2)` `Density(pop/km2)` &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 1 Singapore 5,704,000 710 8,033 2 2 Bangladesh 172,180,000 143,998 1,196 3 3 Palestine 5,266,785 6,020 847 4 4 Lebanon 6,856,000 10,452 656 5 5 Taiwan 23,604,000 36,193 652 6 6 South Korea 51,781,000 99,538 520 7 7 Rwanda 12,374,000 26,338 470 8 8 Haiti 11,578,000 27,065 428 9 9 Netherlands 17,690,000 41,526 426 10 10 Israel 9,470,000 22,072 429 웹 페이지에서 HTML 테이블을 체계적으로 찾는 방법 중 하나는 해당 테이블 노드의 XPath를 알아내는 것이다. XPath는 웹 문서에서 원하는 태그나 속성 등을 쉽게 찾기 위해 개발된 것으로 윈도우의 파일 경로와 비슷한 개념이라고 하겠다. 크롬 웹 브라우저를 대상으로 웹 페이지에서 원하는 HTML 테이블의 XPath를 알아내는 방법은 다음과 같다. 원하는 웹 페이지로 이동 F12 키를 눌러서(또는 마우스 오른쪽 버튼 클릭 &gt; 검사 클릭) 개발자 도구 실행. 창이 분리되며 오른쪽 창에 html 코드가 나타남. Ctrl + F 키를 눌러서 나타난 찾기 창에 &lt;table을 입력하고 찾기 실행 원하는 테이블에 해당되는 노드를 찾게 되면 Figure 3.9에서와 같이 테이블이 하이라이트가 된다. 이어서 마우스 오른쪽 버튼을 클릭 나타난 별도 메뉴에서 Copy &gt; Copy XPath를 클릭 Figure 3.9: 예제 1의 HTML 테이블 XPath 복사 원하는 HTML 테이블의 XPath의 값은 //*[@id=\"mw-content-text\"]/div[1]/table[5]이 되 며, 이것을 함수 html_nodes()안에 옵션 xpath에 지정하면 된다. &gt; X_path &lt;- &#39;//*[@id=&quot;mw-content-text&quot;]/div[1]/table[5]&#39; &gt; node_1 &lt;- html_nodes(web, xpath = X_path) &gt; tbl_1 &lt;- html_table(node_1) &gt; tbl_1 [[1]] # A tibble: 10 x 5 Rank Country Population `Area(km2)` `Density(pop/km2)` &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 1 Singapore 5,704,000 710 8,033 2 2 Bangladesh 172,180,000 143,998 1,196 3 3 Palestine 5,266,785 6,020 847 4 4 Lebanon 6,856,000 10,452 656 5 5 Taiwan 23,604,000 36,193 652 6 6 South Korea 51,781,000 99,538 520 7 7 Rwanda 12,374,000 26,338 470 8 8 Haiti 11,578,000 27,065 428 9 9 Netherlands 17,690,000 41,526 426 10 10 Israel 9,470,000 22,072 429 함수 html_table()로 생성된 객체 tbl_1은 하나의 데이터 프레임으로 구성된 리스트이다. 변수 이름을 수정하고 입력된 자료를 출력해 보자.. &gt; top_pop &lt;- tbl_1[[1]] &gt; names(top_pop) &lt;- c(&quot;rank&quot;, &quot;country&quot;, &quot;pop&quot;, &quot;area&quot;, &quot;density&quot;) &gt; top_pop # A tibble: 10 x 5 rank country pop area density &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 1 Singapore 5,704,000 710 8,033 2 2 Bangladesh 172,180,000 143,998 1,196 3 3 Palestine 5,266,785 6,020 847 4 4 Lebanon 6,856,000 10,452 656 5 5 Taiwan 23,604,000 36,193 652 6 6 South Korea 51,781,000 99,538 520 7 7 Rwanda 12,374,000 26,338 470 8 8 Haiti 11,578,000 27,065 428 9 9 Netherlands 17,690,000 41,526 426 10 10 Israel 9,470,000 22,072 429 변수 pop, area, density이 숫자가 아닌 문자형 벡터로 입력되었음을 알 수 있다. 이것은 숫자에 콤마가 함께 입력되어 있기 때문인데, 이제 변수 pop을 숫자형으로 변환하여 평균을 구해 보자. 숫자형으로 변환하는 방법은 pop에 포함된 콤마를 함수 gsub()를 사용하여 제거하고, 이어서 함수 as.numeric()을 사용하여 유형을 숫자형으로 변환하면 된다. &gt; pop &lt;- top_pop$pop &gt; pop &lt;- gsub(&quot;,&quot;, &quot;&quot;, pop) &gt; mean(as.numeric(pop)) [1] 31650379 예제 2: KBO 홈페이지 기록실에 있는 자료 불러오기 KBO 홈페이지의 기록실에 있는 자료를 불러와 보자. 자료를 불러온 시점은 2022년 2월이며, 내용은 2021년 KBO 정규 시즌 중 타자들의 팀 기록이다. 불러오고자 하는 HTML 테이블은 Figure 3.10에서 볼 수 있다. 해당 웹 페이지에는 하나의 HTML 테이블만이 있기 때문에 굳이 XPath를 복사해야 할 필요는 없다. 문제는 한글이 포함된 HTML 테이블을 불러올 때 종종 오류가 발생할 수 있다는 점이다. 이러한 오류를 어떻게 해결할 수 있는지 살펴보자. Figure 3.10: 예제 2에서 사용된 HTML 테이블 &gt; URL_2 &lt;- &quot;https://www.koreabaseball.com/Record/Team/Hitter/Basic1.aspx&quot; &gt; web_2 &lt;- read_html(URL_2) &gt; node_2 &lt;- html_nodes(web_2, &quot;table&quot;) &gt; tbl_2 &lt;- html_table(node_2)[[1]] Error in type.convert.default(x, as.is = TRUE, dec = dec, na.strings = na.strings): &#39;&lt;ed&gt;&lt;95&gt;&lt;a9&gt;怨&lt;84&gt;&#39;에서 유효하지 않은 멀티바이트 문자열이 있습니다 함수 html_table()에서 발생한 오류는 한글/영문의 locale로 인한 것이다. 우선 locale을 영문으로 바꾸고, 다시 함수 html_table()을 실행시켜 보자. &gt; Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) [1] &quot;LC_COLLATE=English_United States.1252;LC_CTYPE=English_United States.1252;LC_MONETARY=English_United States.1252;LC_NUMERIC=C;LC_TIME=English_United States.1252&quot; &gt; tbl_2 &lt;- html_table(node_2)[[1]] &gt; head(tbl_2) # A tibble: 6 x 15 `&lt;U+C21C&gt;&lt;U+C704&gt;` `&lt;U+D300&gt;&lt;U+BA85&gt;` AVG G PA AB R H `2B` `3B` HR TB &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1 &lt;U+B86F&gt;&lt;U+B370&gt; 0.278 144 5726 5009 727 1393 266 10 107 2000 2 2 &lt;U+B450&gt;&lt;U+C0B0&gt; 0.268 144 5645 4900 738 1314 235 17 110 1913 3 3 &lt;U+C0BC&gt;&lt;U+C131&gt; 0.267 144 5552 4836 712 1292 204 18 133 1931 4 4 KT 0.265 144 5627 4810 719 1276 219 11 106 1835 5 5 SSG 0.261 144 5736 4899 755 1278 204 13 185 2063 6 6 NC 0.261 144 5532 4808 702 1254 203 17 170 2001 # ... with 3 more variables: RBI &lt;int&gt;, SAC &lt;int&gt;, SF &lt;int&gt; 오류문제는 해결되었으나, 불러온 데이터에 이상한 문자가 포함되어 있음을 알 수 있다. 이것을 정상적인 한글로 보이게 하려면, 다시 locale을 한글로 바꾸면 된다. 이어서 합계가 들어간 마지막 행을 삭제하고, 결과를 출력해 보자. &gt; Sys.setlocale(&quot;LC_ALL&quot;, &quot;Korean&quot;) [1] &quot;LC_COLLATE=Korean_Korea.949;LC_CTYPE=Korean_Korea.949;LC_MONETARY=Korean_Korea.949;LC_NUMERIC=C;LC_TIME=Korean_Korea.949&quot; &gt; tbl_2 &lt;- tbl_2[-11,] &gt; tbl_2 # A tibble: 10 x 15 순위 팀명 AVG G PA AB R H `2B` `3B` HR TB RBI &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1 롯데 0.278 144 5726 5009 727 1393 266 10 107 2000 697 2 2 두산 0.268 144 5645 4900 738 1314 235 17 110 1913 698 3 3 삼성 0.267 144 5552 4836 712 1292 204 18 133 1931 669 4 4 KT 0.265 144 5627 4810 719 1276 219 11 106 1835 673 5 5 SSG 0.261 144 5736 4899 755 1278 204 13 185 2063 712 6 6 NC 0.261 144 5532 4808 702 1254 203 17 170 2001 670 7 7 키움 0.259 144 5653 4874 722 1262 244 28 91 1835 671 8 8 LG 0.25 144 5533 4750 654 1188 210 11 110 1750 621 9 9 KIA 0.248 144 5577 4831 568 1198 183 21 66 1621 546 10 10 한화 0.237 144 5495 4685 599 1111 213 17 80 1598 554 # ... with 2 more variables: SAC &lt;int&gt;, SF &lt;int&gt; 일반적으로 웹 페이지에 있는 HTML 테이블을 R로 불러온 후에도 실제 분석 데이터로 사용하기 위해서는 많은 추가 작업이 필요하게 된다. "],["dplyr에-의한-데이터-다듬기.html", "Chapter 4 dplyr에 의한 데이터 다듬기 4.1 행을 작업 대상으로 하는 함수 4.2 열을 작업 대상으로 하는 함수 4.3 여러 행 자료의 요약: summarise()", " Chapter 4 dplyr에 의한 데이터 다듬기 R에 입력된 데이터 세트는 대부분의 경우 바로 통계분석이 가능한 상태가 아니다. 분석에 필요한 적절한 변수가 없거나, 특정 조건을 만족하는 자료만을 선택해야 하거나, 자료의 순서를 바꿔야 하거나, 그룹별로 자료를 합치거나 또는 나눠야 하는 등등의 작업이 필요한 경우가 대부분이다. 이러한 데이터 다듬기는 최적의 통계 예측모형적합 등을 위해 반드시 필요한 절차이지만, 시간이 매우 많이 소요되는 힘든 작업이다. 따라서 일관된 법칙에 따라 편리하고 효율적으로 적용할 수 있는 데이터 다듬기 기법이 절실하게 필요한 상황이라고 하겠다. 통계 데이터 세트는 변수가 열, 관찰값이 행을 이루고 있는 2차원 구조를 가지고 있으며 데이터 프레임으로 입력된다. 이 장에서 살펴볼 내용은 패키지 dplyr에서 수행할 수 있는 다양한 데이터 프레임 다듬기 기법이다. 먼저 데이터 프레임 다듬기 작업에 사용되는 매우 중요하면서도 기본적인 dplyr 함수들을 살펴볼 것이다. 이어서 이러한 기본 dplyr 함수들 이 그룹으로 구분된 데이터에 대해서는 어떻게 작용을 하는지 살펴볼 것이며, 여러 개의 변수들을 대상으로 반복적으로 실행해야 하는 동일한 작업을 함수 across()를 이용하면 얼마나 간편하게 할 수 있는지를 살펴볼 것이다. 또한 행 단위로 작업이 이루어져야 하는 경우에 함수 rowwise()가 어떤 역할을 하는지도 살펴볼 것이다. 기본 dplyr 함수들은 세 가지 그룹으로 나누어 볼 수 있다. 함수 filter(), slice(), arrange(), distinct()와 같이 데이터 프레임의 행을 작업 대상으로 하는 함수가 있고, 함수 select(), rename(), mutate(), relocate()와 같이 열을 대상으로 작업을 하는 함수가 있으며, 요약 통계량을 계산하는 함수 summarise()가 있다. 기본 dplyr 함수들이 공통으로 갖고 있는 특징은 데이터 프레임(또는 tibble)이 함수들의 첫 번째 입력요소라는 것이다. 두 번째 특징은 각 함수 안에서 입력된 데이터 프레임의 변수를 인덱싱 기호($) 없이 사용할 수 있다는 것이다. 마지막 특징은 이 함수들이 생성하는 결과는 또 다른 데이터 프레임(또는 tibble)이라는 것이다. 기본 함수들이 갖고 있는 이러한 특징을 이용해서 조금 더 효율적인 프로그램이 가능하도록 dplyr에서는 pipe 기능을 사용할 수 있다. Pipe 기능 Pipe 기능이란 한 명령문의 결과물을 바로 다음 명령문의 입력 요소로 직접 사용할 수 있도록 명령문들을 서로 연결하는 기능을 의미한다. 이것이 가능하다면, 분석 중간 단계로 생성되는 무수한 객체들을 따로 저장할 필요가 없기 때문에 프로그램 자체가 매우 깔끔하게 정리되며, 분석 흐름을 쉽게 이해할 수 있게 된다. Pipe 연산자 %&gt;%는 tidyverse에 속한 패키지인 magrittr에서 정의된 것으로 tidyverse에 속한 다른 패키지에서도 사용이 가능하다. RStudio에서 pipe 연산자 %&gt;%의 입력은 Shift+Ctrl+M 키를 함께 누르면 된다. 기본적인 형태는 lhs %&gt;% rhs인데, lhs는 데이터 객체이거나 데이터 객체를 생성하는 함수가 되고, rhs는 lhs를 입력 요소로 하는 함수가 된다. 예를 들어 x %&gt;% f()는 객체 x를 함수 f()의 입력 요소로 하는 f(x)를 의미한다. 만일 rhs에 다른 요소가 있다면 lhs는 rhs의 첫 번째 입력 요소가 된다. 따라서 x %&gt;% f(y)는 f(x,y)를 의미한다. 만일 lhs가 rhs의 첫 번째 요소가 아닌 경우에는 원하는 위치에 점(.)을 찍어야 한다. 예를 들어, x %&gt;% f(y,.)은 f(y,x)를 의미한다. 4.1 행을 작업 대상으로 하는 함수 4.1.1 조건에 의한 행 선택: filter() 함수 filter()를 이용하면, 주어진 데이터 프레임에서 특정한 조건을 만족하는 행을 선택 할 수 있다. 조건을 설정할 때는 비교 연산자(&gt;, &gt;=, &lt;, &lt;=, !=, ==)와 논리 연산자(&amp;, |, !)가 사용되며, 연산자 %in%이 매우 유용하게 사용된다. 예제를 통해 자세한 사용법을 확인해 보자. 예제: mtcars 변수 mpg의 값이 30 이상인 자동차를 선택해 보자. 함수 filter()에 전통적인 데이터 프레임을 입력하면 결과로 전통적인 데이터 프레임이 출력되고, tibble을 입력하면 결과가 tibble로 출력된다. 데이터 프레임 mtcars를 tibble로 전환하고 선택 조건과 더불어 함수 filter()에 입력해 보자. &gt; library(tidyverse) &gt; mtcars_t &lt;- as_tibble(mtcars) &gt; mtcars_t %&gt;% filter(mpg &gt;= 30) # A tibble: 4 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 2 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 3 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 4 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 변수 mpg의 값이 30 이상이고 변수 wt의 값이 1.8 미만인 자동차를 선택해 보자. 논리 연산자 &amp; 대신에 콤마(,)를 사용할 수 있다. &gt; mtcars_t %&gt;% filter(mpg &gt;= 30, wt &lt; 1.8) # A tibble: 2 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 2 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 변수 mpg의 값이 30 이하이고, 변수 cyl의 값이 6 또는 8이며, 변수 am의 값이 1인 자동차를 선택해 보자. 이 경우에, 변수 cyl의 값이 6 또는 8인 사건에 대하여 논리 연산자를 사용해서 cyl == 6|cyl == 8으로 조건을 설정하는 것보다는, cyl %in% c(6,8)로 쓰는 것이 훨씬 간단한 방법이 된다. &gt; mtcars_t %&gt;% filter(mpg &lt;= 30, cyl %in% c(6,8), am == 1) # A tibble: 5 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 5 15 8 301 335 3.54 3.57 14.6 0 1 5 8 변수 mpg의 값이 mpg의 중앙값과 \\(Q_{3}\\) 사이에 있는 자동차를 선택해 보자. 여기서 \\(Q_{3}\\)는 0.75분위수를 의미하는 것으로서, \\(p\\) 분위수란 전체 데이터 중 \\((100 \\times p)\\)%데이터보다는 크고, 나머지 \\((100 \\times (1-p))\\)% 데이터보다는 작은 수를 의미한다. 분위수의 계산은 함수 quantile()로 하는데, 벡터 x의 0.75분위수의 계산은 quantile(x, probs=0.75)로 할 수 있다. &gt; mtcars_t %&gt;% + filter( + mpg &gt;= median(mpg), mpg &lt;= quantile(mpg, probs = 0.75) + ) # A tibble: 10 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 6 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 7 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 8 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 9 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 10 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 벡터 x가 특정 두 숫자 사이에 있는지를 확인하는 방법은 x &gt;= left &amp; x &lt;= right가 되는데, 이것을 함수 between()을 이용해서 between(x,left,right)로 할 수 있다. &gt; between(1:5, 2, 4) [1] FALSE TRUE TRUE TRUE FALSE 따라서 위 예제는 다음과 같이 실행해도 동일한 결과를 얻는다. &gt; mtcars_t %&gt;% + filter( + between(mpg, median(mpg), quantile(mpg, probs = 0.75)) + ) # A tibble: 10 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 6 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 7 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 8 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 9 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 10 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 예제: airquality 데이터 프레임 airquality는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의 질과 관련된 조사 결과를 담은 데이터 세트이다. airs라는 이름의 tibble로 전환하고, 처음 5개 케이스 를 출력해 보자. &gt; airs &lt;- as_tibble(airquality) %&gt;% + print(n = 3) # A tibble: 153 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 41 190 7.4 67 5 1 2 36 118 8 72 5 2 3 12 149 12.6 74 5 3 # ... with 150 more rows 변수 Ozone 또는 Solar.R이 결측값인 행을 선택해 보자. 결측값의 확인은 함수 is.na()로 할 수 있다. &gt; airs %&gt;% + filter(is.na(Ozone) | is.na(Solar.R)) %&gt;% + print(n = 5) # A tibble: 42 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 NA NA 14.3 56 5 5 2 28 NA 14.9 66 5 6 3 NA 194 8.6 69 5 10 4 7 NA 6.9 74 5 11 5 NA 66 16.6 57 5 25 # ... with 37 more rows 4.1.2 위치에 의한 행 선택: slice() 및 그와 관련된 함수 위치에 의한 행 선택이란 데이터 프레임에서 선택하고자 하는 행 번호를 지정해서 선택하는 것을 의미한다. 함수 slice()에 의한 행 선택 함수 slice()에는 행의 번호를 직접 지정해서 특정 행을 선택하거나 제거할 수 있다. 양의 정수를 입력하면 해당 위치의 행이 선택되고, 음의 정수를 입력하면 해당 위치의 행이 제거된다. 입력되는 정수는 모두 양수이거나 모두 음수이어야 한다. 데이터 프레임 iris를 tibble로 전환하고 5번째 행부터 10번째 행까지 선택해 보자. &gt; iris_t &lt;- as_tibble(iris) &gt; iris_t %&gt;% slice(5:10) # A tibble: 6 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5 3.6 1.4 0.2 setosa 2 5.4 3.9 1.7 0.4 setosa 3 4.6 3.4 1.4 0.3 setosa 4 5 3.4 1.5 0.2 setosa 5 4.4 2.9 1.4 0.2 setosa 6 4.9 3.1 1.5 0.1 setosa 이번에는 5번째 행부터 10번째 행을 제거해 보자. &gt; iris_t %&gt;% + slice(-(5:10)) %&gt;% + print(n = 3) # A tibble: 144 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa # ... with 141 more rows 이번에는 iris의 마지막 행을 선택해 보자. 이 경우 유용하게 사용될 함수가 n()이다. 이 함수는 데이터 프레임의 행의 개수를 세는 함수로서 단독으로는 사용될 수 없고 dplyr 기본 함수들과 함께 사용되어야 한다. &gt; iris_t %&gt;% + slice(n()) # A tibble: 1 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.9 3 5.1 1.8 virginica 함수 slice_head()와 slice_tail()에 의한 행 선택 데이터 프레임의 처음 몇 개 행을 선택하거나 마지막 몇 개 행을 선택하고자 할 때 사용되는 함수이다. 행의 개수를 지정하는 경우에는 n을 사용하고 행의 비율을 지정하는 경우에 는 prop를 사용하면 된다. 데이터 프레임 iris의 처음 3개 행과 마지막 3개 행을 각각 선택해 보자. &gt; iris_t %&gt;% + slice_head(n = 3) # A tibble: 3 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa &gt; iris_t %&gt;% + slice_tail(n = 3) # A tibble: 3 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 6.5 3 5.2 2 virginica 2 6.2 3.4 5.4 2.3 virginica 3 5.9 3 5.1 1.8 virginica 함수 slice_sample()에 의한 행 선택 데이터 프레임의 일부 행을 단순임의추출방법으로 선택할 때 사용되는 함수이다. 행의 개수를 지정해서 추출하는 경우에는 n을 사용하고, 행의 비율을 지정해서 추출하는 경우에는 prop를 사용하면 된다. 두 함수 모두 비복원추출이 디폴트로 적용되며, 만일 복원추출을 원한다면, replace=TRUE를 입력하면 된다. 데이터 프레임 iris에서 3개 행을 임의추출해 보자. 또한 전체 행 중 2%의 행을 비복원추출과 복원추출로 각각 선택해 보자. &gt; iris_t %&gt;% + slice_sample(n = 3) # A tibble: 3 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.2 2.7 3.9 1.4 versicolor 2 5.6 2.9 3.6 1.3 versicolor 3 6.3 3.3 6 2.5 virginica &gt; iris_t %&gt;% + slice_sample(prop = 0.02) # A tibble: 3 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 6.4 2.7 5.3 1.9 virginica 2 5.1 3.8 1.9 0.4 setosa 3 6.1 2.9 4.7 1.4 versicolor &gt; iris_t %&gt;% + slice_sample(prop = 0.02, replace = TRUE) # A tibble: 3 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.8 2.8 5.1 2.4 virginica 2 4.8 3 1.4 0.3 setosa 3 5 3.6 1.4 0.2 setosa 함수 slice_max()와 slice_min()에 의한 행 선택 특정 변수가 가장 큰 값을 갖거나 혹은 가장 작은 값을 갖는 행을 선택할 때 사용되는 함수이다. 기준으로 사용할 변수를 입력하고 이어서 행의 개수를 지정하는 경우에는 n을, 행의 비율을 지정하는 경우에는 prop를 입력하면 된다. 데이터 프레임 iris에서 변수 Sepal.Width의 값이 가장 큰 두 개 행을 선택해 보자. &gt; iris_t %&gt;% + slice_max(Sepal.Width, n = 2) # A tibble: 2 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 5.7 4.4 1.5 0.4 setosa 2 5.5 4.2 1.4 0.2 setosa 이번에는 Petal.Length의 값이 가장 작은 두 개 행을 선택해 보자. &gt; iris_t %&gt;% + slice_min(Petal.Length, n = 2) # A tibble: 2 x 5 Sepal.Length Sepal.Width Petal.Length Petal.Width Species &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; 1 4.6 3.6 1 0.2 setosa 2 4.3 3 1.1 0.1 setosa 4.1.3 행의 정렬: arrange() 함수 arrange()는 특정 변수를 기준으로 데이터 프레임의 행을 재배열할 때 사용된다. 함수에는 정렬의 기준이 되는 변수를 입력하면 되는데, 2개 이상의 정렬 기준 변수를 입력하게 되면 추가된 변수는 앞선 변수가 같은 값을 갖는 행들의 정렬 기준으로 사용된다. 정렬은 오름차순이 디폴트이며, 내림차순으로 배열하고자 할 때에는 기준 변수를 함수 desc()와 함께 사용해야 한다. 예제: mtcars 데이터 프레임 mtcars를 tibble로 전환하고 변수 mpg의 값이 좋지 않은 자동차 순서로 다시 배열해 보자. 연비가 좋지 않다는 것은 연비가 낮다는 것을 의미하는 것이므로 변수 mpg를 오름차순 정렬 변수로 사용하면 된다. &gt; mtcars_t &lt;- as_tibble(mtcars) &gt; mtcars_t %&gt;% + arrange(mpg) # A tibble: 32 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 2 10.4 8 460 215 3 5.42 17.8 0 0 3 4 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 7 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 8 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 9 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 10 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 # ... with 22 more rows 데이터 프레임 mtcars_t를 변수 mpg의 값이 좋지 않은 자동차 순서로 다시 배열을 하되, mpg 값이 같은 자동차의 경우에는 변수 wt의 값이 높은 자동차부터 배열해 보자. 변수 wt를 두 번째 정렬 기준 변수로 입력하되, 내림차순 정렬이 필요하므로 함수 desc()를 이용한다. &gt; mtcars_t %&gt;% + arrange(mpg, desc(wt)) # A tibble: 32 x 11 mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 10.4 8 460 215 3 5.42 17.8 0 0 3 4 2 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 7 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 8 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2 9 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2 10 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 # ... with 22 more rows 예제: airquality 데이터 프레임 airquality를 tibble로 전환하고, 5월 1일부터 5월 10일까지의 자료만을 대상으로 변수 Ozone의 값이 가장 낮았던 날부터 다시 배열해 보자. &gt; airs_1 &lt;- as_tibble(airquality) %&gt;% + filter(Month == 5, Day &lt;= 10) &gt; airs_1 %&gt;% + arrange(Ozone) # A tibble: 10 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 8 19 20.1 61 5 9 2 12 149 12.6 74 5 3 3 18 313 11.5 62 5 4 4 19 99 13.8 59 5 8 5 23 299 8.6 65 5 7 6 28 NA 14.9 66 5 6 7 36 118 8 72 5 2 8 41 190 7.4 67 5 1 9 NA NA 14.3 56 5 5 10 NA 194 8.6 69 5 10 위의 정렬 결과를 보면 변수 Ozone이 결측값인 행이 가장 뒤로 배열되어 있다. 이것이 문제는 아니지만, 어떤 경우에는 결측값인 행을 가장 앞으로 배열하는 것이 필요할 때도 있다. 데이터 프레임 airs_1을 변수 Ozone이 결측값인 행부터 다시 배열해 보자. 이것은 배열 기준으로 논리형 벡터를 사용해야 되는 문제인데, TRUE와 FALSE의 배열에서 FALSE가 우선 순위에 있기 때문에 !is.na(Ozone)을 배열 기준으로 사용하면 된다. &gt; airs_1 %&gt;% + arrange(!is.na(Ozone)) # A tibble: 10 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 NA NA 14.3 56 5 5 2 NA 194 8.6 69 5 10 3 41 190 7.4 67 5 1 4 36 118 8 72 5 2 5 12 149 12.6 74 5 3 6 18 313 11.5 62 5 4 7 28 NA 14.9 66 5 6 8 23 299 8.6 65 5 7 9 19 99 13.8 59 5 8 10 8 19 20.1 61 5 9 이번에는 데이터 프레임 airs_1을 변수 Ozone의 값이 가장 높은 날부터 다시 배열하되 결측값이 있는 행을 가장 앞으로 배열해 보자. 이때는 !is.na(Ozone)을 첫 번째 배열 기준으로 하여 결측값이 있는 행을 가장 앞으로 배치하고, desc(Ozone)을 두 번째 배열 기준으로 입력해서 결측값이 아닌 행들을 변수 Ozone의 내림차순으로 다시 배열해야 된다. &gt; airs_1 %&gt;% + arrange(!is.na(Ozone), desc(Ozone)) # A tibble: 10 x 6 Ozone Solar.R Wind Temp Month Day &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 NA NA 14.3 56 5 5 2 NA 194 8.6 69 5 10 3 41 190 7.4 67 5 1 4 36 118 8 72 5 2 5 28 NA 14.9 66 5 6 6 23 299 8.6 65 5 7 7 19 99 13.8 59 5 8 8 18 313 11.5 62 5 4 9 12 149 12.6 74 5 3 10 8 19 20.1 61 5 9 4.1.4 중복된 행의 제거: distinct() 함수 distinct()는 중복 입력된 행을 제거할 때 사용된다. 함수에는 중복 여부를 결정할 변수를 입력하면 되는데, 입력한 변수가 없다면 모든 변수들을 대상으로 중복 여부를 결정한다. 옵션 .keep_all=TRUE가 지정되면 데이터 프레임의 모든 변수가 유지되는데, 이 경우에는 중복된 행 중에 처음 나타난 행이 유지된다. 단순한 형태의 데이터 프레임으로 함수 distinct()의 작동 방식을 살펴보자. &gt; df1 &lt;- tibble(id = rep(1:3, times = 2:4), x1 = c(1:2,1:3,1:4)) &gt; df1 # A tibble: 9 x 2 id x1 &lt;int&gt; &lt;int&gt; 1 1 1 2 1 2 3 2 1 4 2 2 5 2 3 6 3 1 7 3 2 8 3 3 9 3 4 변수 id가 중복되지 않은 행들을 선택해 보자. 중복된 행 중에 처음 나타난 행이 유지됨을 알 수 있다. &gt; df1 %&gt;% + distinct(id, .keep_all = TRUE) # A tibble: 3 x 2 id x1 &lt;int&gt; &lt;int&gt; 1 1 1 2 2 1 3 3 1 변수 id가 중복된 행 중에 첫 번째 위치한 행이 아닌, 변수 x1이 가장 큰 값을 갖는 행을 선택해 보자. 이 문제는 변수 id가 중복된 행들을 변수 x1의 내림차순으로 정렬한 데이터 프레임을 대상으로 중복된 행을 제거하면 된다. &gt; df1 %&gt;% + arrange(id, desc(x1)) %&gt;% + distinct(id, .keep_all = TRUE) # A tibble: 3 x 2 id x1 &lt;int&gt; &lt;int&gt; 1 1 2 2 2 3 3 3 4 함수 distinct()로 모든 변수의 값이 중복된 행을 제거하는 예제를 살펴보자. &gt; df2 &lt;- tibble(id = rep(1:3, each = 2), x1 = c(2,2,3,1,4,4)) &gt; df2 # A tibble: 6 x 2 id x1 &lt;int&gt; &lt;dbl&gt; 1 1 2 2 1 2 3 2 3 4 2 1 5 3 4 6 3 4 &gt; df2 %&gt;% + distinct() # A tibble: 4 x 2 id x1 &lt;int&gt; &lt;dbl&gt; 1 1 2 2 2 3 3 2 1 4 3 4 4.2 열을 작업 대상으로 하는 함수 4.2.1 열의 선택: select() 데이터 세트의 크기가 커짐에 따라 변수의 개수가 수백 또는 수천이 되는 경우를 접하는 것이 더 이상 드문 상황은 아니다. 이러한 경우, 분석에 필요한 변수를 선택하여 데이터 세트의 크기를 줄이는 것은 매우 중요한 작업이 된다. 함수 select()에서는 패키지 tidyselect에 의해 구현되는 효과적인 변수 선택 방법을 이용할 수 있다. 여기에서 작동되는 &lt;tidy-select&gt; 방식은 기본적으로 변수들의 집합을 구성하는 것으로 생각하면 된다. 구체적인 선택 방법은 열 번호 또는 열 이름에 의한 방법과 변수의 유형에 의한 방법, 그리고 변 수 선택과 관련된 몇몇 함수들을 이용하는 방법으로 구분할 수 있다. 열 번호(또는 열 이름)에 의한 선택 가장 기본적인 방법은 열 번호를 콤마로 구분하여 나열하는 것이다. 이렇게 나열된 열들은 차례로 합집합을 구성하여 포함된 모든 열을 선택하게 된다. 연속된 열 변호는 콜론(:) 연산자를 이용해서 나타낼 수 있다. 예제로서 데이터 프레임 mtcars의 행 이름을 변수 row.name으로 추가하고 tibble로 전환해 보자. &gt; mtcars_t &lt;- mtcars %&gt;% + rownames_to_column(var = &quot;row.name&quot;) %&gt;% + as_tibble() %&gt;% + print(n = 3) # A tibble: 32 x 12 row.name mpg cyl disp hp drat wt qsec vs am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 W~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 # ... with 29 more rows 이어서 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 선택해 보자. 이 경우에는 열 번호를 함수 c() 없이 그냥 나열해도 결과는 동일하다. &gt; mtcars_t %&gt;% + select(1:3, 7) # A tibble: 32 x 4 row.name mpg cyl wt &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 2.62 2 Mazda RX4 Wag 21 6 2.88 3 Datsun 710 22.8 4 2.32 4 Hornet 4 Drive 21.4 6 3.22 5 Hornet Sportabout 18.7 8 3.44 6 Valiant 18.1 6 3.46 7 Duster 360 14.3 8 3.57 8 Merc 240D 24.4 4 3.19 9 Merc 230 22.8 4 3.15 10 Merc 280 19.2 6 3.44 # ... with 22 more rows 열(변수) 이름은 열 번호와 같은 취급을 받는다. 따라서 다음 방법도 같은 결과를 생성한다. &gt; mtcars_t %&gt;% + select(row.name:cyl, wt) # A tibble: 32 x 4 row.name mpg cyl wt &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 2.62 2 Mazda RX4 Wag 21 6 2.88 3 Datsun 710 22.8 4 2.32 4 Hornet 4 Drive 21.4 6 3.22 5 Hornet Sportabout 18.7 8 3.44 6 Valiant 18.1 6 3.46 7 Duster 360 14.3 8 3.57 8 Merc 240D 24.4 4 3.19 9 Merc 230 22.8 4 3.15 10 Merc 280 19.2 6 3.44 # ... with 22 more rows 열을 제거하고자 하는 경우에는 논리 부정 연산자(!) 또는 마이너스(-) 연산자를 사용해야 한다. 함수 c() 안에 제거하고자 하는 열 번호를 나열하고 논리 부정 연산자를 그 앞에 붙이면 나열된 열로 이루어진 집합의 여집합을 구성하는 것이므로 결과적으로 해당되는 열들이 제거되는 것이다. 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 제거해 보자. &gt; mtcars_t %&gt;% + select(!c(1:3, 7)) # A tibble: 32 x 8 disp hp drat qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 160 110 3.9 16.5 0 1 4 4 2 160 110 3.9 17.0 0 1 4 4 3 108 93 3.85 18.6 1 1 4 1 4 258 110 3.08 19.4 1 0 3 1 5 360 175 3.15 17.0 0 0 3 2 6 225 105 2.76 20.2 1 0 3 1 7 360 245 3.21 15.8 0 0 3 4 8 147. 62 3.69 20 1 0 4 2 9 141. 95 3.92 22.9 1 0 4 2 10 168. 123 3.92 18.3 1 0 4 4 # ... with 22 more rows 마이너스 연산자는 차집합을 구성하게 된다. 예컨대 select(1:4, -1)은 처음 네 변수 중 첫 번째 변수를 제거하라는 의미가 된다. 그러나 만일 select(1:4, !1)과 같이 논리 부정 연산자를 대신 사용하면 처음 네 변수와 첫 번째 변수를 제외한 나머지 변수와의 합 집합을 구성하는 것이 되어서 결국 모든 변수를 다 선택하게 된다. 비록 두 연산자의 의미는 다르지만, 마이너스 연산자가 첫 번째로 입력되면 같은 효과를 볼 수 있다. 따라서 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수의 제거는 다음과 같이 할 수도 있다. &gt; mtcars_t %&gt;% + select(-c(1:3, 7)) # A tibble: 32 x 8 disp hp drat qsec vs am gear carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 160 110 3.9 16.5 0 1 4 4 2 160 110 3.9 17.0 0 1 4 4 3 108 93 3.85 18.6 1 1 4 1 4 258 110 3.08 19.4 1 0 3 1 5 360 175 3.15 17.0 0 0 3 2 6 225 105 2.76 20.2 1 0 3 1 7 360 245 3.21 15.8 0 0 3 4 8 147. 62 3.69 20 1 0 4 2 9 141. 95 3.92 22.9 1 0 4 2 10 168. 123 3.92 18.3 1 0 4 4 # ... with 22 more rows 변수 유형에 의한 선택 특정 유형의 변수를 선택해야 하는 경우 유용하게 사용할 수 있는 방법이다. 변수의 유형 파악은 함수 is.numeric() 또는 is.character() 등 is.*() 형태의 함수로 할 수 있다. 이러한 함수들은 결과가 TRUE 또는 FALSE 중 하나가 되는데, 이런 함수를 predicate 함수라고 한다. 변수 유형에 의한 선택이란 함수 where() 안에 특정 predicate 함수를 입력해서 그 결과가 TRUE가 되는 변수를 선택하는 방법이다. 패키지 ggplot2의 데이터 프레임 mpg를 살펴보자. &gt; mpg %&gt;% print(n = 3) # A tibble: 234 x 11 manufacturer model displ year cyl trans drv cty hwy fl class &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 1 audi a4 1.8 1999 4 auto(l5) f 18 29 p compa~ 2 audi a4 1.8 1999 4 manual(m5) f 21 29 p compa~ 3 audi a4 2 2008 4 manual(m6) f 20 31 p compa~ # ... with 231 more rows 데이터 프레임 mpg에서 숫자형 변수만 선택해 보자. &gt; mpg %&gt;% + select(where(is.numeric)) # A tibble: 234 x 5 displ year cyl cty hwy &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; 1 1.8 1999 4 18 29 2 1.8 1999 4 21 29 3 2 2008 4 20 31 4 2 2008 4 21 30 5 2.8 1999 6 16 26 6 2.8 1999 6 18 26 7 3.1 2008 6 18 27 8 1.8 1999 4 18 26 9 1.8 1999 4 16 25 10 2 2008 4 20 28 # ... with 224 more rows 몇 가지 변수 유형을 함께 고려해야 하는 경우에는 논리 연산자 &amp;와 |을 사용하게 된다. 예를 들어 숫자형 변수이거나 문자형 변수의 선택은 다음과 같다. &gt; mpg %&gt;% + select(where(is.numeric) | where(is.character)) # A tibble: 234 x 11 displ year cyl cty hwy manufacturer model trans drv fl class &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; 1 1.8 1999 4 18 29 audi a4 auto~ f p comp~ 2 1.8 1999 4 21 29 audi a4 manu~ f p comp~ 3 2 2008 4 20 31 audi a4 manu~ f p comp~ 4 2 2008 4 21 30 audi a4 auto~ f p comp~ 5 2.8 1999 6 16 26 audi a4 auto~ f p comp~ 6 2.8 1999 6 18 26 audi a4 manu~ f p comp~ 7 3.1 2008 6 18 27 audi a4 auto~ f p comp~ 8 1.8 1999 4 18 26 audi a4 quattro manu~ 4 p comp~ 9 1.8 1999 4 16 25 audi a4 quattro auto~ 4 p comp~ 10 2 2008 4 20 28 audi a4 quattro manu~ 4 p comp~ # ... with 224 more rows 변수 선택과 관련된 함수의 이용 변수 선택에 매우 유용하게 사용되는 함수들이 있다. 먼저 특정 위치의 열을 선택할 때 사용할 수 있는 함수들이다. everything() : 모든 변수 선택 last_col() : 마지막 변수 선택 변수 이름을 구성하고 있는 문자열에 대한 매칭 작업으로 변수를 선택할 때 사용할 수 있는 함수들이다. starts_with(\"x\"): 이름이 x로 시작하는 변수 선택 ends_with(\"x\"): 이름이 x로 끝나는 변수 선택 contains(\"x\"): 이름에 x가 있는 변수 선택 num_range(\"x\", 1:10): x1, x2, … , x10과 동일 변수 이름이 입력된 문자형 벡터를 이용하여 변수를 선택할 때 사용할 수 있는 함수들 이다. all_of(vec): 문자형 벡터 vec에 이름이 입력된 변수 선택. 해당 데이터 프레임에 없는 변수 이름이 vec에 입력되어 있으면 오류 발생. any_of(vec): 함수 all_of()와 동일함. 단, 데이터 프레임에 없는 변수 이름이 입력 되어도 오류가 발생하지 않음. 예제로 데이터 프레임 mtcars_t에서 첫 번째 변수와 마지막 변수를 선택해 보자. &gt; mtcars_t %&gt;% + select(1, last_col()) # A tibble: 32 x 2 row.name carb &lt;chr&gt; &lt;dbl&gt; 1 Mazda RX4 4 2 Mazda RX4 Wag 4 3 Datsun 710 1 4 Hornet 4 Drive 1 5 Hornet Sportabout 2 6 Valiant 1 7 Duster 360 4 8 Merc 240D 2 9 Merc 230 2 10 Merc 280 4 # ... with 22 more rows 이번에는 mtcars_t에서 이름이 m으로 시작하는 변수를 선택해 보자. &gt; mtcars_t %&gt;% + select(starts_with(&quot;m&quot;)) # A tibble: 32 x 1 mpg &lt;dbl&gt; 1 21 2 21 3 22.8 4 21.4 5 18.7 6 18.1 7 14.3 8 24.4 9 22.8 10 19.2 # ... with 22 more rows 이름이 p로 끝나는 변수도 선택해 보자. &gt; mtcars_t %&gt;% + select(ends_with(&quot;p&quot;)) # A tibble: 32 x 2 disp hp &lt;dbl&gt; &lt;dbl&gt; 1 160 110 2 160 110 3 108 93 4 258 110 5 360 175 6 225 105 7 360 245 8 147. 62 9 141. 95 10 168. 123 # ... with 22 more rows 이름에 A가 있는 변수를 선택해 보자. &gt; mtcars_t %&gt;% + select(contains(&quot;A&quot;)) # A tibble: 32 x 5 row.name drat am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 3.9 1 4 4 2 Mazda RX4 Wag 3.9 1 4 4 3 Datsun 710 3.85 1 4 1 4 Hornet 4 Drive 3.08 0 3 1 5 Hornet Sportabout 3.15 0 3 2 6 Valiant 2.76 0 3 1 7 Duster 360 3.21 0 3 4 8 Merc 240D 3.69 0 4 2 9 Merc 230 3.92 0 4 2 10 Merc 280 3.92 0 4 4 # ... with 22 more rows 대문자 A가 이름에 있는 변수 선택을 요구했지만, 결과는 모두 소문자 a가 이름에 있는 변수가 선택되었다. 이런 결과가 나온 이유는 옵션 ignore.case = TRUE가 디폴트로 설정되어서 대문자와 소문자를 구분하지 않기 때문이다. 이 옵션은 함수 starts_with()와 ends_with()에도 동일하게 TRUE가 디폴트이다. 만일 대문자를 구분해서 문자열 매칭 작업을 하면 다음과 같이 해당되는 변수가 없다는 결과가 나온다. &gt; mtcars_t %&gt;% + select(contains(&quot;A&quot;, ignore.case = FALSE)) # A tibble: 32 x 0 문자형 벡터 vars에 다음과 같이 변수 이름을 입력해 보자. 앞에서 생성된 데이터 프레임 mtcars_t에는 변수 mpg와 wt는 있지만, 변수 model은 없는 상태이다. &gt; vars &lt;- c(&quot;model&quot;, &quot;mpg&quot;, &quot;wt&quot;) 함수 any_of()를 사용하면 mtcars_t에 있는 두 변수가 선택된다. &gt; mtcars_t %&gt;% + select(any_of(vars)) # A tibble: 32 x 2 mpg wt &lt;dbl&gt; &lt;dbl&gt; 1 21 2.62 2 21 2.88 3 22.8 2.32 4 21.4 3.22 5 18.7 3.44 6 18.1 3.46 7 14.3 3.57 8 24.4 3.19 9 22.8 3.15 10 19.2 3.44 # ... with 22 more rows 함수 all_of()를 사용하게 되면 model이 mtcars_t에 없는 변수이기 때문에 오류가 발생하게 된다. &gt; mtcars_t %&gt;% + select(all_of(vars)) Error: Can&#39;t subset columns that don&#39;t exist. x Column `model` doesn&#39;t exist. 당연한 것이지만, 지금까지 살펴본 세 가지 변수 선택 방법은 서로 혼합해서 사용할 수 있다. 예를 들어 숫자형 변수 중에 이름에 a가 변수는 다음과 같이 선택할 수 있다. &gt; mtcars_t %&gt;% + select(where(is.numeric) &amp; contains(&quot;c&quot;)) # A tibble: 32 x 3 cyl qsec carb &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 6 16.5 4 2 6 17.0 4 3 4 18.6 1 4 6 19.4 1 5 8 17.0 2 6 6 20.2 1 7 8 15.8 4 8 4 20 2 9 4 22.9 2 10 6 18.3 4 # ... with 22 more rows 벡터 형태로 변수 선택: 함수 pull() 데이터 프레임의 한 변수를 선택하여 벡터로 추출하고자 한다면 함수 pull()을 사용하면 된다. 변수 선택 방법은 옵션 var에 변수 이름을 지정하거나, 위치를 나타내는 정수를 지정하는 것이다. 양의 정수는 첫 번째 변수를 시작점으로 하는 위치이고, 음의 정수는 마지막 변수 를 시작점으로 하는 위치이다. 디폴트는 var = -1로 설정되어 있어서, 마지막 변수가 선택된다. 데이터 프레임 mtcars를 대상으로 마지막 변수와 세 번째 변수, 그리고 변수 am을 벡터 형태로 선택해 보자. &gt; mtcars_t %&gt;% pull() [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 &gt; mtcars_t %&gt;% pull(var = 3) [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 &gt; mtcars_t %&gt;% pull(var = am) [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 4.2.2 열 이름 변경: rename()과 rename_with() 변수 이름이 매우 복잡하거나 사용하기 불편해서 이름을 변경해야 하는 경우가 많다. 함수 select()로도 변수 이름을 변경할 수 있으나, 함수 내에서 이름이 명시되지 않은 변수는 선택되지 않은 변수가 되어 제거되고, 이름이 변경된 변수만 남게 된다. 변수에 새로운 이름을 주는 방식은 new_name = old_name이 되는데, old_name 자리에는 변수 이름 또는 변수의 열 번호가 올 수 있다. &gt; mtcars_t %&gt;% + select(model = row.name) # A tibble: 32 x 1 model &lt;chr&gt; 1 Mazda RX4 2 Mazda RX4 Wag 3 Datsun 710 4 Hornet 4 Drive 5 Hornet Sportabout 6 Valiant 7 Duster 360 8 Merc 240D 9 Merc 230 10 Merc 280 # ... with 22 more rows &gt; mtcars_t %&gt;% + select(model = 1) # A tibble: 32 x 1 model &lt;chr&gt; 1 Mazda RX4 2 Mazda RX4 Wag 3 Datsun 710 4 Hornet 4 Drive 5 Hornet Sportabout 6 Valiant 7 Duster 360 8 Merc 240D 9 Merc 230 10 Merc 280 # ... with 22 more rows 함수 select()에서 이름이 변경되지 않은 변수도 모두 그대로 유지하려면 함수 everything()을 함께 사용하면 된다. &gt; mtcars_t %&gt;% + select(model = row.name, everything()) # A tibble: 32 x 12 model mpg cyl disp hp drat wt qsec vs am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 ~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 Hornet 4 D~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 Hornet Spo~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # ... with 22 more rows 함수 rename()을 사용하면 이름이 변경되지 않은 변수도 모두 그대로 유지가 된다. 변수에 새로운 이름을 주는 방식은 함수 select()와 동일하게 new_name = old_name이다. &gt; mtcars_t %&gt;% + rename(model = row.name) # A tibble: 32 x 12 model mpg cyl disp hp drat wt qsec vs am gear carb &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 ~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 Hornet 4 D~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 Hornet Spo~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # ... with 22 more rows 많은 변수의 이름을 어떤 공통된 양식에 따라 모두 바꿔야 하는 경우, 하나씩 new_name = old_name으로 변경하는 방식은 매우 비효율적이 될 수 있다. 예컨대 대문자로 입력된 변수 이름을 모두 소문자로 변경하거나, 이름 중간에 들어간 점(.)을 밑줄(_)로 변경해야 하는 경우에 하나씩 변경하는 방식이 아닌 해당되는 변수의 이름을 한꺼번에 모두 바꿀 수 있는 방식이 필요한 것이다. 이러한 작업은 함수 rename_with()로 할 수 있다. 데이터 프레임 mtcars_t의 모든 변수 이름을 대문자로 변경해 보자. 함수 rename_with()에는 기존의 변수 이름을 새로운 이름으로 바꿀 수 있는 함수를 지정해야 한다. 모든 변수를 대문자로 변경하는 작업이므로 함수 toupper()를 사용하면 된다. &gt; mtcars_t %&gt;% + rename_with(toupper) # A tibble: 32 x 12 ROW.NAME MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 ~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 Hornet 4 D~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 Hornet Spo~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # ... with 22 more rows 모든 변수가 이름 변경 대상이 되는 것이 디폴트이다. 변경 대상 변수를 선택을 해야 하는 경우에는 함수 select()에서 사용했던 &lt;tidy-select&gt;의 방식으로 선택하여 함수 rename_with()의 세 번째 입력요소로 지정하면 된다. 이름에 a가 포함되어 있는 변수의 이름을 대문자로 바꾸어 보자. &gt; mtcars_t %&gt;% + rename_with(toupper, contains(&quot;a&quot;)) # A tibble: 32 x 12 ROW.NAME mpg cyl disp hp DRAT wt qsec vs AM GEAR CARB &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 Mazda RX4 ~ 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 Hornet 4 D~ 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 5 Hornet Spo~ 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 # ... with 22 more rows 4.2.3 열의 위치 변경: relocate() 열의 위치를 변경해야 하는 경우에 사용할 수 있는 함수이다. 위치를 바꿀 열은 &lt;tidy-select&gt; 방식을 사용하여 선택할 수 있어서, 여러 열의 위치를 한꺼번에 옮길 수 있다. 제일 앞으로 이동되는 것이 디폴트 위치이며 옵션 .after 혹은 .before에서 위치를 지정할 수 있다. 데이터 프레임 iris의 마지막 변수 Species를 첫 번째 위치로 이동해 보자. &gt; iris_t &lt;- as_tibble(iris) &gt; iris_t %&gt;% + relocate(Species) # A tibble: 150 x 5 Species Sepal.Length Sepal.Width Petal.Length Petal.Width &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 setosa 5.1 3.5 1.4 0.2 2 setosa 4.9 3 1.4 0.2 3 setosa 4.7 3.2 1.3 0.2 4 setosa 4.6 3.1 1.5 0.2 5 setosa 5 3.6 1.4 0.2 6 setosa 5.4 3.9 1.7 0.4 7 setosa 4.6 3.4 1.4 0.3 8 setosa 5 3.4 1.5 0.2 9 setosa 4.4 2.9 1.4 0.2 10 setosa 4.9 3.1 1.5 0.1 # ... with 140 more rows 이름이 th로 끝나는 변수를 모두 Species 다음으로 이동하면 변수 Species를 첫 번째 위치로 이동하는 것이 된다. &gt; iris_t %&gt;% + relocate(ends_with(&quot;th&quot;), .after = Species) # A tibble: 150 x 5 Species Sepal.Length Sepal.Width Petal.Length Petal.Width &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 setosa 5.1 3.5 1.4 0.2 2 setosa 4.9 3 1.4 0.2 3 setosa 4.7 3.2 1.3 0.2 4 setosa 4.6 3.1 1.5 0.2 5 setosa 5 3.6 1.4 0.2 6 setosa 5.4 3.9 1.7 0.4 7 setosa 4.6 3.4 1.4 0.3 8 setosa 5 3.4 1.5 0.2 9 setosa 4.4 2.9 1.4 0.2 10 setosa 4.9 3.1 1.5 0.1 # ... with 140 more rows 특정 변수를 제일 앞으로 이동하는 작업은 함수 select()에 everything()을 함께 사용해서 할 수도 있다. &gt; iris_t %&gt;% + select(Species, everything()) # A tibble: 150 x 5 Species Sepal.Length Sepal.Width Petal.Length Petal.Width &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 setosa 5.1 3.5 1.4 0.2 2 setosa 4.9 3 1.4 0.2 3 setosa 4.7 3.2 1.3 0.2 4 setosa 4.6 3.1 1.5 0.2 5 setosa 5 3.6 1.4 0.2 6 setosa 5.4 3.9 1.7 0.4 7 setosa 4.6 3.4 1.4 0.3 8 setosa 5 3.4 1.5 0.2 9 setosa 4.4 2.9 1.4 0.2 10 setosa 4.9 3.1 1.5 0.1 # ... with 140 more rows 4.2.4 새로운 열의 추가: mutate()와 transmute() 데이터 프레임을 구성하고 있는 기존의 변수들을 이용하여 새로운 변수를 만들어 데이터 프레임에 추가해야 할 경우가 종종 있다. 이러한 작업을 수행하는 함수가 mutate()이다. 데이터 프레임이 함수 mutate()의 첫 번째 입력 요소가 되고, 이어서 새로운 변수를 만드는 표현식이 차례로 입력된다. 새롭게 만들어진 변수는 데이터 프레임의 제일 마지막 변수로 추가된다. 만일 새롭게 만들어진 변수로만 데이터 프레임을 구성하고자 한다면 함수 transmute()를 사용하면 된다. 함수 mutate()와 transmute()에서 새로운 변수를 만들 때 유용하게 사용되는 함수들의 목록이 RStudio의 메뉴 Help &gt; Cheatsheets &gt; Data Transformation with dplyr에 잘 정리되어 있다. 예제: mtcars 다음의 조건에 의하여 새로운 변수 kml과 gp_kml을 만들고 데이터 프레임에 첫 번째와 두번째 변수로 추가해 보자. ∙ 변수 kml: 1 mpg(mile per gallon)는 0.43 kml(kilometer per liter) ∙ 변수 gp_kml: kml이 10 이상이면 good, 10 미만이면 bad 연속형 변수 kml을 기반으로 범주의 개수가 두 개인 범주형 변수 gp_kml를 생성하는 작업은 함수 if_else()를 사용하는 것이 효과적이다. 기본적인 사용법은 if_else(condition, true, false)이며 condition이 만족되면 true의 값을 갖고, 아니면 false의 값을 갖게 된다. 조건의 만족 여부에 따라 할당되는 두 가지 값의 유형은 같아야 한다. &gt; as_tibble(mtcars) %&gt;% + mutate(kml = 0.43*mpg, + gp_kml = if_else(kml &gt;= 10, &quot;good&quot;, &quot;bad&quot;) + ) %&gt;% + relocate(kml, gp_kml) %&gt;% + print(n=3) # A tibble: 32 x 13 kml gp_kml mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 9.03 bad 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 9.03 bad 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 9.80 bad 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 # ... with 29 more rows 연속형 변수를 기반으로 범주의 개수가 3개 이상이 되는 범주형 변수를 생성하려는 경우에 함수 if_else()를 사용하는 것은 적절하지 않을 수 있다. 이러한 경우에는 함수 case_when()이 효과적인 대안이 된다. 기본적인 형태는 LHS ~ RHS로서, LHS는 조건이고, RHS에는 할당하려는 값이 된다. 다음 구조에서는 condition_1이 TRUE이면 value_1, condition_1은 FALSE이나 condition_2가 TRUE이면 value_2, 두 조건 모두 FALSE이면 value_3를 출력하게 된다. case_when( condition_1 ~ value_1, condition_2 ~ value_2, TRUE ~ value_3 ) LHS에 제시되는 조건들은 순서대로 평가가 된다. 따라서 가장 좁은 범위의 조건이 가장 먼저 제시되어야 하고, 범위를 넓혀가는 조건이 잇따라 제시되어야 한다. 제시되는 조건의 개수에는 제한이 없다. 또한 RHS에 제시된 값들은 모두 같은 유형이어야 한다. 이제 다음의 변경된 조건으로 변수 gp_kml을 생성해 보자. ∙ 변수 gp_kml: kml이 11 이상이면 excellent, 11 미만 8 이상이면 good, 8 미만이면 bad &gt; as_tibble(mtcars) %&gt;% + mutate(kml = 0.43*mpg, + gp_kml = case_when( + kml &lt; 8 ~ &quot;bad&quot;, + kml &lt; 11 ~ &quot;good&quot;, + TRUE ~ &quot;excellent&quot; + ) + ) %&gt;% + relocate(kml, gp_kml) %&gt;% + print(n=3) # A tibble: 32 x 13 kml gp_kml mpg cyl disp hp drat wt qsec vs am gear carb &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 9.03 good 21 6 160 110 3.9 2.62 16.5 0 1 4 4 2 9.03 good 21 6 160 110 3.9 2.88 17.0 0 1 4 4 3 9.80 good 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 # ... with 29 more rows 만일 새로운 변수만 유지하고 나머지 변수는 모두 삭제하려고 한다면, 함수 transmute()를 사용하면 된다. &gt; as_tibble(mtcars) %&gt;% + transmute(kml = 0.43*mpg, + gp_kml = if_else(kml &gt;= 10, &quot;good&quot;, &quot;bad&quot;) + ) %&gt;% + print(n=3) # A tibble: 32 x 2 kml gp_kml &lt;dbl&gt; &lt;chr&gt; 1 9.03 bad 2 9.03 bad 3 9.80 bad # ... with 29 more rows 4.3 여러 행 자료의 요약: summarise() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

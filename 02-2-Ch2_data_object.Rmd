
## 요인

명목형 혹은 순서형 데이터와 같은 범주형 데이터를 나타내기 위한 구조를
요인(factor)이 라고 한다. 1차원 구조를 갖고 있는 요인이 취하는 값을
수준(level)이라고 하는데, 따라서 요인은 `level` 속성을 가진 벡터라 할 수
있으며 데이터 분석에서 매우 중요한 역할을 하고 있다.

### 요인의 기본 특성

-   명목형 요인의 생성

주어진 벡터를 요인으로 변환시키는 작업은 함수 `as.factor()` 또는
`factor()`로 할 수 있다.

```{r}
gender <- c("Male","Female","Female")
gender_f <- as.factor(gender)
gender_f
```

함수 `as.factor()`는 수준의 개수나 이름 등의 변화 없이 벡터를 요인으로
변환하는 작업을 수행한다. 문자형 벡터에서 요인으로 변환된 `gender_f`의
개별자료에는 인용부호가 없어지고 대신 `level`이 다음 줄에 나타나는데,
알파벳순으로 `Female`이 첫 번째, `Male`이 두 번째가 되었다.

요인이 갖고 있는 수준의 이름 등을 바꾸고자 하는 경우에는 함수
`factor()`을 사용해야 한다. 옵션 `labels`에 수준의 개수와 길이가 같은
문자형 벡터를 지정해 주면 수준의 이름이 변경된다. 예를 들어 다음의
숫자형 벡터 `x`를 요인으로 변환하면 숫자가 수준이 되는데, 이것에 다른
이름을 주는 방법은 다음과 같다.

```{r}
x <- c(1, 3, 2, 2, 1, 4)
factor(x)
x1 <- factor(x, labels = c("A", "B", "C", "D"))
x1
```

옵션 `labels`에 수준의 개수만큼의 문자를 지정하였다. 만일 `labels`에
같은 문자를 반복해서 입력하면 요인의 수준이 합쳐지게 된다. 예를 들어
벡터 `x`의 네 개 수준에서 `(1, 2)`를 `A`로 합치고 `(3, 4)`를 `B`로
합쳐서 두 개 수준으로 병합하고자 한다면 다음과 같이하면 된다.

```{r}
x2 <- factor(x, labels = c("A","A","B","B"))
x2
```

함수 `nlevels()`과 `levels()`를 사용하면 요인의 수준 개수와 이름을
확인할 수 있다.

```{r}
levels(x1)
levels(x2)
nlevels(x1)
nlevels(x2)
```

-   요인의 유형 및 속성

요인의 유형 및 속성을 확인하기 위하여 함수 `typeof()`와 `class()`를
사용해 보자.

```{r}
typeof(gender_f)
class(gender_f)
```

함수 `typeof()`로 확인한 요인의 유형은 정수형 벡터이다. R 내부에서는 첫
번째 수준인 `Female`이 1로, 두 번째 수준인 `Male`이 2로 저장된다. 함수
`class()`는 객체가 가진 부가적인 속성 중 class 속성을 확인하는 함수인데,
이 속성은 객체 지향 프로그램에서 매우 중요한 역할을 하는 속성이다. 예를
들어 함수 `summary()`는 입력되는 객체의 class 속성에 따라 다른 분석을
실시하는 generic 함수 중 하나이다. 함수 `summary()`에 문자형 벡터
`gender`와 요인 `gender_f`를 입력시키면 각 속성에 적합한 다른 분석
결과가 출력됨을 알 수 있다.

```{r}
summary(gender)
summary(gender_f)
```

-   순서형 요인의 생성

순서형 요인을 만들기 위해서는 함수 `factor()`에 `order=TRUE`를
포함시켜야 하고, 원하는 수준의 순서가 알파벳 순서와 다른 경우에는 옵션
`level`에서 사용자가 직접 지정해야 한다.

```{r}
income <- c("Low","Medium","High","Medium")
factor(income, order = TRUE)
factor(income, order = TRUE, level = c("Low","Medium","High"))
```

### 숫자형 벡터를 요인으로 변환

통계분석과정에서 기존의 숫자형 변수를 범주형 변수로 변환시켜야 하는
경우가 종종 있는데, 시험점수(숫자형 변수)를 기반으로 특정 기준에 따라
학점(범주형 변수)을 부여하는 경우가 여기에 해당된다고 하겠다. 이러한
경우 숫자형 변수가 취할 수 있는 값의 전체 범위를 특정 기준에 따라
일정구간으로 나누고 각 구간에 개별 값이 속하면 해당 범주의 값을 갖게하면
된다.

-   논리형 벡터에 의한 변수 변환

예를 들어 0에서 100 사이의 값을 갖는 숫자형 벡터 x를 '90 이상', '90 미만
80 이상', '80 미만'의 세 등분으로 구분하여 각각 A, B, C의 값을 갖는 요인
`cat.x`로 변환해 보자. 변환방법으로 우선 논리형 벡터를 사용하는 방법을
생각해 볼 수 있다. 조금씩 다른 세 가지 방법을 살펴보자. 각 방법 모두 세
번의 벡터 비교가 이루어졌는데, 각 괄호 안에는 비교 결과인 `TRUE`와
`FALSE`로 이루어진 논리형 벡터가 생성되며, 이 논리형 벡터들이 사칙연산에
적용되면 `TRUE`는 1, `FALSE`는 0으로 전환되는 것을 이용하였다.

첫 번째 방법에서는 90 이상의 값들이 세 번의 비교에서 모두 1의 값을 갖게
되지만 80 이상 90 미만의 값들은 두 번의 비교에서만 1의 값을 갖게 되고,
80 미만의 값들은 한 번의 비교에서만 1의 값을 갖게 되는 구조가 된다.
숫자형 벡터를 요인으로 전환하는 작업은 함 수 `factor()`로 수행하였다.
옵션 `labels`를 사용하여 1은 C, 2는 B, 3은 A로 나타내었다.

```{r}
x <- c(80,88,90,93,95,94,100,78,65)
```

```{r}
x_1 <- (x >= 0) + (x >= 80) + (x >= 90)
cat.x <- factor(x_1, labels = c("C","B","A"))
cat.x
```

두 번째 방법은 첫 번째 방법과 반대 방향으로 비교가 이루어지는 것으로 80
미만은 3, 80 이상 90 미만은 2, 그리고 90 이상은 1의 값을 갖게 된다.
생성된 벡터 `x_2`에 대해서는 옵션 `labels`에 지정된 문자의 방향이 첫
번째 방법과는 반대로 되어 있다.

```{r}
x_2 <- (x <= 100) + (x < 90) + (x < 80)
cat.x <- factor(x_2, labels = c("A","B","C"))
cat.x
```

세 번째 방법은 세 번의 비교가 서로 배타적인 관계가 되도록 설정한 것이다.

```{r}
x_3 <- 1*(x >= 0 & x < 80) + 2*(x >= 80 & x < 90) + 3*(x >= 90)
cat.x <- factor(x_3, labels = c("C","B","A"))
cat.x
```

-   함수 `cut()`에 의한 변수 변환

연속형 벡터를 요인으로 전환하는 작업은 함수 `cut()`을 사용하면 비교적
간단하게 할 수 있다. 함수 `cut()`의 옵션으로 `breaks`에는 최솟값과
최댓값을 포함하여 전체 구간을 원하는 그룹으로 구분하는 벡터가 입력되며,
`right`에는 설정된 구간이 오른쪽으로 닫힌 것이면 (a \< x ≤ b) `TRUE`,
왼쪽으로 닫힌 것이면 (a ≤ x \< b) `FALSE`가 입력되고,
`include.lowest`에는 개별 값이 전체 구간의 최솟값(또는 최댓값,
`right=FALSE`의 경우)과 같아도 변환에 포함시 킬 것(`TRUE`)인지
아닌지(`FALSE`)를 지정하게 된다. 옵션 `right`의 디폴트는 `TRUE`이고,
옵션 `include.lowest`의 디폴트는 `FALSE`이다. 요인 수준의 라벨은 옵션
`labels`로 지정할 수 있다.

```{r}
cat.x <- cut(x, breaks=c(0,80,90,100), include.lowest=TRUE,
             right=FALSE, labels=c("C","B","A"))
cat.x
```

옵션 `include.lowest`를 따로 지정하지 않고 디폴트 값을 그대로 사용하고자
한다면 옵션 `break`에 최솟값은 `-Inf`로, 최댓값은 `Inf`로 지정하면 된다.

```{r}
cut(x, breaks=c(-Inf,80,90,Inf),
    right=FALSE, labels=c("C","B","A"))
```

순서형 요인을 원한다면 옵션 `ordered_result=TRUE`를 입력해야 한다.

```{r}
cut(x, breaks=c(-Inf,80,90,Inf),
    right=FALSE, labels=c("C","B","A"), 
    ordered_result=TRUE)
```

## 날짜

시간의 흐름에 따라 데이터를 얻는 경우, 날짜는 중요한 변수가 된다. 날짜를
만드는 방법 은 문자형 벡터에 함수 `as.Date()`를 적용하면 된다. 입력되는
문자형 벡터의 디폴트 형태는 `yyyy-mm-dd`가 된다.

```{r}
x <- as.Date(c("2017-01-01","2018-01-01"))
x
```

출력된 날짜는 문자형 벡터로 보이지만, 사실은 숫자형 벡터로 1970년 1월
1일부터의 날수로 저장되며, 따라서 날짜를 대상으로 사칙연산을 할 수 있다.

```{r}
typeof(x)
x[2]-x[1]
```

날짜의 class 속성은 `Date`이다.

```{r}
class(x)
```

일정한 간격의 날짜를 만들고자 한다면 함수 `seq()`를 사용하는 것이 좋다.
예를 들어 2018년 3월 1일부터 3월 31까지의 기간 동안 7일 간격의 날짜를
구해 보자.

```{r}
s1 <- as.Date("2018-03-01")
e1 <- as.Date("2018-03-31")
seq(from = s1, to = e1, by = 7)
```

증가 폭을 일 단위가 아닌 주 단위 혹은 월 단위로 하는 것도 가능하다.

```{r}
seq(from = s1, by = "week", length = 5)
seq(from = s1, by = "month", length = 5)
seq(from = s1, by = "year", length = 5)
```

## 행렬 및 배열

1차원 구조인 벡터에 부가적인 속성 중 하나인 dim이 추가되면 이차원 구조인
행렬이나, 다차원 구조인 배열이 된다. 따라서 행렬과 배열도 구성요소는
모든 동일한 유형(논리형, 숫자형, 문자형)이어야 한다

### 행렬과 배열의 기본 특성

-   행렬의 생성

행렬은 함수 `matrix()`로 만들 수 있다. 행렬로 전환될 벡터를 먼저
입력하고 이어서 행과 열의 개수를 `nrow=`와 `ncol=`로 지정할 수 있다.
벡터가 먼저 입력되어 행렬을 구성하 는 요소의 전체 개수가 주어진
상태이므로, `nrow` 혹은 `ncol` 둘 중 하나만 사용해도 된다.

```{r}
x <- matrix(1:12, nrow = 3)
x
```

위의 예에서 자료는 열 단위로 채워졌는데, 이것을 행 단위로 채우려면
`byrow=TRUE`를 지정하면 된다

```{r}
y <- matrix(1:12, nrow = 3, byrow = TRUE)
y
```

행렬의 생성에 유용하게 사용되는 또 다른 함수로 `cbind()`와 `rbind()`가
있다. 함수 `cbind()`는 기존의 벡터들을 열 단위로 묶어서 행렬을 만들 때
사용할 수 있고, 함수 `rbind()`는 벡터들을 행 단위로 묶어서 행렬을 구성할
때 사용할 수 있다.

```{r}
x1 <- 1:3
x2 <- 4:6
(A <- cbind(x1,x2))
(B <- rbind(x1,x2))
```

기존의 행렬에 열 또는 행을 추가하는 경우에도 함수 `cbind()`와
`rbind()`를 사용할 수 있다.

```{r}
cbind(A, x3 = 7:9)
rbind(A, 7:8)
```

함수 `cbind()`와 `rbind()`를 사용할 때 결합 대상이 되는 벡터들의 길이가
서로 다르면 순환법칙이 적용된다. 다음 예에서 벡터 `x2`는 한 번, `x3`는
세 번 반복되어 `x1`과 길이를 맞춘 후 결합이 진행된다.

```{r}
x1 <- 1:4 
x2 <- 5:6 
x3 <- 7
cbind(x1,x2,x3)
```

또한 벡터에 함수 `dim()`으로 `dim` 속성을 부가하면, 벡터가 행렬이나
배열로 변환된다.

```{r}
x <- 1:12 
dim(x) <- c(3,4)
x
```

행렬의 행과 열에 이름을 붙일 수 있는데, 이것은 함수 `rownames()`와
`colnames()`로 할 수 있다.

```{r}
rownames(x) <- c("one","two","three")
colnames(x) <- c("a","b","c","d")
x
```

행렬의 경우에는 자료 전체의 개수보다는 행 또는 열의 개수가 더 중요한
정보가 된다. 따라서 함수 `length()`보다는 함수 `nrow()`, `ncol()` 혹은
`dim()`의 사용이 더 적절할 것이다.

```{r}
length(x)
nrow(x)
ncol(x)
dim(x)
```

-   배열의 생성

배열은 함수 `array()`로 만들 수 있다. 배열은 다차원 구조이므로 각 차원에
대한 정의가 함수 `array()` 안에 포함되어야 한다.

```{r}
y <- array(1:24, c(4,3,2))
y
```

각 차원에 대한 이름은 함수 `dimnames()`로 붙일 수 있는데, 문자형
벡터들로 이루어진 리스트를 할당해야 한다.

```{r}
dimnames(y) <- list(X=c("x1","x2","x3","x4"),Y=c("y1","y2","y3"),
                    Z=c("z1","z2"))
y
```

-   행렬과 배열의 인덱싱

벡터의 경우와 동일하게 행렬에서도 자료의 일부분을 선택하는 인덱싱은 매우
중요한 작업이다. 이 경우에도 대괄호가 사용되는데 행렬 `x`의 `i`번째 행,
`j`번째 열에 있는 값은 `x[i,j]`로, `i`번째 행은 `x[i,]`로, `j`번째 열은
`x[,j]`로 나타낸다.

```{r}
x <- matrix(1:12, nrow = 3)
x
x[2,3]
x[1,]
x[,2]
x[1:2,]
x[1:2, 3:4]
```

배열의 인덱싱도 대괄호가 사용되며, 차원 수만큼의 첨자가 필요하다. 다음은
3차원 배열에 대한 인덱싱 예제이다.

```{r}
y <- array(1:24, c(4,3,2))
y[,1,1]
y[,,1]
```

### 행렬의 연산

행렬의 연산은 선형대수 문제뿐만이 아니라 다양한 통계분석을 진행하는
과정에서 종종 사용된다. Table \@ref(tab:matrix-func)에는 행렬의 연산에서
중요하게 사용되는 함수 및 연산자들이 정리되어있다. 표에서 `A`와 `B`는
행렬을, `x`와 `b`는 벡터를, 그리고 `k`는 스칼라를 의미한다.

```{r matrix-func, echo=FALSE}
col1 <- c(paste('+', '-', '*', '/', '^', sep = "  "), 'A %*% B', 'colMeans(A)', 'colSums(A)', 
                'diag(A)', 'diag(x)', 'diag(k)', 'eigen(A)', 'rowMeans(A)', 'rowSums(A)',
                'solve(A)', 'solve(A, b)','t(A)')
col2 <- c('행렬을 구성하는 숫자 각각에 적용', '행렬 A와 B의 곱하기', 
          '행렬 A 각 열의 평균값으로 구성된 벡터', '행렬 A 각 열의 합으로 구성된 벡터',
          '행렬 A의 대각선 원소로 구성된 벡터', '벡터 x를 대각선 원소로 하는 대각행렬',
          'k * k 단위행렬', '행렬 A의 고유값과 고유벡터로 구성된 리스트', 
          '행렬 A 각 행의 평균값으로 구성된 벡터', '행렬 A 각 행의 합으로 구성된 벡터',
          '행렬 A의 역행렬', '연립방정식 Ax=b의 해', 
          '행렬 A의 전치')
tab1 <- tibble::tibble(`연산자 및 함수` = col1, `기능` = col2)
knitr::kable(tab1, "pipe", caption = "행렬의 연산에 유용하게 사용되는 함수 및 연산자")
```

다음은 행렬 연산에 대한 이해를 돕기 위해 몇몇 함수 및 연산자들에 대한
간단한 사용 예를 보인 것이다.

```{r}
(A <- matrix(1:4, 2, byrow = TRUE))
(B <- matrix(5:8, 2, byrow = TRUE))
```

```{r}
A * B
A %*% B
t(A) 
```

```{r}
cbind(A,B)
rbind(A,B)
```

```{r}
colMeans(A)
rowSums(A)
```

```{r}
diag(A)
x <- c(10,20)
diag(x)
diag(2)
```

```{r}
solve(A)
solve(A)%*%A
b <- c(5,6)
solve(A,b)
```

## 데이터 프레임 {#section-dataframe}

데이터 세트는 행과 열의 2차원 구조를 갖고 있으며, 하나의 열에는 같은
유형의 자료만이 올 수 있으나, 각각의 열은 서로 다른 유형의 자료를 가질
수 있는 구조이다. 이러한 통계 데이터 세트를 위한 데이터 객체가 바로
데이터 프레임이다. 따라서 가장 빈번하게 사용되는 데이터 객체가 된다.

### 데이터 프레임의 생성

함수 `data.frame()`에 이름을 붙인 벡터를 차례로 입력함으로써 데이터
프레임을 만들 수 있다. 벡터 `x`와 `y`가 데이터 프레임 `df1`의 열(변수)이
되었고, 행 번호가 자동으로 붙은 것을 알 수 있다.

```{r}
df1 <- data.frame(x = c(2,4,6), y = c("a","b","c"))
df1
```

이 때 입력하는 벡터의 길이는 반드시 같아야 한다.

```{r, error=TRUE}
data.frame(x = c(2,4), y = c("a","b","c"))
```

길이가 1인 벡터의 경우에는 순환 법칙이 적용되어 길이가 긴 벡터의
길이만큼 반복되어 입력된다.

```{r}
data.frame(x = 1, y = c("a","b","c"))
```

함수 `str()`은 데이터 객체의 특성을 살펴볼 수 있는 함수이다. 함수
str()을 이용하여 데이터 프레임 `df1`의 특성을 살펴보자. 관찰값(행)과
변수(열)의 개수가 표시되고 각 변수의 이름과 유형 및 자료의 처음 몇 개의
값이 출력된다.

```{r}
str(df1)
```

데이터 프레임은 행렬과 같이 2차원 구조여서 함수 `rownames()`와
`colnames()`의 역할은 행렬과 동일하다. 다만 데이터 프레임에서는 함수
`names()`가 함수 `colnames()`와 같은 역할을 하고 있으며, 함수
`length()`도 전체 데이터의 개수가 아닌 열의 개수, 즉 변수의 개수를
구한다.

```{r}
colnames(df1)
names(df1)
rownames(df1)
length(df1)
```

### 데이터 프레임의 인덱싱

함수 `typeof()`로 확인할 수 있는 데이터 프레임의 유형은 리스트이다.

```{r}
typeof(df1)
```

따라서 리스트에 적용되는 인덱싱 방법을 사용할 수 있다. 또한 데이터
프레임은 행렬과 같이 2차원 구조를 갖고 있기 때문에 행렬에 적용되는
인덱싱 방법도 사용할 수도 있다.

리스트에서는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호를 인덱싱 기호로
사용하고 있다. 즉, `df1[a]` 또는 `df1[[a]]`의 형태가 된다. 데이터
프레임에 이 방식을 적용하면, 데이터 프레임을 구성하고 있는 열, 즉 변수
중 일부분을 선택할 수 있다. 대괄호 안에 들어가는 벡터 `a`는 숫자형 또는
문자형이 되는데, 숫자형인 경우에는 선택할 열의 위치를, 문자형인 경우에는
선택할 열의 이름을 지정하면 된다. 하나의 대괄호 기호와 겹쳐진 두 개의
대괄호 기호의 차이는 선택된 객체의 구조인데, 하나의 대괄호 기호로 선택한
결과는 항상 데이터 프레임이 되고, 겹쳐진 두 개의 대괄호 기호로 선택한
결과는 항상 벡터가 된다. 따라서 여러 변수를 선택할 때에는 하나의 대괄호
기호를 사용해야 한다.

```{r}
df1[1]
df1[[1]]
df1["x"]
df1[["x"]]
```

데이터 프레임을 대상으로 통계분석을 할 때에는 분석 대상이 되는 개별
변수를 벡터 형태로 선택하는 경우가 많다. 따라서 `df1[[“x”]]`의 형태가
자주 사용되는데, 이것을 조금 더 편리하게 하는 방식이 `$` 기호의
사용이다. 즉 `df1[[“x”]]`은 `df1$x`와 동일하다.

```{r}
df1$x
```

데이터 프레임도 행렬과 같은 2차원 구조이므로 행렬의 인덱싱 방법을
동일하게 적용할 수 있다. 이 경우에는 선택한 변수의 개수에 따라 결과
객체의 구조가 결정되는데, 선택한 변수가 하나이면 벡터가 되고 두 개
이상이면 데이터 프레임이 된다.

```{r}
df1[,1]
df1[1,]
df1[c(1,2),]
```

### 함수 `with()`

데이터 프레임의 개별 변수를 벡터 형태로 선택할 때 겹쳐진 두 개의 대괄호
기호 또는 `$` 기호를 사용하여 개별 변수를 선택할 수 있다. 그러나 이러한
방법은 변수를 선택할 때 마다 데이터 프레임의 이름을 함께 입력해야 하는
번거로운 방법이기도 하다. 데이터 프레임이라는 것이 가장 빈번하게
사용되는 구조의 데이터 객체이기 때문에 조금 더 편하게 변수에 접근할 수
있는 방법이 필요한데, 이러한 경우에 사용할 수 있는 함수가 바로 `with()`
이다. 함수 `with()`의 일반적인 사용 형태는
`with(데이터 프레임, R 명령문)`으로, 함수 `with()` 안에서는 지정된
데이터 프레임에 속한 변수를 인덱싱 기법 없이 그냥 사용할 수 있다.

데이터 프레임 `airquality`는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의
질과 관련된 몇몇 변수들로 이루어진 데이터 프레임이다. 처음 3개 케이스를
출력해 보자.

```{r}
head(airquality, n = 3)
```

데이터 프레임 `airquality`에 있는 변수 `Temp`를 표준화시켜보자. 변수
`Temp`는 데이터 프레임 `airquality`의 열 벡터이기 때문에 인덱싱 기법을
사용하지 않은 상태에서는 R이 변수 `Temp`를 찾지 못한다. 따라서 다음에
주어진 첫 번째 문장에서 오류가 발생한 것이다. 두 번째 문장이 데이터
프레임의 인덱싱이 사용된 방법인데, 데이터 프레임의 이름을 여러 번
입력해야 한다는 것이 번거로운 작업이 될 수 있다. 세 번째에서는 함수
`with()` 안에 `airquality`를 한 번만 선언하고 이어지는 R 명령문에서는
변수 이름만을 사용하여 표준화 과정을 실행시켰다. 두 번째와 세 번째
명령문의 실행 결과는 당연히 동일하며, 더 간편한 방법을 선택하는 것이
좋을 것이다.

```{r, error=TRUE}
z.Temp <- (Temp - mean(Temp))/sd(Temp)
z.Temp <- (airquality$Temp - mean(airquality$Temp))/sd(airquality$Temp)
z.Temp <- with(airquality, (Temp - mean(Temp))/sd(Temp))
```

## Tibble: 개선된 형태의 데이터 프레임

`Tibble`은 `tidyverse`에 속한 패키지들이 공통적으로 사용하는 개선된
형태의 데이터 프레임이다. 기존의 데이터 프레임에 몇 가지 기능을
추가함으로써 조금 더 사용하기 편리한 형태를 취하고 있다. `Tibble`과
관련된 작업을 하기 위해서는 패키지 `tibble`을 불러와야 하는데,
`Core tidyverse`에 속한 패키지이므로 `library(tidyverse)`를 실행하면
다른 `core tidyverse`패키지들과 함께 세션에 올라오게 된다.

```{r}
library(tidyverse)
```

### Tibble 생성

기존의 전통적인 데이터 프레임을 tibble로 전환하기 위해서는 함수
`as_tibble()`을 사용하면 된다.

```{r}
as_tibble(cars)
```

앞 절에서 살펴보았던 전통적인 데이터 프레임의 출력 형태와는 많이 다른
모습을 보이고있다.

개별 벡터를 이용한 tibble의 생성은 함수 `tibble()`로 할 수 있다. 길이가
1인 스칼라는 순환법칙이 적용되며, 함께 입력된 변수를 이용하여 다른
변수를 만들 수 있다.

```{r}
tibble(x = 1:3, y = x + 1, z = 1)
```

함께 입력되는 변수를 이용하여 다른 변수를 만들 수 있는 기능은 매우
유용하게 사용될 수 있는데, 함수 `data.frame()`에서는 가능하지 않던
것이다.

```{r, error=TRUE}
data.frame(x = 1:3, y = x+1)
```

함수 `tibble()`에서는 열(변수) 단위로 자료를 입력해야 했는데, 경우에
따라서 행 단위로 입력하는 것이 더 편리할 때가 있다. 이런 경우에는 함수
`tribble()`을 사용해야 한다. 첫 줄의 변수 이름은 기호 `~`으로 시작되는
공식으로 정의되며, 각 자료는 콤마로 구분된다.

```{r}
tibble(x = 1:3, y = letters[1:3])
```

### Tibble과 전통적인 데이터 프레임의 차이

Tibble과 전통적인 데이터 프레임은 출력 방식과 자료의 부분을 선택하는
인덱싱 방식에서 차이가 있으며 행 이름(row name)를 다루는 방식에서도
차이가 있다.

-   출력 방식의 차이

먼저 출력 방식에서 보면 전통적인 데이터 프레임은 대규모 데이터를
대상으로 하는 경우에 불편한 측면이 있다. 전통적 데이터 프레임은 가능한
모든 자료를 화면에 출력하게 되어 있는데, 이런 출력 방식은 대규모 자료의
경우 내용을 확인하기 매우 어려운 측면이 있다. 이에 반하여 tibble은 처음
10개 케이스만을 출력하며, 변수도 화면의 크기에 따라 출력되 는 개수를
조절하여, 한 화면에서 자료의 특성을 비교적 편하게 확인할 수 있다.

```{r}
as_tibble(MASS::Cars93)
```

변수 이름과 더불어 변수의 유형을 바로 밑 줄에 표시하고 있으며, 화면 크기
때문에 자료가 출력되지 않은 변수는 이름과 유형을 가장 밑에 나열해
두었다. 만일 조금 더 많은 자료를 확인하고자 한다면 함수 `print()`를
옵션과 함께 사용하면 된다. 예를 들어 처음 20개 케이스와 모든 변수를 다
출력하고자 한다면 다음과 같이 옵션 `n = 20`과 `width = Inf`를 사용한다.

```{r, eval=FALSE}
print(as_tibble(MASS::Cars93), n = 20, width = Inf)
```

-   행 이름 처리 방식의 차이

자료가 출력될 때 전통적인 데이터 프레임의 경우에는 행 이름이 함께
출력되지만, tibble에서는 생략이 된다. 데이터 프레임 `mtcars`를 출력해
보자.

```{r}
head(mtcars)
```

```{r}
mtcars_t <- as_tibble(mtcars)
print(mtcars_t, n = 6)
```

생략된 행 이름은 함수 `rownames_to_column()`을 사용하면 변수로 전환할 수
있다.

```{r}
mtcars_d <- rownames_to_column(mtcars, var="rowname")
mtcars_t <- as_tibble(mtcars_d)
mtcars_t
```

-   인덱싱 방법의 차이

데이터 프레임의 일부분을 선택하는 인덱싱 기법은 tibble에서도 동일하게
적용된다. 한 가지 차이점은 기호 `$`을 이용하는 경우인데, 데이터
프레임에서는 변수이름이 부분 매칭만 되어도 선택되지만, tibble에서는
엄격한 기준이 적용되어 변수의 전체 이름을 다 사용해야 선택된다.

```{r}
df1 <- data.frame(xyz = 1:3, abc = letters[1:3])
df1$x

tb1 <- as_tibble(df1)
tb1$x
tb1$xyz
```

흔한 상황은 아니지만, 만일 tibble을 입력했을 때 처리를 못하는 함수가
있다면, tibble을 전통적인 데이터 프레임으로 전환해야 한다. 데이터
프레임으로의 전환은 함수 `as.data.frame()`을 사용하면 된다. 이러한
전환이 필요한 상황 중 하나는 대괄호를 이용하여 행렬 방식으로 인덱싱을
실시하는 경우이다. 전통적 데이터 프레임의 경우 행렬 방식으로 자료를 부분
선택할 때 선택된 변수가 두 개 이상이면 데이터 프레임이 유지되지만,
선택된 변수가 한 개라면 벡터가 된다. 즉, `mtcars[,1:2]`는 데이터
프레임이지만 `mtcars[,1]`은 벡터가 된다는 것이다. 반면에 tibble의
경우에는 선택되는 변수의 개수와 관계 없이 그대로 tibble 속성이 유지가
된다. 따라서 `mtcars_t[,1:2]`와 `mtcars_t[,1]` 모두 tibble이며,
`mtcars_t[1,1]`도 tibble 속성을 그대로 유지하고 있다. 따라서 데이터
프레임에서 행렬 방식으로 하나의 변수를 선택했을 때 벡터가 되어야 작동이
되는 경우라면 tibble을 사용해서는 안 되는 상황이 되는 것이다.

## 리스트 {#section-list}

리스트는 R에서 가장 포괄적인 형태의 데이터 구조이다. 그 구성요소로서
벡터, 배열, 데이터 프레임, 함수, 다른 리스트 등이 될 수 있는, 한마디로
여러 다른 유형의 객체들을 하부 구조로 하여 한데 묶은 또 다른 객체라고 할
수 있다.

-   리스트의 생성

리스트는 함수 `list()`로 만들 수 있다. 문자형 벡터, 숫자형 벡터, 데이터
프레임과 다른 리스트로 이루어진, 리스트 `x`를 만들어보자.

```{r}
x <- list(a = c("one","two","three"), b = 1:3, c = list(-1,-5),
          d = data.frame(x1 = c("s1","s2"), x2 = 1:2))
x
```

-   리스트의 인덱싱

리스트의 인덱싱 기호는 하나의 대괄호 또는 겹쳐진 두 개의 대괄호이다.
대괄호 하나를 사용하여 선택하면 원래의 구조가 그대로 유지되어 항상
리스트가 되고, 겹쳐진 두 개의 대괄호를 사용하면 해당되는 구성요소의 객체
구조가 된다. 즉, `x[1]`은 `x`의 첫 번째 구성 요소인 문자형 벡터 하나로만
이루어진 리스트가 되며, `x[[1]]`은 `x`의 첫 번째 구성요소인 문자형
벡터가 된다.

```{r}
x[1]
x[[1]]
```

```{r}
str(x[1])
str(x[[1]])
```

따라서 `x[[4]]`는 네 번째 구성요소인 데이터 프레임이 되는 것이며,
`x[[4]][2]`은 해당 데이터 프레임의 두 번째 열만으로 구성된 데이터
프레임이 되고, `x[[4]][[2]]`는 숫자형 벡터가 된다.

```{r}
x[[4]]
x[[4]][2]
x[[4]][[2]]
```

데이터 프레임의 경우와 같이 리스트에서도 `$` 기호를 사용하여 인덱싱을 할
수 있다. 즉, `x$a`는 `x[["a"]]`와 같은 것이며, 따라서 `x$a[1:2]`는
`x[["a"]][1:2]`와 같은 것이다.

```{r}
x$a
x$a[1:2]
```

리스트는 매우 중요한 구조 형태인데, 그것은 산만하게 흩어져 있는 정보들을
간편하게 묶을 수 있다는 장점과 대부분의 R 함수들이 실행결과를 리스트의
형태로 생성하기 때문이다. 앞으로 많은 예제를 통하여 R 함수들의
실행결과로 생성되는 리스트를 볼 수 있을 것이다. 리스트로 생성된 결과물
중 우리가 원하는 결과는 대부분의 경우 그 일부분이 될 것이기 때문에
리스트의 인덱싱 기법을 사용하여 적절하게 선택해야 할 것이다.

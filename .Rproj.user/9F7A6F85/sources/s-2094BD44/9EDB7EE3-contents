

# `dplyr`에 의한 데이터 다듬기

R에 입력된 데이터 세트는 대부분의 경우 바로 통계분석이 가능한 상태가 아니다. 분석에
필요한 적절한 변수가 없거나, 특정 조건을 만족하는 자료만을 선택해야 하거나, 자료의
순서를 바꿔야 하거나, 그룹별로 자료를 합치거나 또는 나눠야 하는 등등의 작업이 필요한
경우가 대부분이다. 이러한 데이터 다듬기는 최적의 통계 예측모형적합 등을 위해 반드시
필요한 절차이지만, 시간이 매우 많이 소요되는 힘든 작업이다. 따라서 일관된 법칙에 따라 편리하고 효율적으로 적용할 수 있는 데이터 다듬기 기법이 절실하게 필요한 상황이라고 하겠다.

통계 데이터 세트는 변수가 열, 관찰값이 행을 이루고 있는 2차원 구조를 가지고 있으며
데이터 프레임으로 입력된다. 이 장에서 살펴볼 내용은 패키지 `dplyr`에서 수행할 수 있는
다양한 데이터 프레임 다듬기 기법이다. 먼저 데이터 프레임 다듬기 작업에 사용되는 매우
중요하면서도 기본적인 `dplyr` 함수들을 살펴볼 것이다. 이어서 이러한 기본 `dplyr` 함수들
이 그룹으로 구분된 데이터에 대해서는 어떻게 작용을 하는지 살펴볼 것이며, 여러 개의
변수들을 대상으로 반복적으로 실행해야 하는 동일한 작업을 함수 `across()`를 이용하면
얼마나 간편하게 할 수 있는지를 살펴볼 것이다. 또한 행 단위로 작업이 이루어져야 하는
경우에 함수 `rowwise()`가 어떤 역할을 하는지도 살펴볼 것이다.

기본 `dplyr` 함수들은 세 가지 그룹으로 나누어 볼 수 있다. 함수 `filter()`, `slice()`,
`arrange()`, `distinct()`와 같이 데이터 프레임의 행을 작업 대상으로 하는 함수가 있고,
함수 `select()`, `rename()`, `mutate()`, `relocate()`와 같이 열을 대상으로 작업을 하는 
함수가 있으며, 요약 통계량을 계산하는 함수 `summarise()`가 있다.

기본 `dplyr` 함수들이 공통으로 갖고 있는 특징은 데이터 프레임(또는 tibble)이 함수들의 첫 번째 입력요소라는 것이다. 두 번째 특징은 각 함수 안에서 입력된 데이터 프레임의
변수를 인덱싱 기호(`$`) 없이 사용할 수 있다는 것이다. 마지막 특징은 이 함수들이 생성하는 결과는 또 다른 데이터 프레임(또는 tibble)이라는 것이다. 기본 함수들이 갖고 있는 이러한 특징을 이용해서 조금 더 효율적인 프로그램이 가능하도록 dplyr에서는 pipe 기능을 사용할 수 있다.

* Pipe 기능

Pipe 기능이란 한 명령문의 결과물을 바로 다음 명령문의 입력 요소로 직접 사용할 수 있도록 명령문들을 서로 연결하는 기능을 의미한다. 이것이 가능하다면, 분석 중간 단계로
생성되는 무수한 객체들을 따로 저장할 필요가 없기 때문에 프로그램 자체가 매우 깔끔하게 정리되며, 분석 흐름을 쉽게 이해할 수 있게 된다. Pipe 연산자 `%>%`는 `tidyverse`에 속한 패키지인 `magrittr`에서 정의된 것으로 `tidyverse`에 속한 다른 패키지에서도 사용이 가능하다. RStudio에서 pipe 연산자 `%>%`의 입력은 Shift+Ctrl+M 키를 함께 누르면 된다.

기본적인 형태는 `lhs %>% rhs`인데, `lhs`는 데이터 객체이거나 데이터 객체를 생성하는
함수가 되고, `rhs`는 `lhs`를 입력 요소로 하는 함수가 된다. 예를 들어 `x %>% f()`는 객체 `x`를 함수 `f()`의 입력 요소로 하는 `f(x)`를 의미한다. 만일 `rhs`에 다른 요소가 있다면 `lhs`는
`rhs`의 첫 번째 입력 요소가 된다. 따라서 `x %>% f(y)`는 `f(x,y)`를 의미한다. 만일 `lhs`가
`rhs`의 첫 번째 요소가 아닌 경우에는 원하는 위치에 점(.)을 찍어야 한다. 예를 들어, `x
%>% f(y,.)`은 `f(y,x)`를 의미한다.


## 행을 작업 대상으로 하는 함수

### 조건에 의한 행 선택: `filter()`

함수 `filter()`를 이용하면, 주어진 데이터 프레임에서 특정한 조건을 만족하는 행을 선택
할 수 있다. 조건을 설정할 때는 비교 연산자(`>, >=, <, <=, !=, ==`)와 논리 연산자(`&, |,
!`)가 사용되며, 연산자 `%in%`이 매우 유용하게 사용된다. 
예제를 통해 자세한 사용법을 확인해 보자.

* 예제: `mtcars`

변수 `mpg`의 값이 30 이상인 자동차를 선택해 보자. 함수 `filter()`에 전통적인 데이터 프레임을 입력하면 결과로 전통적인 데이터 프레임이 출력되고, tibble을 입력하면 결과가
tibble로 출력된다. 데이터 프레임 `mtcars`를 tibble로 전환하고 선택 조건과 더불어 함수
`filter()`에 입력해 보자.

```{r}
library(tidyverse)
```

```{r}
mtcars_t <- as_tibble(mtcars)
mtcars_t %>% filter(mpg >= 30)
```

변수 `mpg`의 값이 30 이상이고 변수 wt의 값이 1.8 미만인 자동차를 선택해 보자. 
논리 연산자 `&` 대신에 콤마(,)를 사용할 수 있다.

```{r}
mtcars_t %>% filter(mpg >= 30, wt < 1.8)
```

변수 `mpg`의 값이 30 이하이고, 변수 `cyl`의 값이 6 또는 8이며, 변수 `am`의 값이 1인 자동차를 선택해 보자. 이 경우에, 변수 `cyl`의 값이 6 또는 8인 사건에 대하여 논리 연산자를
사용해서 `cyl == 6|cyl == 8`으로 조건을 설정하는 것보다는, `cyl %in% c(6,8)`로 쓰는 것이 훨씬 간단한 방법이 된다.

```{r}
mtcars_t %>% filter(mpg <= 30, cyl %in% c(6,8), am == 1)
```

변수 `mpg`의 값이 `mpg`의 중앙값과 $Q_{3}$ 사이에 있는 자동차를 선택해 보자. 
여기서 $Q_{3}$는 0.75분위수를 의미하는 것으로서, $p$ 분위수란 전체 데이터 중 $(100 \times p)$%데이터보다는 크고, 나머지 $(100 \times (1-p))$% 데이터보다는 작은 수를 의미한다. 
분위수의 계산은 함수 `quantile()`로 하는데, 벡터 `x`의 0.75분위수의 계산은 `quantile(x, probs=0.75)`로 할 수 있다.

```{r}
mtcars_t %>% 
  filter(
    mpg >= median(mpg), mpg <= quantile(mpg, probs = 0.75)
  )
```

벡터 `x`가 특정 두 숫자 사이에 있는지를 확인하는 방법은 `x >= left & x <= right`가 되는데, 이것을 함수 `between()`을 이용해서 `between(x,left,right)`로 할 수 있다. 

```{r}
between(1:5, 2, 4)
```


따라서 위 예제는 다음과 같이 실행해도 동일한 결과를 얻는다.

```{r}
mtcars_t %>% 
  filter(
    between(mpg, median(mpg), quantile(mpg, probs = 0.75))
    )
```


* 예제: `airquality`

데이터 프레임 `airquality`는 1973년 5월부터 9월까지 미국 뉴욕시의 공기의 질과 관련된
조사 결과를 담은 데이터 세트이다. `airs`라는 이름의 tibble로 전환하고, 처음 5개 케이스
를 출력해 보자.

```{r}
airs <- as_tibble(airquality) %>% 
  print(n = 3)
```

변수 `Ozone` 또는 `Solar.R`이 결측값인 행을 선택해 보자. 결측값의 확인은 함수
`is.na()`로 할 수 있다.

```{r}
airs %>% 
  filter(is.na(Ozone) | is.na(Solar.R)) %>% 
  print(n = 5)
```


### 위치에 의한 행 선택: `slice()` 및 그와 관련된 함수

위치에 의한 행 선택이란 데이터 프레임에서 선택하고자 하는 행 번호를 지정해서 선택하는 것을 의미한다.

* 함수 `slice()`에 의한 행 선택

함수 `slice()`에는 행의 번호를 직접 지정해서 특정 행을 선택하거나 제거할 수 있다. 
양의 정수를 입력하면 해당 위치의 행이 선택되고, 음의 정수를 입력하면 해당 위치의 행이
제거된다. 입력되는 정수는 모두 양수이거나 모두 음수이어야 한다. 데이터 프레임 `iris`를
tibble로 전환하고 5번째 행부터 10번째 행까지 선택해 보자.

```{r}
iris_t <- as_tibble(iris)
iris_t %>% slice(5:10)
```

이번에는 5번째 행부터 10번째 행을 제거해 보자.

```{r}
iris_t %>% 
  slice(-(5:10)) %>% 
  print(n = 3)
```

이번에는 `iris`의 마지막 행을 선택해 보자. 이 경우 유용하게 사용될 함수가 `n()`이다.
이 함수는 데이터 프레임의 행의 개수를 세는 함수로서 단독으로는 사용될 수 없고 `dplyr`
기본 함수들과 함께 사용되어야 한다.

```{r}
iris_t %>% 
  slice(n())
```


* 함수 `slice_head()`와 `slice_tail`()에 의한 행 선택

데이터 프레임의 처음 몇 개 행을 선택하거나 마지막 몇 개 행을 선택하고자 할 때 사용되는 함수이다. 행의 개수를 지정하는 경우에는 `n`을 사용하고 행의 비율을 지정하는 경우에
는 `prop`를 사용하면 된다. 데이터 프레임 `iris`의 처음 3개 행과 마지막 3개 행을 각각 선택해 보자.

```{r}
iris_t %>% 
  slice_head(n = 3)
```

```{r}
iris_t %>% 
  slice_tail(n = 3)
```


* 함수 `slice_sample()`에 의한 행 선택

데이터 프레임의 일부 행을 단순임의추출방법으로 선택할 때 사용되는 함수이다. 
행의 개수를 지정해서 추출하는 경우에는 `n`을 사용하고, 행의 비율을 지정해서 추출하는 경우에는 `prop`를 사용하면 된다. 
두 함수 모두 비복원추출이 디폴트로 적용되며, 만일 복원추출을 원한다면, `replace=TRUE`를 입력하면 된다. 
데이터 프레임 `iris`에서 3개 행을 임의추출해 보자. 또한 전체 행 중 2%의 행을 비복원추출과 복원추출로 각각 선택해 보자.

```{r}
iris_t %>% 
  slice_sample(n = 3)
```

```{r}
iris_t %>% 
  slice_sample(prop = 0.02)
```

```{r}
iris_t %>% 
  slice_sample(prop = 0.02, replace = TRUE)
```


* 함수 `slice_max()`와 `slice_min()`에 의한 행 선택

특정 변수가 가장 큰 값을 갖거나 혹은 가장 작은 값을 갖는 행을 선택할 때 사용되는 
함수이다. 기준으로 사용할 변수를 입력하고 이어서 행의 개수를 지정하는 경우에는 `n`을, 
행의 비율을 지정하는 경우에는 `prop`를 입력하면 된다. 데이터 프레임 `iris`에서 변수
`Sepal.Width`의 값이 가장 큰 두 개 행을 선택해 보자.

```{r}
iris_t %>% 
  slice_max(Sepal.Width, n = 2)
```

이번에는 `Petal.Length`의 값이 가장 작은 두 개 행을 선택해 보자.

```{r}
iris_t %>% 
  slice_min(Petal.Length, n = 2)
```


### 행의 정렬: `arrange()`

함수 `arrange()`는 특정 변수를 기준으로 데이터 프레임의 행을 재배열할 때 사용된다. 
함수에는 정렬의 기준이 되는 변수를 입력하면 되는데, 2개 이상의 정렬 기준 변수를 입력하게 되면 추가된 변수는 앞선 변수가 같은 값을 갖는 행들의 정렬 기준으로 사용된다. 
정렬은 오름차순이 디폴트이며, 내림차순으로 배열하고자 할 때에는 기준 변수를 
함수 `desc()`와 함께 사용해야 한다.

* 예제: `mtcars`

데이터 프레임 `mtcars`를 tibble로 전환하고 변수 `mpg`의 값이 좋지 않은 자동차 순서로
다시 배열해 보자. 연비가 좋지 않다는 것은 연비가 낮다는 것을 의미하는 것이므로 변수
`mpg`를 오름차순 정렬 변수로 사용하면 된다.

```{r}
mtcars_t <- as_tibble(mtcars)
mtcars_t %>% 
  arrange(mpg)
```

데이터 프레임 `mtcars_t`를 변수 `mpg`의 값이 좋지 않은 자동차 순서로 다시 배열을
하되, `mpg` 값이 같은 자동차의 경우에는 변수 `wt`의 값이 높은 자동차부터 배열해 보자. 
변수 `wt`를 두 번째 정렬 기준 변수로 입력하되, 내림차순 정렬이 필요하므로 함수 `desc()`를
이용한다.

```{r}
mtcars_t %>% 
  arrange(mpg, desc(wt))
```


* 예제: `airquality`

데이터 프레임 `airquality`를 tibble로 전환하고, 5월 1일부터 5월 10일까지의 자료만을
대상으로 변수 `Ozone`의 값이 가장 낮았던 날부터 다시 배열해 보자.

```{r}
airs_1 <- as_tibble(airquality) %>%  
  filter(Month == 5, Day <= 10) 
airs_1 %>% 
  arrange(Ozone)
```

위의 정렬 결과를 보면 변수 `Ozone`이 결측값인 행이 가장 뒤로 배열되어 있다. 이것이
문제는 아니지만, 어떤 경우에는 결측값인 행을 가장 앞으로 배열하는 것이 필요할 때도
있다. 데이터 프레임 `airs_1`을 변수 `Ozone`이 결측값인 행부터 다시 배열해 보자. 이것은
배열 기준으로 논리형 벡터를 사용해야 되는 문제인데, `TRUE`와 `FALSE`의 배열에서 `FALSE`가
우선 순위에 있기 때문에 `!is.na(Ozone)`을 배열 기준으로 사용하면 된다.

```{r}
airs_1 %>% 
  arrange(!is.na(Ozone))
```

이번에는 데이터 프레임 `airs_1`을 변수 `Ozone`의 값이 가장 높은 날부터 다시 배열하되
결측값이 있는 행을 가장 앞으로 배열해 보자. 
이때는 `!is.na(Ozone)`을 첫 번째 배열 기준으로 하여 결측값이 있는 행을 가장 앞으로 배치하고, `desc(Ozone)`을 두 번째 배열 기준으로 입력해서 결측값이 아닌 행들을 변수 `Ozone`의 내림차순으로 다시 배열해야 된다.

```{r}
airs_1 %>% 
  arrange(!is.na(Ozone), desc(Ozone))
```


### 중복된 행의 제거: `distinct()`

함수 `distinct()`는 중복 입력된 행을 제거할 때 사용된다. 
함수에는 중복 여부를 결정할 변수를 입력하면 되는데, 입력한 변수가 없다면 모든 변수들을 대상으로 중복 여부를 결정한다. 
옵션 `.keep_all=TRUE`가 지정되면 데이터 프레임의 모든 변수가 유지되는데, 
이 경우에는 중복된 행 중에 처음 나타난 행이 유지된다. 
단순한 형태의 데이터 프레임으로 함수 `distinct()`의 작동 방식을 살펴보자.

```{r}
df1 <- tibble(id = rep(1:3, times = 2:4), x1 = c(1:2,1:3,1:4))
df1
```

변수 `id`가 중복되지 않은 행들을 선택해 보자. 중복된 행 중에 처음 나타난 행이 유지됨을 알 수 있다.

```{r}
df1 %>% 
  distinct(id, .keep_all = TRUE)
```

변수 `id`가 중복된 행 중에 첫 번째 위치한 행이 아닌, 변수 x1이 가장 큰 값을 갖는 행을 선택해 보자. 
이 문제는 변수 `id`가 중복된 행들을 변수 `x1`의 내림차순으로 정렬한 데이터 프레임을 대상으로 중복된 행을 제거하면 된다.

```{r}
df1 %>% 
  arrange(id, desc(x1)) %>% 
  distinct(id, .keep_all = TRUE)
```

함수 `distinct()`로 모든 변수의 값이 중복된 행을 제거하는 예제를 살펴보자.

```{r}
df2 <- tibble(id = rep(1:3, each = 2), x1 = c(2,2,3,1,4,4))
df2
df2 %>% 
  distinct()
```


## 열을 작업 대상으로 하는 함수

### 열의 선택: `select()`

데이터 세트의 크기가 커짐에 따라 변수의 개수가 수백 또는 수천이 되는 경우를 접하는
것이 더 이상 드문 상황은 아니다. 
이러한 경우, 분석에 필요한 변수를 선택하여 데이터 세트의 크기를 줄이는 것은 매우 중요한 작업이 된다. 
함수 `select()`에서는 패키지 `tidyselect`에 의해 구현되는 효과적인 변수 선택 방법을 이용할 수 있다. 
여기에서 작동되는 `<tidy-select>` 방식은 기본적으로 변수들의 집합을 구성하는 것으로 생각하면 된다. 
구체적인 선택 방법은 열 번호 또는 열 이름에 의한 방법과 변수의 유형에 의한 방법, 그리고 변
수 선택과 관련된 몇몇 함수들을 이용하는 방법으로 구분할 수 있다.

1. 열 번호(또는 열 이름)에 의한 선택

가장 기본적인 방법은 열 번호를 콤마로 구분하여 나열하는 것이다. 이렇게 나열된 열들은 차례로 합집합을 구성하여 포함된 모든 열을 선택하게 된다. 
연속된 열 변호는 콜론(:) 연산자를 이용해서 나타낼 수 있다.

예제로서 데이터 프레임 `mtcars`의 행 이름을 변수 `row.name`으로 추가하고 tibble로 전환해 보자. 

```{r}
mtcars_t <- mtcars %>% 
  rownames_to_column(var = "row.name") %>% 
  as_tibble() %>% 
  print(n = 3)
```

이어서 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 선택해 보자. 이 경우에는
열 번호를 함수 `c()` 없이 그냥 나열해도 결과는 동일하다.

```{r}
mtcars_t %>% 
  select(1:3, 7)
```

열(변수) 이름은 열 번호와 같은 취급을 받는다. 따라서 다음 방법도 같은 결과를 생성한다.

```{r}
mtcars_t %>% 
  select(row.name:cyl, wt)
```

열을 제거하고자 하는 경우에는 논리 부정 연산자(!) 또는 마이너스(-) 연산자를 사용해야
한다. 함수 `c()` 안에 제거하고자 하는 열 번호를 나열하고 논리 부정 연산자를 그 앞에 붙이면 나열된 열로 이루어진 집합의 여집합을 구성하는 것이므로 결과적으로 해당되는 열들이 제거되는 것이다. 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수를 제거해 보자.

```{r}
mtcars_t %>% 
  select(!c(1:3, 7))
```

마이너스 연산자는 차집합을 구성하게 된다. 예컨대 `select(1:4, -1)`은 처음 네 변수
중 첫 번째 변수를 제거하라는 의미가 된다. 그러나 만일 `select(1:4, !1)`과 같이 논리
부정 연산자를 대신 사용하면 처음 네 변수와 첫 번째 변수를 제외한 나머지 변수와의 합
집합을 구성하는 것이 되어서 결국 모든 변수를 다 선택하게 된다.

비록 두 연산자의 의미는 다르지만, 마이너스 연산자가 첫 번째로 입력되면 같은 효과를
볼 수 있다. 따라서 첫 번째에서 세 번째 변수, 그리고 일곱 번째 변수의 제거는 다음과 같이 할 수도 있다.

```{r}
mtcars_t %>% 
  select(-c(1:3, 7))
```

2. 변수 유형에 의한 선택

특정 유형의 변수를 선택해야 하는 경우 유용하게 사용할 수 있는 방법이다. 
변수의 유형 파악은 함수 `is.numeric()` 또는 `is.character()` 등 `is.*()` 형태의 함수로 할 수 있다. 
이러한 함수들은 결과가 `TRUE` 또는 `FALSE` 중 하나가 되는데, 이런 함수를 `predicate` 함수라고 한다. 변수 유형에 의한 선택이란 함수 `where()` 안에 특정 `predicate` 함수를 입력해서 그 결과가 `TRUE`가 되는 변수를 선택하는 방법이다.

패키지 `ggplot2`의 데이터 프레임 `mpg`를 살펴보자.

```{r}
mpg %>% print(n = 3)
```

데이터 프레임 `mpg`에서 숫자형 변수만 선택해 보자.

```{r}
mpg %>% 
  select(where(is.numeric))
```

몇 가지 변수 유형을 함께 고려해야 하는 경우에는 논리 연산자 `&`와 `|`을 사용하게 된다.

예를 들어 숫자형 변수이거나 문자형 변수의 선택은 다음과 같다.

```{r}
mpg %>% 
  select(where(is.numeric) | where(is.character))
```

3. 변수 선택과 관련된 함수의 이용

변수 선택에 매우 유용하게 사용되는 함수들이 있다. 먼저 특정 위치의 열을 선택할 때
사용할 수 있는 함수들이다.

* `everything()` : 모든 변수 선택

* `last_col()` : 마지막 변수 선택

변수 이름을 구성하고 있는 문자열에 대한 매칭 작업으로 변수를 선택할 때 사용할 수
있는 함수들이다.

* `starts_with("x")`: 이름이 `x`로 시작하는 변수 선택

* `ends_with("x")`: 이름이 `x`로 끝나는 변수 선택

* `contains("x")`: 이름에 `x`가 있는 변수 선택

* `num_range("x", 1:10)`: `x1`, `x2`, ... , `x10`과 동일

변수 이름이 입력된 문자형 벡터를 이용하여 변수를 선택할 때 사용할 수 있는 함수들
이다.

* `all_of(vec)`: 문자형 벡터 `vec`에 이름이 입력된 변수 선택. 해당 데이터 프레임에 없는 변수 이름이 `vec`에 입력되어 있으면 오류 발생.

* `any_of(vec)`: 함수 `all_of()`와 동일함. 단, 데이터 프레임에 없는 변수 이름이 입력
되어도 오류가 발생하지 않음.

예제로 데이터 프레임 `mtcars_t`에서 첫 번째 변수와 마지막 변수를 선택해 보자.

```{r}
mtcars_t %>% 
  select(1, last_col())
```

이번에는 `mtcars_t`에서 이름이 `m`으로 시작하는 변수를 선택해 보자.

```{r}
mtcars_t %>% 
  select(starts_with("m"))
```

이름이 `p`로 끝나는 변수도 선택해 보자.

```{r}
mtcars_t %>% 
  select(ends_with("p"))
```

이름에 `A`가 있는 변수를 선택해 보자.

```{r}
mtcars_t %>% 
  select(contains("A"))
```

대문자 `A`가 이름에 있는 변수 선택을 요구했지만, 결과는 모두 소문자 `a`가 이름에
있는 변수가 선택되었다. 이런 결과가 나온 이유는 옵션 `ignore.case = TRUE`가 디폴트로
설정되어서 대문자와 소문자를 구분하지 않기 때문이다. 이 옵션은 함수 `starts_with()`와
`ends_with()`에도 동일하게 `TRUE`가 디폴트이다. 
만일 대문자를 구분해서 문자열 매칭 작업을 하면 다음과 같이 해당되는 변수가 없다는 결과가 나온다.

```{r}
mtcars_t %>% 
  select(contains("A", ignore.case = FALSE))
```

문자형 벡터 `vars`에 다음과 같이 변수 이름을 입력해 보자. 앞에서 생성된 데이터 프레임 `mtcars_t`에는 변수 `mpg`와 `wt`는 있지만, 변수 `model`은 없는 상태이다. 

```{r}
vars <- c("model", "mpg", "wt")
```

함수 `any_of()`를 사용하면 `mtcars_t`에 있는 두 변수가 선택된다. 

```{r}
mtcars_t %>% 
  select(any_of(vars))
```

함수 `all_of()`를 사용하게 되면 `model`이 `mtcars_t`에 없는 변수이기 때문에 오류가 발생하게 된다. 

```{r, error=TRUE}
mtcars_t %>% 
  select(all_of(vars))
```

당연한 것이지만, 지금까지 살펴본 세 가지 변수 선택 방법은 서로 혼합해서 사용할 수
있다. 예를 들어 숫자형 변수 중에 이름에 `a`가 변수는 다음과 같이 선택할 수 있다.

```{r}
mtcars_t %>% 
  select(where(is.numeric) & contains("c"))
```

* 벡터 형태로 변수 선택: 함수 `pull()`

데이터 프레임의 한 변수를 선택하여 벡터로 추출하고자 한다면 함수 `pull()`을 사용하면
된다. 변수 선택 방법은 옵션 `var`에 변수 이름을 지정하거나, 위치를 나타내는 정수를 지정하는
것이다. 양의 정수는 첫 번째 변수를 시작점으로 하는 위치이고, 음의 정수는 마지막 변수
를 시작점으로 하는 위치이다. 디폴트는 `var = -1`로 설정되어 있어서, 마지막 변수가 선택된다. 데이터 프레임 `mtcars`를 대상으로 마지막 변수와 세 번째 변수, 그리고 변수 `am`을 벡터 형태로 선택해 보자.

```{r}
mtcars_t %>% pull()
```

```{r}
mtcars_t %>% pull(var = 3)
```


```{r}
mtcars_t %>% pull(var = am)
```


### 열 이름 변경: `rename()`과 `rename_with()`

변수 이름이 매우 복잡하거나 사용하기 불편해서 이름을 변경해야 하는 경우가 많다. 함수
`select()`로도 변수 이름을 변경할 수 있으나, 함수 내에서 이름이 명시되지 않은 변수는
선택되지 않은 변수가 되어 제거되고, 이름이 변경된 변수만 남게 된다. 
변수에 새로운 이름을 주는 방식은 `new_name = old_name`이 되는데, `old_name` 자리에는 변수 이름 또는 변수의 열 번호가 올 수 있다.

```{r}
mtcars_t %>% 
  select(model = row.name)
```

```{r}
mtcars_t %>% 
  select(model = 1)
```

함수 `select()`에서 이름이 변경되지 않은 변수도 모두 그대로 유지하려면 함수 `everything()`을 함께 사용하면 된다.

```{r}
mtcars_t %>% 
  select(model = row.name, everything())
```

함수 `rename()`을 사용하면 이름이 변경되지 않은 변수도 모두 그대로 유지가 된다. 
변수에 새로운 이름을 주는 방식은 함수 `select()`와 동일하게 `new_name = old_name`이다.

```{r}
mtcars_t %>% 
  rename(model = row.name)
```

많은 변수의 이름을 어떤 공통된 양식에 따라 모두 바꿔야 하는 경우, 하나씩 `new_name
= old_name`으로 변경하는 방식은 매우 비효율적이 될 수 있다. 예컨대 대문자로 입력된
변수 이름을 모두 소문자로 변경하거나, 이름 중간에 들어간 점(.)을 밑줄(_)로 변경해야
하는 경우에 하나씩 변경하는 방식이 아닌 해당되는 변수의 이름을 한꺼번에 모두 바꿀 수
있는 방식이 필요한 것이다. 이러한 작업은 함수 `rename_with()`로 할 수 있다.

데이터 프레임 `mtcars_t`의 모든 변수 이름을 대문자로 변경해 보자. 
함수 `rename_with()`에는 기존의 변수 이름을 새로운 이름으로 바꿀 수 있는 함수를 
지정해야 한다. 모든 변수를 대문자로 변경하는 작업이므로 함수 `toupper()`를 사용하면 된다.

```{r}
mtcars_t %>% 
  rename_with(toupper)
```

모든 변수가 이름 변경 대상이 되는 것이 디폴트이다. 
변경 대상 변수를 선택을 해야 하는 경우에는 함수 `select()`에서 사용했던 `<tidy-select>`의 방식으로 선택하여 함수 `rename_with()`의 세 번째 입력요소로 지정하면 된다. 이름에 `a`가 포함되어 있는 변수의 이름을 대문자로 바꾸어 보자.

```{r}
mtcars_t %>% 
  rename_with(toupper, contains("a"))
```


### 열의 위치 변경: `relocate()`

열의 위치를 변경해야 하는 경우에 사용할 수 있는 함수이다. 위치를 바꿀 열은 `<tidy-select>`
방식을 사용하여 선택할 수 있어서, 여러 열의 위치를 한꺼번에 옮길 수 있다. 
제일 앞으로 이동되는 것이 디폴트 위치이며 옵션 `.after` 혹은 `.before`에서 위치를 지정할 수
있다.

데이터 프레임 `iris`의 마지막 변수 `Species`를 첫 번째 위치로 이동해 보자.

```{r}
iris_t <- as_tibble(iris)
```

```{r}
iris_t %>% 
  relocate(Species)
```

이름이 `th`로 끝나는 변수를 모두 `Species` 다음으로 이동하면 변수 `Species`를 첫 번째 위치로 이동하는 것이 된다.

```{r}
iris_t %>% 
  relocate(ends_with("th"), .after = Species)
```

특정 변수를 제일 앞으로 이동하는 작업은 함수 `select()`에 `everything()`을 함께 사용해서 할 수도 있다.

```{r}
iris_t %>% 
  select(Species, everything())
```


### 새로운 열의 추가: `mutate()`와 `transmute()`

데이터 프레임을 구성하고 있는 기존의 변수들을 이용하여 새로운 변수를 만들어 데이터
프레임에 추가해야 할 경우가 종종 있다. 이러한 작업을 수행하는 함수가 `mutate()`이다.
데이터 프레임이 함수 `mutate()`의 첫 번째 입력 요소가 되고, 이어서 새로운 변수를 만드는 표현식이 차례로 입력된다. 
새롭게 만들어진 변수는 데이터 프레임의 제일 마지막 변수로 추가된다. 만일 새롭게 만들어진 변수로만 데이터 프레임을 구성하고자 한다면 함수
`transmute()`를 사용하면 된다. 함수 `mutate()`와 `transmute()`에서 새로운 변수를 만들
때 유용하게 사용되는 함수들의 목록이 RStudio의 메뉴 `Help > Cheatsheets > Data
Transformation with dplyr`에 잘 정리되어 있다.

* 예제: `mtcars`

다음의 조건에 의하여 새로운 변수 `kml`과 `gp_kml`을 만들고 데이터 프레임에 첫 번째와 
두번째 변수로 추가해 보자.

∙ 변수 `kml`: 1 mpg(mile per gallon)는 0.43 kml(kilometer per liter)

∙ 변수 `gp_kml`: `kml`이 10 이상이면 `good`, 10 미만이면 `bad`

연속형 변수 `kml`을 기반으로 범주의 개수가 두 개인 범주형 변수 `gp_kml`를 생성하는
작업은 함수 `if_else()`를 사용하는 것이 효과적이다. 기본적인 사용법은 `if_else(condition,
true, false)`이며 `condition`이 만족되면 `true`의 값을 갖고, 아니면 `false`의 값을 갖게 된다. 조건의 만족 여부에 따라 할당되는 두 가지 값의 유형은 같아야 한다.

```{r}
as_tibble(mtcars) %>% 
  mutate(kml = 0.43*mpg,
         gp_kml = if_else(kml >= 10, "good", "bad")
         ) %>% 
  relocate(kml, gp_kml) %>% 
  print(n=3)
```

연속형 변수를 기반으로 범주의 개수가 3개 이상이 되는 범주형 변수를 생성하려는 경우에 함수 `if_else()`를 사용하는 것은 적절하지 않을 수 있다. 이러한 경우에는 함수
`case_when()`이 효과적인 대안이 된다. 기본적인 형태는 `LHS ~ RHS`로서, `LHS`는 조건이고,
`RHS`에는 할당하려는 값이 된다. 다음 구조에서는 `condition_1`이 `TRUE`이면 `value_1`, `condition_1`은 `FALSE`이나 `condition_2`가 `TRUE`이면 `value_2`, 두 조건 모두 `FALSE`이면 `value_3`를 출력하게 된다.

```{r, eval=FALSE, prompt=FALSE}
case_when(
  condition_1 ~ value_1,
  condition_2 ~ value_2,
  TRUE ~ value_3
)
```

`LHS`에 제시되는 조건들은 순서대로 평가가 된다. 따라서 가장 좁은 범위의 조건이 가장
먼저 제시되어야 하고, 범위를 넓혀가는 조건이 잇따라 제시되어야 한다. 제시되는 조건의
개수에는 제한이 없다. 또한 `RHS`에 제시된 값들은 모두 같은 유형이어야 한다. 
이제 다음의 변경된 조건으로 변수 `gp_kml`을 생성해 보자.

∙ 변수 `gp_kml`: `kml`이 11 이상이면 `excellent`, 11 미만 8 이상이면 `good`, 8 미만이면 `bad`

```{r}
as_tibble(mtcars) %>% 
  mutate(kml = 0.43*mpg,
         gp_kml = case_when(
           kml < 8 ~ "bad",
           kml < 11 ~ "good",
           TRUE ~ "excellent"
           )
         ) %>% 
  relocate(kml, gp_kml) %>% 
  print(n=3)

```

만일 새로운 변수만 유지하고 나머지 변수는 모두 삭제하려고 한다면, 함수 `transmute()`를 사용하면 된다.

```{r}
as_tibble(mtcars) %>% 
  transmute(kml = 0.43*mpg,
         gp_kml = if_else(kml >= 10, "good", "bad")
  ) %>% 
  print(n=3)
```


## 여러 행 자료의 요약: `summarise()`

변수들의 요약통계량을 계산할 때 유용하게 사용되는 함수가 `summarise()`이다. 첫 번째
입력 요소는 데이터 프레임이고, 이어서 `name=fun`의 형태로 원하는 요약통계량 값을 계산할 함수와 열의 이름을 입력한다. 예를 들어 데이터 프레임 `mpg`의 변수 `hwy`의 전체 케이스와 서로 다른 값을 갖고 있는 케이스의 개수, 그리고 평균값을 계산해 보자. 
전체 케이스는 함수 `n()`으로, 서로 다른 값을 갖는 케이스의 개수는 `n_distinct()`로 계산한다.

```{r}
mpg %>% 
  summarise(n = n(), n_hwy = n_distinct(), avg_hwy = mean(hwy))
```


















# R 데이터 구조 {#data-structure}

통계학에서 데이터는 양적 데이터와 질적 데이터로 구분된다. 양적 데이터는
숫자형 데이터를 의미하는 것으로서 연속형과 이산형 데이터로 구분할 수
있다. 질적 데이터는 범주형 데이터라고도 하며, 다시 명목형과 순서형으로
구분된다. 또한 통계 데이터 세트란 데이터들이 행과 열의 2차원 형태로
배열된 상태를 의미한다. 열은 변수를 나타내며 하나의 열에는 같은 유형의
데이터만이 올 수 있고, 행은 동일 대상에 대한 여러 변수들의 관찰값을
나타낸다.

이렇듯 분석 대상이 되는 통계 데이터는 다양한 유형과 구조를 가지고 있다.
데이터의 다양한 구조를 표현하기 위해 R에서는 벡터, 요인, 행렬, 배열,
데이터 프레임 그리고 리스트라는 이름의 데이터 객체가 있다. 벡터는 하나의
변수를 나타내기 위한 1차원 구조이고, 요인은 범주형 자료를 나타내기 위한
구조이며, 행렬과 데이터 프레임은 2차원 구조, 배열은 2차원 이상의 구조를
가진 데이터 형태이다. 리스트는 가장 포괄적인 형태의 구조로서 여러 유형,
여러 형태의 데이터를 한데 묶은 형태를 취하고 있다. 이 장에서는 다양한
데이터 객체를 생성하는 방법 및 각 객체들의 중요한 특성들을 살펴보고자
한다.

## 벡터

벡터는 하나의 변수를 나타내기 위한 것으로써 1차원으로 배열된 데이터
구조를 갖고 있다. 한 변수를 나타내는 것이므로, 벡터를 구성하고 있는
자료는 모두 동일한 유형이어야 하며, 그 유형에 따라 논리형(logical),
숫자형(numeric), 문자형(character)으로 구분된다. 숫자형 벡터는 다시
정수형(integer)과 실수형(double)으로 세분된다.

### 벡터의 기본 특성

-   벡터의 생성

벡터는 함수 `c()`로 만들 수 있다.

```{r}
x <- c(TRUE, FALSE, TRUE)
y1 <- c(1L, 3L, 5L)
y2 <- c(1.1, 3.5, 10.4)
z <- c("one", "two", "three")
```

`x`는 논리형, `y1`은 정수형, `y2`는 실수형, `z`는 문자형 벡터이다.
논리형 벡터는 `TRUE` 혹은 `FALSE`로 이루어진 가장 단순한 형태를 갖고
있으며, 벡터의 비교 결과로 주로 생성된다. 정수형 벡터 `y1`을 만들 때
사용된 숫자 뒤에 붙는 기호 `L`은 유형을 정수로 지정하는 효과가 있다.
정수형 벡터와 실수형 벡터는 합쳐서 숫자형 벡터로 분류되며, 문자형 벡터의
구성인자들은 모두 인용부호 `" "` 혹은 `' '` 안에 있어야 한다.

-   벡터의 특성

벡터의 유형 확인은 함수 `typeof()`로 할 수 있다.

```{r}
typeof(x)
typeof(y1)
typeof(y2)
typeof(z)
```

벡터를 구성하고 있는 요소의 개수, 즉 벡터의 길이 확인은 함수 `length()`로
할 수 있다. 예를 들어 `length(y2)`는 벡터 `y2`가 몇 개의 숫자로 구성되어
있는지를 확인하는 것으로 결과는 3이 된다.

구성요소가 하나인 벡터를 스칼라(scalar)라고 하는데, 스칼라를 만들 때에는
함수 `c()`를 사용하지 않아도 된다. 즉, `a <- 1` 혹은 `a <- c(1)` 모두
숫자형 벡터 `a`를 생성한다.

벡터는 동일한 유형의 데이터만으로 구성할 수 있는데, 만일 다른 유형의
데이터가 뒤섞여서 있다면 어떤 일이 벌어지겠는가? 아래의 예에서 그 답을
찾을 수 있다.

```{r}
c(1, "1", TRUE)
c(3, TRUE, FALSE)
```

첫 번째 예에서 `1`은 숫자형, `"1"`은 문자형, `TRUE`는 논리형 데이터이다.
이 데이터를 뒤섞어 입력하면 그 결과는 모두 문자형 데이터로 통일된다.
이것은 문자형이 가장 복잡한 형태의 유형이기 때문이다. 두 번째 예는
숫자형과 논리형 데이터를 함께 입력한 경우이다. 이런 경우에는 논리형
데이터가 숫자형으로 변환되는데, `TRUE`는 `1`로, `FALSE`는 `0`으로
변환된다. 이것 또한 숫자형이 논리형보다 더 복잡한 유형의 구조이기
때문이다.

-   벡터 구성요소에 이름 붙이기

모든 벡터는 각 개별 자료에 이름을 붙일 수 있다. 예를 들어 서울, 부산,
인천, 수원의 인구(천 명 단위)를 숫자형 벡터로 입력하면서 각 숫자에 도시
이름을 붙일 수 있다.

```{r}
c(Seoul=9930, Busan=3497, Inchon=2944, Suwon=1194)
```

이미 생성된 벡터의 각 개별자료에 이름을 붙이는 것은 함수 `names()`로 할
수 있다.

```{r}
pop <- c(9930,3497,2944,1194)
names(pop) <- c("Seoul", "Busan", "Inchon", "Suwon")
pop
```

-   함수 `scan()`에 의한 벡터 생성

함수 `scan()`은 다양한 기능을 지니고 있는 함수로서 직접 벡터를 생성할
수도 있고 외부 데이터 파일을 불러와서 벡터에 할당할 수도 있다. 직접
벡터를 생성하기 위해서는 함수 `scan()`을 그냥 실행하면 된다. 그러면
Console의 프롬프트가 `>` 기호에서 `1:` 기호로 바뀌는데, 이것은 첫 번째
자료의 입력을 기다리고 있다는 것을 의미한다. 이어서 데이터를 직접
입력하거나 또는 복사하고 붙여넣기를 할 수 있으며, 한 줄에 여러 개의
숫자를 빈 칸으로 구분하여 입력할 수도 있다. 아래의 예에서 4개 숫자의
입력이 끝나고 나타나는 `5:` 프롬프트에서 그냥 Enter 키를 치면 데이터의
입력이 종료된 것으로 인식한다.

![](Figure/scan_num.png)

문자형 벡터의 입력은 옵션 `what="character"`를 포함해야 한다. 함수
`c()`의 경우와는 다르게 각각의 자료에 인용부호를 사용할 필요는 없으나,
만일 자료에 빈칸이 포함되어 있다면 그 자료를 인용부호로 감싸야 한다.

![](Figure/scan_char.png)

한 변수의 자료가 입력되어 있는 데이터 파일을 벡터로 불러오고자 하는
경우에도 함수 `scan()`을 사용할 수 있다. 텍스트 파일에 입력된 각
자료들은 반드시 한 칸 이상의 빈 칸으로 구분되어 있어야 한다. 예를 들어
`Data` 폴더에 있는 파일 data1.txt에 다음과 같이 데이터가 저장되어
있다고 하자. 이것을 벡터 `z`에 입력시키는 방법은 다음과 같이 `scan()`에
불러올 파일이 저장된 위치를 입력하면 된다.

![](Figure/data1.png){#data1.txt}


```{r}
z <- scan("Data/data1.txt")
z
```

### 다양한 형태를 갖는 벡터의 생성

이 절에서는 기존의 벡터에 데이터를 추가하거나 여러 벡터들을 결합하여
하나의 벡터를 만드는 방법 및 일정한 구조를 갖는 벡터의 생성 방법을
살펴보겠다.

#### 벡터에 데이터 추가 및 벡터들의 결합

기존의 벡터에 추가적으로 데이터를 덧붙이는 작업이나 벡터들을 결합하는
작업은 함수 `c()` 또는 함수 `append()`를 이용하여 할 수 있다. 우선
`c()`에 의한 결합 예를 살펴보자.

```{r}
x <- c(11,12,13,14)
c(x, 15)
y <- c(16,17,18)
c(x, y)
```

함수 `append()`는 추가되는 스칼라 혹은 벡터의 위치를 옵션 `after`로
지정할 수 있다.

```{r}
append(x, 15)
append(x, 15, after = 2)
append(x, y)
append(x, y, after = 3)
```

#### 일정한 구조를 갖는 벡터의 생성

일정한 구조를 갖고 있는 벡터가 필요한 경우가 있다. 예를 들어 1부터
100까지의 정수로 이루어진 벡터를 만들어야 한다고 하자. 이러한 경우
`c()`에 숫자를 하나하나 입력해야 한다면 무척 한심스러운 일이 될 것이다.
`콜론(:)` 연산자 또는 `seq()`를 이용하면 일정한 간격이 있는 자료를 쉽게
만들 수 있으며, `rep()`를 이용하면 반복된 패턴이 있는 자료를 간편하게
만들 수 있다.

-   콜론 연산자

콜론 연산자는 연산자의 왼쪽 숫자에서 시작하여 오른쪽 숫자를 초과하지
않을 때까지 1씩 증가하는 수열을 만든다. 왼쪽의 숫자가 오른쪽의 숫자보다
크면 1씩 감소를 시킨다.

```{r}
1:5
-3:3
1.5:5.4
5:0
```

-   함수 `seq()`에 의한 수열 생성

콜론 연산자는 만들고자 하는 수열의 증가 폭이 1인 경우에만 사용할 수
있다는 한계가 있다. 조금 더 일반적인 형태의 수열을 만드는 작업은 함수
`seq()`를 사용해야 한다. 가장 기본적인 형태는 옵션 `from`과 `to`가
있으면서 `by`와 `length`로 수열의 간격 또는 개수를 지정하는 것이다.
시작점(from)과 끝점(to)만이 있다면, 콜론 연산자의 경우와 같이 간격이 1이
된다. 옵션 `by`는 간격을 지정하는 것으로써 `from`에서 시작하여 `by` 만큼
증가(감소)를 시키되 `to`를 지나치지 않는 수열을 생성한다. 옵션
`length`는 수열의 개수를 지정하는 것으로써 `from`과 `to`를 포함하는
간격이 일정한 수열을 생성한다. 만일 옵션 `to`가 없다면, `from`에서
시작하여 `by` 만큼의 간격이 있는 `length`개의 수열을 구성한다.

```{r}
seq(from = 0, to = 5)   
seq(from = 0, to = 5, by = 2)
seq(from = 0, to = 5, length = 3)
seq(from = 0, by = 2, length = 3)
```

함수 `seq()`에 하나의 숫자만을 입력하면 1을 시작점으로 하여 1씩
증가(감소)하여 지정된 숫자를 끝점으로 하는 수열이 만들어진다.

```{r}
seq(3)
seq(-3)
```

주어진 벡터와 길이가 같으면서, 1에서부터 시작하고 간격이 1인 수열이
필요한 경우가 있다. 이러한 경우에는 함수 `seq()`의 옵션 `along`에
해당되는 벡터를 지정하거나, 옵션 `length`에 해당 벡터의 길이를 지정하면
된다. 또는 함수 `seq_along()` 혹은 함수 `seq_len()`을 대신 사용해도
된다.

```{r}
x <- c(24,31,29)
seq(along = x)
seq(length = length(x))
seq_along(x)
seq_len(length(x))
```

-   함수 `rep()`에 의한 반복된 패턴이 있는 데이터 생성

함수 `rep()`는 옵션 `times`와 `each`, `length`를 이용하여 다양한 형태의
반복된 패턴이 있는 데이터를 만들 수 있다. 옵션 `times`는 반복 횟수를
지정하는 것으로써 하나의 정수를 지정할 때와 반복시키려는 벡터의 길이와
같은 정수형 벡터를 지정할 때에 다른 결과가 나온다.

```{r}
rep(1, times = 3)     
rep(1:3, times = 2)
rep(c("M","F"), times = c(2,3))
```

옵션 `times`에 하나의 반복 횟수만 지정하면 데이터 전체를 지정된 횟수만큼
반복시킨다. 반복 대상이 `c("M","F")`이고 반복 횟수가 `c(2,3)`이 되어
일대일 대응이 되는 경우에는 `M`이 두 번 먼저 반복되고 이어서 `F`가 세 번
반복된다.

옵션 `each`에 반복 횟수를 지정하면, 데이터의 요소들이 각각 each번
반복한다. 이어서 옵션 `times`를 추가하면 각 요소의 `each`번 반복 과정
전체가 `times`만큼 반복된다.

```{r}
rep(1:3, each = 2)
rep(1:3, times = rep(2,3))
rep(1:3, each = 2, times = 2)
```

옵션 `length`에 벡터의 길이를 지정하면, 길이가 `length`가 될 때까지
데이터 전체가 반복된다. 옵션 `each`를 함께 사용하면, 데이터 각 요소가
`each`번 반복되는 과정을 반복하여 결과 벡터의 길이가 `length`가 되도록
한다.

```{r}
rep(1:3, length = 6)
rep(1:3, each = 2, length = 8)
```

### 문자열을 위한 함수

R에는 문자열을 다루기 위한 매우 유용한 함수들이 있다. 우리는 종종 문자형
벡터에서 특 정 정보를 얻거나 문자형 벡터의 내용을 수정해야 할 때가
있는데 이런 경우 유용하게 사 용할 수 있는 함수들이 Table
\@ref(tab:char-func)에 있다.

```{r char-func, echo=FALSE}
col1 <- c('nchar(x)', 'paste(..., sep=\" \")', 'substr(x, start, stop)',
          'toupper(x)', 'tolower(x)', 'strsplit(x, split)',
          'sub(old, new, x)', 'gsub(old, new, x)')
col2 <- c('문자열 x를 구성하는 문자의 개수', '문자열의 결합', '문자열 일부분 선택',
          '영문자 대문자로 변환', '영문자 소문자로 변환', '문자열의 분리',
          '문자열 치환', '문자열 치환')
tab1 <- tibble::tibble(`함수` = col1, `기능` = col2)
knitr::kable(tab1, "pipe", caption = "문자 함수", booktabs = TRUE)
```

-   함수 `nchar()`: 문자열을 구성하는 문자 개수 계산

함수 `nchar()`는 문자열을 구성하고 있는 문자의 개수를 센다. 다음에
주어진 문자형 벡터 `x`의 첫 문자열은 4개, 두 번째는 3개, 마지막 문자열은
4개의 문자로 이루어졌다는 것을 알 수 있다. 한글로 이루어진 문자열도 문제
없이 문자 개수를 셀 수 있다.

```{r}
x <- c("Park","Lee","Kwon")
nchar(x)
nchar("응용통계학과")
```

-   함수 `paste()`: 문자열의 결합

여러 개의 문자열들을 적절하게 결합시켜 새로운 문자열을 만들어야 하는
경우가 자주 있다. 이런 경우에 함수 `paste()`가 매우 유용하게 사용된다.
함수 `paste()`의 기본적인 사용법은 결합시키고자 하는 문자열들을 차례로
입력하는 것이고, 옵션 `sep`에서 지정하는 문자 혹은 빈칸 등이 결합되는
문자열과 문자열 사이에 오게 된다.

5개의 문자열인 "모든", "사람에게는", "통계적", "사고능력이" 그리고
"필요하다"를 결합시켜 보자. 첫 번째는 옵션 `sep`의 디폴트 값인
`sep=" "`가 사용되어 결합되는 문자열들 사이에 하나의 빈칸이 생긴 것이고,
두 번째는 `sep="-"`가 지정되어 문자열들이 대시(dash) 기호로 결합되었고,
세 번째에는 `sep=""`이 사용되어 빈칸 없이 문자열들이 결합되었다.

```{r}
paste("모든", "사람에게는", "통계적", "사고능력이", "필요하다")
paste("모든", "사람에게는", "통계적", "사고능력이", "필요하다",
      sep="-")
paste("모든", "사람에게는", "통계적", "사고능력이", "필요하다",
      sep="")
```

함수 `paste()`에 입력된 숫자는 문자로 전환되어 문자열 결합에 사용된다.

```{r}
paste("원주율은", pi, "이다")
```

함수 `paste()` 안에 문자형 벡터 몇 개가 함께 들어오면 벡터들의 대응되는
요소끼리의 결합이 이루어진다. 이때 벡터의 길이가 서로 다르면, 순환법칙이
적용된다. 즉, 문자열 `"Stat"`과 벡터 `1:3`을 함께 입력하면 실제로는
`c("Stat","Stat","Stat")`과 `1:3`이 결합이 되는 것이고,
`c("Stat","Math")`와 `1:3`을 함께 입력하면, `c("Stat","Math", "Stat")`과
`1:3`이 결합되는 것이다.

```{r}
paste(c("Stat", "Math"), 1:2, sep = "")
paste("Stat", 1:3, sep="")
paste(c("Stat","Math"), 1:3, sep="-")
```

빈칸 없이 문자열을 결합시킬 때에는 함수 `paste()`에 옵션 `sep=""`을
추가하는 것보다 그냥 함수 `paste0()`을 사용하는 것이 더 편리하다.

```{r}
paste0("stat", 1:3)
```

한 개의 문자형 벡터를 구성하고 있는 모든 문자열을 묶어서 하나의 문자열로
나타내는 작업이 필요한 경우가 있다. 이때는 옵션 `collapse`를 사용하면
된다. 영문자 소문자와 대문자로 구성된 문자형 벡터 `letters`와
`LETTERS`를 각각 하나의 문자열로 합쳐보자.

```{r}
letters
paste0(letters, collapse = "")
paste(LETTERS, collapse = ",")
```

하나의 문자열로 합쳐질 때 옵션 `collapse`에 지정한 문자가 일종의 구분자
역할을 하고 있다.

함수 `paste()`에 두 개의 문자형 벡터를 입력하고, 이어서 옵션
`collapse`를 사용하면 입력된 두 문자형 벡터를 하나의 문자형 벡터로
결합시키고, 이어서 모든 문자열을 묶어서 하나의 문자열로 나타낸다.

```{r}
paste0(letters, LETTERS, collapse = ",")
paste(letters, LETTERS, sep = "-", collapse = ",")
```

-   함수 `substr()`: 문자열에서 일부분 선택

주어진 문자열에서 일부분을 선택해야 하는 작업도 빈번히 일어나는 중요한
작업 중 하나이다. 함수 `substr()`에는 문자형 벡터, 시작점, 끝점이
차례로 입력된다. 시작점과 끝점은 각각 정수형 스칼라 혹은 벡터가 된다.

시작점과 끝점이 벡터가 되면, 대응되는 숫자끼리 시작점과 끝점을 구성하며
필요하다면 순환법칙도 적용된다. 아래 예의 첫 번째 결과는 문자형 벡터
`x`를 구성하고 있는 세 문자에 대하여 동일하게 시작점과 끝점을 하나의
숫자로 지정하여 추출한 것이다. 두 번째 결과는 시작점과 끝점이 벡터로
지정된 것으로 첫 번째 문자열에는 (시작점=1, 끝점=2), 두 번째 문자열에는
(시작 점=3, 끝점=6), 그리고 세 번째 문자열에는 다시 (시작점=1, 끝점=2)가
적용된 결과이다.

```{r}
substr("Statistics", 1, 4)
x <- c("응용통계학과", "정보통계학과", "학생회장") 
substr(x, 3, 6)
substr(x, c(1,3), c(2,6))
```

미국의 세 도시와 그 도시가 속한 주 이름이 입력된 문자형 벡터 `x`에서 세
도시가 속한 주 이름만을 선택하여 출력해 보자. 비록 세 문자열의 길이가
서로 다르지만 주의 이름은 각 문자열의 마지막 두 칸에 있다는 점에
착안하여 함수 `nchar()`로 시작점과 끝점을 지정할 수 있다.

```{r}
x <- c("New York, NY","Ann Arbor, MI","Chicago, IL")
substr(x, start=nchar(x)-1, stop=nchar(x))
```

패키지 `ggplot2`에 있는 데이터 프레임 `mpg`는 자동차의 연비와 관련된
자료이다. 11개의 변수 중 `trans`는 변속기 종류를 나타내는 변수이다. 변수
`trans`가 갖는 값을 살펴보자. 함수 `library()`로 패키지를 로딩하지 않은
상태에서 해당 패키지의 데이터를 불러오려면 `패키지::데이터`의 형식을
사용하면 된다. `mpg$trans`는 데이터 프레임 `mpg`의 변수 `trans`를 벡터
형태로 선택한 것이며 자세한 설명은 \@ref(section-dataframe)절에서 찾아볼
수 있다. 또한 함수 `table()`로 문자형 벡터를 구성하고 있는 각 문자열의
빈도를 계산할 수 있다.

```{r}
x <- ggplot2::mpg$trans
table(x)
```

`auto(av)`부터 `auto(s6)`까지를 `auto`로 통합하고 `manual(m5)`와 `manual(m6)`를
`manual`로 통합하는 작업은 시작점을 `1`, 끝점을 `nchar(x)-4`로
지정함으로써 가능하다.

```{r}
y <- substr(x, start = 1, stop = nchar(x) - 4)
table(y)
```

-   함수 `strsplit()`: 문자열의 분할

여러 문자열들을 서로 결합하는 것도 중요한 작업이지만 하나의 문자열을 몇
개로 분리하는 것도 매우 중요한 작업이다. 함수 `strsplit()`는 주어진
문자열을 옵션 `split`에 지정된 기준에 의하여 분리시킨다.

문자형 벡터 `x`에 입력된 세 도시의 이름과 주 이름을 분리해 보자. 도시
이름과 주 이름이 콤마로 구분되어 있기 때문에 분리 기준으로 옵션
`split=","`을 지정하였다. 결과는 리스트로 출력된다. R 데이터 구조 중
하나인 리스트에 대한 소개는 \@ref(section-list)절에 있다.

```{r}
x <- c("New York, NY","Ann Arbor, MI","Chicago, IL")
(y <- strsplit(x, split = ","))
unlist(y)
```

리스트 `y`를 생성하는 할당문 전체가 괄호로 감싸여 있는데, 이렇게
할당문을 괄호로 감싸면 할당된 객체의 값이 출력됨을 볼 수 있다. 또한
리스트 객체를 함수 `unlist()`에 입력하면, 리스트의 모든 구성요소들로
이루어진 벡터가 만들어진다.

문자열을 구성하는 개별 문자들을 모두 분리시키는 작업도 가능한데, 이
경우에는 분리 기준이 옵션 `split = ""`이 되어야 한다.

```{r}
unlist(strsplit("PARK", split = ""))
```

점(.)이 포함된 문자열에서 점을 기준으로 분리하고자 하는 경우에 옵션
`split="."`을 지정하는 것으로는 원하는 결과를 얻을 수 없다. 옵션
`split`에는 정규 표현식(regular expression)이 사용되는데, 정규 표현식에서
점은 다른 의미를 갖고 있는 특수 기호로 사용된다. 이러한 경우에는 또 다른
기호인 대괄호를 함께 사용하면 원하는 결과를 얻을 수 있다. 정규 표현식에
대한 대략적인 소개는 \@ref(ch6)장에서 볼 수 있다.

```{r}
unlist(strsplit("a.b.c", split = "."))
unlist(strsplit("a.b.c", split = "[.]"))
```

-   함수 `toupper()`와 `tolower()`

가끔 주어진 문자형 벡터를 구성하는 영문자들의 대문자 혹은 소문자를 서로
바꿔야 하는 경우가 생긴다. 이러한 경우에 유용하게 사용할 수 있는 함수가
`toupper()`와 `tolower()` 이다.

```{r}
x <- c("park","lee","kwon")
(y <- toupper(x))
tolower(y)
```

문자열 전체를 바꾸는 것이 아닌 특정 위치에 있는 것만 바꿔야 할 경우가
있다. 문자형 벡터 `x`를 구성하고 있는 세 문자열의 첫 글자만 대문자로
바꿔보자. 이 경우 우선 함수 `substr()`로 첫 글자를 추출하고, 그것을 함수
`toupper()`로 대문자로 변환시킨 후, 그 결 과를 다시 함수 `substr()`로
추출한 첫 글자를 치환하면 된다.

```{r}
x
substr(x,1,1) <- toupper(substr(x,1,1))
x
```

-   함수 `sub()`와 `gsub()`: 문자열의 치환

문자열의 일부를 수정하는 작업은 매우 중요한 작업이라 하겠다. 두 함수의
일반적인 사용법은 `sub(old, new, x)`과 `gsub(old, new, x)`이 되는데,
문자형 벡터 `x`를 구성하고 있는 각 문자열 중 `old`를 `new`로 치환하는
것이다. 두 함수의 차이점으로 함수 `sub()`는 각 문자열 중 첫 번째
`old`만을 `new`로 치환하지만, 함수 `gsub()`는 각 문자열의 모든 `old`를
`new`로 치환한다는 것이다.

```{r}
x <- "Park hates stats. He hates math, too."
sub("hat", "lov", x)
gsub("hat", "lov" ,x)
```

문자형 벡터를 구성하고 있는 각 원소의 치환도 가능하다.

```{r}
(y <- paste0("banana", 1:3))
sub("a", "A", y)
gsub("a", "A", y)
```

문자열의 일부를 삭제하고자 한다면 `new`에 `""`을 입력하면 된다.

```{r}
z <- "Everybody cannot do it"
sub("not", "", z)
```

### 벡터의 연산

벡터와 벡터의 연산은 대응되는 각 구성요소끼리의 연산, 즉 벡터 단위로
이루어진다. 이것의 의미는 다음의 예에서 확인할 수 있다.

```{r}
x <- c(7,8,9,10)
y <- c(1,2,3,4)
x+y
x-y
x*y
x/y
x^y
```

두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산, 즉 첫 번째
숫자끼리 연산, 두 번째 숫자끼리 연산 등등으로 이루어진다. 벡터와
스칼라의 연산도 동일한 개념으로 수행 되어 벡터의 모든 구성요소와
스칼라와의 연산이 이루어진다.

```{r}
x
x+3
x/4
2^x
```

벡터 연산은 R의 가장 큰 강점 중 하나이다. 벡터 단위의 연산이 가능하지
않은 다른 소프트웨어에서 R의 벡터 연산과 동일한 작업을 수행하기
위해서는 루프(loop)에 의한 반복 작업이 이루어져야 하며, 이것은 프로그램의
복잡성뿐만이 아니라 처리속도에도 악영향을 미치게 된다.

벡터의 연산 결과로 나타날 수 있는 특수 기호에는 `Inf`, `-Inf`, `NaN`
등이 있다. `Inf`와 `–Inf`는 무한대와 마이너스 무한대를 나타내는 것이고
`NaN`은 'Not a Number'를 나타내는 기호이다.

```{r}
c(-1,0,1)/0
```

`NaN`은 0/0 외에도 계산을 할 수 없는 몇몇 상황에서 발생한다.

```{r}
sqrt(-1)
Inf-Inf
Inf/Inf
```

-   벡터 연산의 순환법칙

R에서 두 벡터의 연산은 각 벡터의 대응되는 구성요소끼리의 연산으로
이루어지는데, 만일 두 벡터의 길이가 달라 일대일 대응이 되지 않는다면
어떤 일이 벌어지겠는가? 이런 경 우에는 길이가 짧은 벡터의 구성요소를
순환 반복시켜 길이가 긴 벡터의 구성요소와 짝을 짓게 된다. 예를 들어
`1:6 + 1:3`의 경우에는 길이가 3인 `1:3`을 한 번 반복시켜서 길이가 6인
`c(1,2,3,1,2,3)`을 만든 후 벡터 연산을 수행하게 된다.

```{r}
1:6 + 1:3
1:6 + rep(1:3,2)
```

이와 같은 연산의 순환법칙은 비단 벡터 연산의 경우에만 국한되는 것은
아니고, 다양한 함수의 적용 과정에서도 이 순환법칙이 사용되고 있다.
앞으로 많은 경우에 있어서 순환법칙이 적용되는 상황을 보게 될 것이다.
사실 벡터와 스칼라의 연산도 순환법칙이 적용된 결과로서 `c(7,8,9,10)`과
3의 덧셈은 3이 4번 반복되어 `c(3,3,3,3)`이 된 후 덧셈이 이루어지는
것이다.

이러한 순환법칙이 실행될 때 긴 벡터의 길이가 짧은 벡터 길이의 배수가
아니라면 짧은 벡터를 순환 반복시키더라도 긴 벡터와 길이를 동일하게 만들
수 없게 되다. 이런 경우 R은 경고 문구를 내보낸다.

```{r}
1:4 + 1:3
```

의도적으로 순환법칙을 사용하지 않은 경우에 이와 같은 경고 문구를 보게
되면 무엇이 문제인지를 면밀히 검토해보는 것이 좋을 것이다. 대부분의 경우
잘못된 연산이 수행되었을 것이다.

-   수학 계산 관련 함수

R에는 숫자형 벡터를 위한 다양한 함수가 있다. 먼저 기본적인 수학계산과
관련된 함수들 을 살펴보자. Table \@ref(tab:math-func)에 있는 함수들의
사용 예는 다음과 같다.

```{r math-func, echo=FALSE}
col1 <- c('abs(x)', 'sqrt(x)', 'ceiling(x)', 'floor(x)', 'trunc(x)',
          'round(x, n)', 'signif(x, n)', 'log(x)', 'log10(x)', 'exp(x)')
col2 <- c('절댓값 계산', '제곱근 계산', 'x보다 작지 않은 가장 작은 정수',
          'x보다 크지 않은 가장 큰 정수', 'x의 소수점 이하 버림', 'x를 소수 n자리로 반올림',
          'x를 유효수 n자리로 반올림', 'x의 자연로그 값', 'x의 사용로그 값', 'x의 지수 함수 값')
tab1 <- tibble::tibble(`함수` = col1, `설명` = col2)
knitr::kable(tab1, "pipe", caption = "수학 계산과 관련된 함수")
```

```{r}
abs(-2)
sqrt(25)
ceiling(3.475)
floor(3.475)
trunc(5.99)
round(3.475,2)
signif(0.00347, 2)
sin(1); cos(1); tan(1)
asin(sin(1)); acos(cos(1)); atan(tan(1))
log(2,base=2)
log(10)
log10(10)
exp(log(10))
```

-   기초 통계 관련 함수

많이 사용되는 기초적인 통계 계산과 관련된 함수를 살펴보자. Table
\@ref(tab:stat-func)에 있는 함수들의 사용 예는 다음과 같다.

```{r stat-func, echo=FALSE}
col1 <- c('mean(x)', 'median(x)', 'range(x)', 'IQR(x)', 'sum(x)', 
          'diff(x, n)', 'min(x)', 'max(x)')
col2 <- c('산술 평균값', '중앙값', '최솟값과 최댓값', '사분위범위', '합', 
          '차분', '최솟값' , '최댓값')
tab1 <- tibble::tibble(`함수` = col1, `설명` = col2)
knitr::kable(tab1, "pipe", caption = "통계 관련 함수")
```

```{r}
x <- c(1,2,3,4,50)
mean(x)
median(x)
range(x)
IQR(x)
sd(x)
var(x)
sum(x)
min(x)
max(x)
diff(c(1,2,4,7,11))

```

-   결측값

데이터에는 그 규모에 관계 없이 결측값이 있을 수 있다. R에서는 결측값을
기호 `NA` (not available)로 표시한다. 주어진 데이터에 결측값의 포함
여부를 파악하는 것은 모든 분석의 시작이라고 할 수 있으며, 함수
`is.na()`로 그러한 작업을 할 수 있다.

```{r}
x <- c(1,0,3,5,NA)
is.na(x)
```

자료에 포함된 결측값의 개수는 함수 `is.na()`로 생성된 논리형 벡터를 함수
`sum()`에 입 력하면 계산할 수 있다.

```{r}
sum(is.na(x))
```

결측값의 포함여부를 비교 연산자를 이용하여 `x == NA`로 파악할 수 있을
것이라고 생각할 수도 있겠으나 결측값은 자기 자신을 포함한 어느 대상과도
비교되지 않는다. 따라서 `x == NA`의 결과는 모두 `NA`가 된다. 여기서 두
개의 등호를 연속해서 사용한 기호 `==`는 벡터의 비교에 사용되는 비교
연산자로써 자세한 설명은 \@ref(vector-compare)절에서 찾아볼 수 있다.

`NA`가 포함된 벡터를 수학 및 통계 관련 함수들에 적용시키면 많은 경우에
그 결과가 `NA` 로 출력되며 어떤 경우에는 함수의 실행이 중단되기도 한다.
이것은 R에서 `NA`를 중요한 요소로 인식하고 있다는 증거가 된다. 몇몇
함수의 경우 계산 과정에서 `NA`를 제외하고자 한다면 옵션 `na.rm=TRUE`를
사용해야 한다.

```{r}
mean(x)
max(x)
mean(x, na.rm = TRUE)
max(x, na.rm = TRUE)
```

### 벡터의 비교{#vector-compare}

두 벡터의 구성요소끼리 크기를 비교하거나, 혹은 벡터와 스칼라를 비교하는
작업 등은 그 자체로도 의미가 있지만 벡터의 인덱싱이나 벡터의 변환 등에서
필수적인 요소가 된다. 어느 경우든 적절한 비교를 위해서는 비교 연산자와
논리 연산자가 필요하다.

```{r, echo=FALSE}
col1 <- c('<', '<=', '>', '>=', '==', '!=', '!x', 'x | y', 'x & y')
col2 <- c('작다', '작거나 같다', '크다', '크거나 같다', '같다', '같지 않다', 
          'x가 아니다 (NOT)', 'x 또는 y (OR)', 'x 그리고 y (AND)')
tab1 <- tibble::tibble(`연산자` = col1, `기능` = col2)
knitr::kable(tab1, "pipe", caption = "비교/논리 연산자") 
```

R의 큰 강점 중 하나가 벡터 연산이 가능하다는 것인데 두 벡터의 비교도
벡터 연산으 로 이루어진다. 즉, 두 벡터 사이에 대응되는 구성요소끼리의
비교가 이루어지는 것이다. 따라서 3개의 숫자로 구성된 두 벡터를 비교하면
그 구성요소 각각을 비교한 3개의 `TRUE` 또는 `FALSE`가 결과로 출력된다.

```{r}
x <- c(3, 8, 2)
y <- c(5, 4, 2)
x > y
x >= y
x < y
x <= y
x == y
x != y
```

벡터와 스칼라의 비교는 숫자 하나를 벡터의 모든 구성요소와 비교하게 되는
것으로 연산의 순환법칙이 적용된 것이다.

```{r}
x <- 1:3
x > 2
x < 2
x <= 2 | x >= 3
x <= 2 & x >= 1
```

벡터의 비교가 이루어지면 벡터의 길이만큼의 논리형 벡터가 결과로
출력된다. 이때 만일 각 구성요소 차원의 세세한 결과보다 전체 비교 중 한
번이라도 사실이 있는지, 혹은 모든 비교가 사실인지가 중요한 결과인
경우에는 함수 `any()`와 `all()`이 유용하게 사용될 수 있다.

```{r}
x <- 1:5
any(x >= 4)
all(x >= 4)
```

주어진 벡터의 구성요소 중 특정 조건을 만족시키는 요소의 개수 혹은 비율을
알고자 하는 경우에도 논리형 벡터는 매우 유용하게 사용된다. 예를 들어
주어진 숫자형 벡터 `x` 중 4보다 크거나 같은 숫자의 개수와 비율은 다음과
같이 논리형 벡터를 함수 `sum()` 또는 `mean()`에 적용시켜 구할 수 있다.

```{r}
x <- 1:5
x >= 4
sum(x >= 4)
mean(x >= 4)
```

주어진 벡터의 구성요소 중 특정한 값이 포함되어 있는지를 확인해야 하는
경우에는 `%in%` 연산자가 매우 유용하게 사용된다.

```{r}
x <- 1:5
x %in% c(2,4)
```

벡터 `x`의 구성요소 하나하나와 `%in%` 연산자 오른쪽에 주어진 값을
비교하여 같은 값이 면 `TRUE`, 아니면 `FALSE`가 생성된다.

만일 벡터 `x`에 `c(2,4)`가 포함되어 있는지 여부를 `x == c(2,4)`로
확인하려고 한다면 어떤 결과가 나오는지 살펴보자.

```{r}
x == c(2,4)
```

여기에서 이루어진 작업은 길이가 다른 벡터 `x`와 `c(2,4)`에 대한
비교이다. 따라서 길이가 짧은 벡터 `c(2,4)`를 순환 반복시켜서
실질적으로는 `x == c(2,4,2,4,2)`가 실행된 것이므로, 원하는 작업을 수행한
것이 아니다.

### 벡터의 인덱싱

벡터의 인덱싱(indexing)이란 벡터의 일부분만을 선택하는 것을 의미하는
것으로, 하나의 대괄호를 인덱싱 기호로 사용한다. 즉, `x[a]`의 형태가
되는데, 여기서 `a`는 정수형 벡터와 논리형 벡터가 사용되며, 이름이 있는
벡터의 경우에는 문자형 벡터도 가능하다.

정수형 벡터가 모두 양수인 경우에는 지정된 위치의 자료를 선택하는 것이고,
모두 음수인 경우에는 지정된 위치의 자료를 제외하는 것이다. 양수와
음수를 혼합하여 지정할 수는 없다.

```{r}
y <- c(2, 4, 6, 8, 10)
y[c(1, 3, 5)]
y[c(-2, -4)]
```

같은 위치를 반복해서 지정할 수 있으며, 지정한 위치가 벡터의 길이보다
크면 지정할 자료가 없기 때문에 결측값인 `NA`가 출력된다.

```{r}
y[c(2, 2, 2)]
y[0]
y[6]
```

이름이 있는 벡터의 경우에는 문자형 벡터를 사용하여 인덱싱을 할 수 있다.
벡터 `pop`에서 `Seoul`과 `Suwon`의 인구만을 선택해 보자.

```{r}
pop <- c(Seoul = 9930, Busan = 3497, Inchon = 2944, Suwon = 1194)
pop[c("Seoul", "Suwon")]
```

논리형 벡터를 사용하는 경우에는 `TRUE`가 있는 위치의 자료만 선택되는데,
이러한 인덱싱은 벡터의 비교에 따른 자료 선택에서 유용하게 사용된다.

```{r}
y
y[c(TRUE, TRUE, FALSE, FALSE, TRUE)]
y>3
y[y>3]
```

-   조건에 의한 인덱싱

논리형 벡터에 의한 인덱싱의 경우에는 `TRUE`인 위치의 자료가 선택된다고
하였는데, 이러한 논리형 벡터는 주로 벡터의 비교 결과로 생성된다. 이것은
곧 주어진 조건을 만족시키는 요소만을 선택할 수 있다는 것을 의미한다.
벡터 `x`의 각 개별 값 중 벡터 `x`의 평균값보다 큰 값을 선택해 보자. 우선
벡터 `x`의 개별값과 평균값의 크기를 비교해 보자.

```{r}
x <- c(80, 88, 90, 93, 95, 94, 99, 78, 101)
x >= mean(x)
```

`FALSE`는 작은 경우를, `TRUE`는 크거나 같은 경우를 나타내고 있다. 이
결과를 대괄호에 입력시키면 평균값보다 크거나 같은 개별 값들만이 선택된다.

```{r}
x[x >= mean(x)]
```

위에서 소개된 방법을 이용하여 다음의 조건을 만족시키는 개별 관찰값을
각각 선택해 보자.

1)  평균으로부터 ±1 표준편차 안에 있는 관찰값

2)  평균으로부터 ±1 표준편차와 ±2 표준편차 사이에 있는 관찰값

3)  평균으로부터 ±2 표준편차를 벗어나는 관찰값

진행 절차는 우선 벡터 `x`를 표준화시켜 그것을 벡터 `z`에 할당하고 이어서
벡터 `z`로 각 조건을 나타내는 비교를 실시하여 그 결과를 벡터 `x`의
대괄호에 입력하면 된다. 평균으로 부터 ±2 표준편차를 벗어나는 관찰값은
없는 것으로 나타났다.

```{r}
z <- (x-mean(x))/sd(x)
x[abs(z) <= 1]               # 1
x[abs(z) > 1 & abs(z) <= 2]  # 2
x[abs(z) > 2]                # 3
```
